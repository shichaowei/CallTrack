<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Tue Mar 01 03:21:14 CET 2016 -->
<TITLE>
SmartOrganicLayouter (yFiles-2.12.0.1 API)
</TITLE>

<META NAME="keywords" CONTENT="y.layout.organic.SmartOrganicLayouter class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../apistylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="SmartOrganicLayouter (yFiles-2.12.0.1 API)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<FONT CLASS="ApiSearchFont" ><A HREF="http://kb.yworks.com/search/yfiles-api" TARGET="_Top">Search this API</A></FONT></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../y/layout/organic/ShuffleLayouter.html" title="class in y.layout.organic"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../y/layout/organic/SplitEdgeLayoutStage.html" title="class in y.layout.organic"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?y/layout/organic/SmartOrganicLayouter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SmartOrganicLayouter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
y.layout.organic</FONT>
<BR>
Class SmartOrganicLayouter</H2>
<PRE>
<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../y/layout/CanonicMultiStageLayouter.html" title="class in y.layout">y.layout.CanonicMultiStageLayouter</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>y.layout.organic.SmartOrganicLayouter</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../y/layout/Layouter.html" title="interface in y.layout">Layouter</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>SmartOrganicLayouter</B><DT>extends <A HREF="../../../y/layout/CanonicMultiStageLayouter.html" title="class in y.layout">CanonicMultiStageLayouter</A></DL>
</PRE>

<P>
This class can be used as a convenience class to gain access to a variety of
 organic layout algorithms. Its strength lies in being able to conveniently
 specify a ratio between quality and running time, as well as the ability to
 specify the degree of the compactness of the drawing and
 to guarantee non-overlapping nodes.
 <br>
 Note: This class is able to consider a partition grid structure (see <A HREF="../../../y/layout/grid/PartitionGrid.html" title="class in y.layout.grid"><CODE>PartitionGrid</CODE></A>).
 However, for common nodes (i.e., non-group nodes) it only considers single partition cells.
 Furthermore, the layout algorithm throws an <A HREF="../../../y/base/WrongGraphStructure.html" title="class in y.base"><CODE>WrongGraphStructure</CODE></A> if there is a partition grid
 and the descendants of a group node are assigned to different partition grid cells or if there
 are group nodes that are associated with group node mode data
 (see <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_DATA"><CODE>GROUP_NODE_MODE_DATA</CODE></A>)
 that is not equal to <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_NORMAL"><CODE>GROUP_NODE_MODE_NORMAL</CODE></A>.
<P>

<P>
<DL>
<!-- generated by yDoc 3.0_01   http://www.yworks.com/products/ydoc/   b0ac8294e88f500d32e0d39d807e8289e759a8f1e278a9... -->
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_DATA">GROUP_NODE_MODE_DATA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The data provider key for specifying how to handle group nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_FIX_BOUNDS">GROUP_NODE_MODE_FIX_BOUNDS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group node mode constant that can be used to tag a group node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_FIX_CONTENTS">GROUP_NODE_MODE_FIX_CONTENTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group node mode constant that can be used to tag a group node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_NORMAL">GROUP_NODE_MODE_NORMAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group node mode constant that can be used to tag a group node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA">NODE_SUBSET_DATA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The data provider key for specifying the node subset to be laid out.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#PREFERRED_EDGE_LENGTH_DATA">PREFERRED_EDGE_LENGTH_DATA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The data provider key for specifying the preferred edge lengths for each edge
 The algorithm expects to find <A HREF="../../../y/base/DataProvider.html#getInt(java.lang.Object)"><CODE>DataProvider.getInt(Object)</CODE></A> integer values associated with
 each edge.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL">SCOPE_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scope constant - used for laying out all nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET">SCOPE_MAINLY_SUBSET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scope constant - used for laying out mainly the subset of the nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET">SCOPE_SUBSET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scope constant - used for laying out the subset of nodes only.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_y.layout.Layouter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface y.layout.<A HREF="../../../y/layout/Layouter.html" title="interface in y.layout">Layouter</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../y/layout/Layouter.html#EDGE_ID_DPKEY">EDGE_ID_DPKEY</A>, <A HREF="../../../y/layout/Layouter.html#NODE_ID_DPKEY">NODE_ID_DPKEY</A>, <A HREF="../../../y/layout/Layouter.html#SELECTED_EDGES">SELECTED_EDGES</A>, <A HREF="../../../y/layout/Layouter.html#SELECTED_NODES">SELECTED_NODES</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SmartOrganicLayouter()">SmartOrganicLayouter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new SmartOrganicLayouter instance</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#canLayoutCore(y.layout.LayoutGraph)">canLayoutCore</A></B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subclasses have to provide information whether or not they
 can layout the given graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#configureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)">configureComponentLayouter</A></B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph,
                           <A HREF="../../../y/layout/ComponentLayouter.html" title="class in y.layout">ComponentLayouter</A>&nbsp;layouter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Configures the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A>
 and graph instance to adhere to the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA"><CODE>NODE_SUBSET_DATA</CODE></A> in case
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL"><CODE>SCOPE_ALL</CODE></A> is not set, and to use <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getMinimalNodeDistance()"><CODE>getMinimalNodeDistance()</CODE></A> also for distances between components.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#doLayout(y.layout.LayoutGraph)">doLayout</A></B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;layoutGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a layout for the given graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#doLayoutCore(y.layout.LayoutGraph)">doLayoutCore</A></B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subclasses have to provide core layout code in this method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getAutoClusteringQuality()">getAutoClusteringQuality</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the quality ratio of the clustering algorithm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getCompactness()">getCompactness</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the property for the compactness of the resulting layout.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping">GroupBoundsCalculator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getGroupBoundsCalculator()">getGroupBoundsCalculator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping"><CODE>GroupBoundsCalculator</CODE></A> instance used for calculating the size of group nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getGroupNodeCompactness()">getGroupNodeCompactness</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the group node compactness factor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getMaximumDuration()">getMaximumDuration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximum duration this algorithm is allowed to run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getMinimalNodeDistance()">getMinimalNodeDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current minimal node distance this algorithm should enforce if the
 node overlaps allowance property is set to <CODE>true</CODE>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../y/layout/organic/OutputRestriction.html" title="class in y.layout.organic">OutputRestriction</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getOutputRestriction()">getOutputRestriction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current OutputRestriction instance set for this instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getPreferredEdgeLength()">getPreferredEdgeLength</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the currently set default preferred edge length.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getPreferredMinimalNodeDistance()">getPreferredMinimalNodeDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current preferred minimal node distance this algorithm should use for
 pairs of nodes that are not directly connected by adjacent edges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getQualityTimeRatio()">getQualityTimeRatio</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the quality to time ratio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getScope()">getScope</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the scope of the layout.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isAutoClusteringEnabled()">isAutoClusteringEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether or not a clustering algorithm should be applied.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isAutomaticGroupNodeCompactionEnabled()">isAutomaticGroupNodeCompactionEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether or not the automatic group node compaction is used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isConsiderNodeLabelsEnabled()">isConsiderNodeLabelsEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether or not node labels are considered for the next layout run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isDeterministic()">isDeterministic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the algorithm will behave deterministically in the next layout run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isMultiThreadingAllowed()">isMultiThreadingAllowed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether the algorithm may use multi-threading to reduce the runtime.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isNodeEdgeOverlapAvoided()">isNodeEdgeOverlapAvoided</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether or not the layouter tries to avoid node/edge overlaps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isNodeOverlapsAllowed()">isNodeOverlapsAllowed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether node overlaps are allowed (but not encouraged) for the next run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isNodeSizeAware()">isNodeSizeAware</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the algorithm should consider the size of the nodes for the layout.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isSmartComponentLayoutEnabled()">isSmartComponentLayoutEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether this instance should configure the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A>
 in such a way that it respects the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getScope()"><CODE>scope's</CODE></A> settings <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET"><CODE>SCOPE_SUBSET</CODE></A> and
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET"><CODE>SCOPE_MAINLY_SUBSET</CODE></A> by keeping other nodes pinned, even if they reside in different components.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutoClusteringEnabled(boolean)">setAutoClusteringEnabled</A></B>(boolean&nbsp;autoClusteringEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies whether or not a clustering algorithm should be applied to the input graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutoClusteringQuality(double)">setAutoClusteringQuality</A></B>(double&nbsp;autoClusteringQuality)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the quality measure of the clustering algorithm,
 if option <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutoClusteringEnabled(boolean)"><CODE>setAutoClusteringEnabled(boolean)</CODE></A> is enabled,
 Possible values are all doubles d with 0 &lt;= d &lt;= 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutomaticGroupNodeCompactionEnabled(boolean)">setAutomaticGroupNodeCompactionEnabled</A></B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies whether or not to use the automatic group node compaction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setCompactness(double)">setCompactness</A></B>(double&nbsp;compactness)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the compactness property for the next layout run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setConsiderNodeLabelsEnabled(boolean)">setConsiderNodeLabelsEnabled</A></B>(boolean&nbsp;considerNodeLabelsEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies whether or not to consider node labels for the next layout run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setDeterministic(boolean)">setDeterministic</A></B>(boolean&nbsp;deterministic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets this algorithm to deterministic mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupBoundsCalculator(y.layout.grouping.GroupBoundsCalculator)">setGroupBoundsCalculator</A></B>(<A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping">GroupBoundsCalculator</A>&nbsp;groupBoundsCalculator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping"><CODE>GroupBoundsCalculator</CODE></A> instance used for calculating the size of group nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupNodeCompactness(double)">setGroupNodeCompactness</A></B>(double&nbsp;groupNodeCompactness)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the compactness of group nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setMaximumDuration(long)">setMaximumDuration</A></B>(long&nbsp;maximumDurationMillis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the soft limit for the maximum duration this algorithm is allowed to execute.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setMinimalNodeDistance(double)">setMinimalNodeDistance</A></B>(double&nbsp;minimalNodeDistance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minimal node distance this algorithm should enforce between all pairs of nodes
 for the next run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setMultiThreadingAllowed(boolean)">setMultiThreadingAllowed</A></B>(boolean&nbsp;multiThreadingAllowed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies whether the algorithm may use multi-threading to reduce the runtime.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeEdgeOverlapAvoided(boolean)">setNodeEdgeOverlapAvoided</A></B>(boolean&nbsp;nodeEdgeOverlapAvoided)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies whether or not the layouter tries to avoid node/edge overlaps.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeOverlapsAllowed(boolean)">setNodeOverlapsAllowed</A></B>(boolean&nbsp;nodeOverlapsAllowed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the next layout run should enforce non-overlapping nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeSizeAware(boolean)">setNodeSizeAware</A></B>(boolean&nbsp;nodeSizeAware)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies whether or not to consider node sizes for the next layout run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setOutputRestriction(y.layout.organic.OutputRestriction)">setOutputRestriction</A></B>(<A HREF="../../../y/layout/organic/OutputRestriction.html" title="class in y.layout.organic">OutputRestriction</A>&nbsp;restriction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a restriction on the output generated by this layouter</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setPreferredEdgeLength(double)">setPreferredEdgeLength</A></B>(double&nbsp;preferredEdgeLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the default preferred edge length for the next algorithm run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setPreferredMinimalNodeDistance(double)">setPreferredMinimalNodeDistance</A></B>(double&nbsp;preferredMinimalNodeDistance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minimal node distance this algorithm should try to obey for the next run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setQualityTimeRatio(double)">setQualityTimeRatio</A></B>(double&nbsp;qualityTimeRatio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the quality to time ratio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)">setScope</A></B>(byte&nbsp;scope)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the scope for the next layout run.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setSmartComponentLayoutEnabled(boolean)">setSmartComponentLayoutEnabled</A></B>(boolean&nbsp;smartComponentLayoutEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets whether this instance should configure the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A>
 in such a way that it respects the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getScope()"><CODE>scope's</CODE></A> settings <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET"><CODE>SCOPE_SUBSET</CODE></A> and
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET"><CODE>SCOPE_MAINLY_SUBSET</CODE></A> by keeping other nodes pinned, even if they reside in different components.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#unconfigureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)">unconfigureComponentLayouter</A></B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph,
                             <A HREF="../../../y/layout/ComponentLayouter.html" title="class in y.layout">ComponentLayouter</A>&nbsp;layouter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A> from the previous
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#configureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><CODE>configureComponentLayouter(y.layout.LayoutGraph,y.layout.ComponentLayouter)</CODE></A>
 call.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_y.layout.CanonicMultiStageLayouter"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class y.layout.<A HREF="../../../y/layout/CanonicMultiStageLayouter.html" title="class in y.layout">CanonicMultiStageLayouter</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#appendStage(y.layout.LayoutStage)">appendStage</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#calcLayout(y.base.GraphInterface, y.layout.GraphLayout)">calcLayout</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#calcLayout(y.layout.LayoutGraph)">calcLayout</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#canLayout(y.layout.LayoutGraph)">canLayout</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#checkGroupNodeSize(y.layout.GraphLayout, java.lang.Object)">checkGroupNodeSize</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#checkNodeSize(y.layout.GraphLayout, java.lang.Object)">checkNodeSize</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#doLayout(y.base.GraphInterface, y.layout.GraphLayout)">doLayout</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#enableOnlyCore()">enableOnlyCore</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()">getComponentLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getGroupNodeHider()">getGroupNodeHider</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getLabelLayouter()">getLabelLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getLayoutOrientation()">getLayoutOrientation</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getOrientationLayouter()">getOrientationLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getParallelEdgeLayouter()">getParallelEdgeLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getSelfLoopLayouter()">getSelfLoopLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getSubgraphLayouter()">getSubgraphLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isComponentLayouterEnabled()">isComponentLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isGroupNodeHidingEnabled()">isGroupNodeHidingEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isLabelLayouterEnabled()">isLabelLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isOrientationLayouterEnabled()">isOrientationLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isParallelEdgeLayouterEnabled()">isParallelEdgeLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isSelfLoopLayouterEnabled()">isSelfLoopLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#isSubgraphLayouterEnabled()">isSubgraphLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#prependStage(y.layout.LayoutStage)">prependStage</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#removeStage(y.layout.LayoutStage)">removeStage</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setComponentLayouter(y.layout.LayoutStage)">setComponentLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setComponentLayouterEnabled(boolean)">setComponentLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setGroupNodeHider(y.layout.LayoutStage)">setGroupNodeHider</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setGroupNodeHidingEnabled(boolean)">setGroupNodeHidingEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setLabelLayouter(y.layout.LayoutStage)">setLabelLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setLabelLayouterEnabled(boolean)">setLabelLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setLayoutOrientation(byte)">setLayoutOrientation</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setOrientationLayouter(y.layout.LayoutStage)">setOrientationLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setOrientationLayouterEnabled(boolean)">setOrientationLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setParallelEdgeLayouter(y.layout.LayoutStage)">setParallelEdgeLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setParallelEdgeLayouterEnabled(boolean)">setParallelEdgeLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setSelfLoopLayouter(y.layout.LayoutStage)">setSelfLoopLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setSelfLoopLayouterEnabled(boolean)">setSelfLoopLayouterEnabled</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setSubgraphLayouter(y.layout.LayoutStage)">setSubgraphLayouter</A>, <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setSubgraphLayouterEnabled(boolean)">setSubgraphLayouterEnabled</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SCOPE_ALL"><!-- --></A><H3>
SCOPE_ALL</H3>
<PRE>
public static final byte <B>SCOPE_ALL</B></PRE>
<DL>
<DD>Scope constant - used for laying out all nodes.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)"><CODE>setScope(byte)</CODE></A>, 
<A HREF="../../../constant-values.html#y.layout.organic.SmartOrganicLayouter.SCOPE_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SCOPE_SUBSET"><!-- --></A><H3>
SCOPE_SUBSET</H3>
<PRE>
public static final byte <B>SCOPE_SUBSET</B></PRE>
<DL>
<DD>Scope constant - used for laying out the subset of nodes only.
 The above mentioned subset has to be specified by registering an
 appropriate <A HREF="../../../y/base/DataProvider.html" title="interface in y.base"><CODE>DataProvider</CODE></A> for key <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA"><CODE>NODE_SUBSET_DATA</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)"><CODE>setScope(byte)</CODE></A>, 
<A HREF="../../../constant-values.html#y.layout.organic.SmartOrganicLayouter.SCOPE_SUBSET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SCOPE_MAINLY_SUBSET"><!-- --></A><H3>
SCOPE_MAINLY_SUBSET</H3>
<PRE>
public static final byte <B>SCOPE_MAINLY_SUBSET</B></PRE>
<DL>
<DD>Scope constant - used for laying out mainly the subset of the nodes.
 The above mentioned subset has to be specified by registering an
 appropriate <A HREF="../../../y/base/DataProvider.html" title="interface in y.base"><CODE>DataProvider</CODE></A> for key <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA"><CODE>NODE_SUBSET_DATA</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)"><CODE>setScope(byte)</CODE></A>, 
<A HREF="../../../constant-values.html#y.layout.organic.SmartOrganicLayouter.SCOPE_MAINLY_SUBSET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODE_SUBSET_DATA"><!-- --></A><H3>
NODE_SUBSET_DATA</H3>
<PRE>
public static final <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>NODE_SUBSET_DATA</B></PRE>
<DL>
<DD>The data provider key for specifying the node subset to be laid out.
 The algorithm expects for each node in the graph to find a
 <A HREF="../../../y/base/DataProvider.html#getBool(java.lang.Object)"><CODE>boolean</CODE></A> that indicates whether the node belongs
 to the "sphere of action".
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)"><CODE>setScope(byte)</CODE></A></DL>
</DL>
<HR>

<A NAME="GROUP_NODE_MODE_DATA"><!-- --></A><H3>
GROUP_NODE_MODE_DATA</H3>
<PRE>
public static final <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>GROUP_NODE_MODE_DATA</B></PRE>
<DL>
<DD>The data provider key for specifying how to handle group nodes.
 The algorithm expects for each node to find one of the following constants or
 <code>null</code>:
 <ul>
 <li><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_NORMAL"><CODE>GROUP_NODE_MODE_NORMAL</CODE></A></li>
 <li><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_FIX_BOUNDS"><CODE>GROUP_NODE_MODE_FIX_BOUNDS</CODE></A></li>
 <li><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_FIX_CONTENTS"><CODE>GROUP_NODE_MODE_FIX_CONTENTS</CODE></A></li>
 </ul>
 <code>null</code> will be treated like <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_NORMAL"><CODE>GROUP_NODE_MODE_NORMAL</CODE></A>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="GROUP_NODE_MODE_NORMAL"><!-- --></A><H3>
GROUP_NODE_MODE_NORMAL</H3>
<PRE>
public static final <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>GROUP_NODE_MODE_NORMAL</B></PRE>
<DL>
<DD>Group node mode constant that can be used to tag a group node.
 Use the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_DATA"><CODE>GROUP_NODE_MODE_DATA</CODE></A> DataProvider key to associate this constant
 with a group node to indicate that it should be treated like an ordinary group node.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="GROUP_NODE_MODE_FIX_BOUNDS"><!-- --></A><H3>
GROUP_NODE_MODE_FIX_BOUNDS</H3>
<PRE>
public static final <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>GROUP_NODE_MODE_FIX_BOUNDS</B></PRE>
<DL>
<DD>Group node mode constant that can be used to tag a group node.
 Use the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_DATA"><CODE>GROUP_NODE_MODE_DATA</CODE></A> DataProvider key to associate this constant
 with a group node to indicate that its bounds should be treated as fixed an
 its contents should never exceed those bounds.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="GROUP_NODE_MODE_FIX_CONTENTS"><!-- --></A><H3>
GROUP_NODE_MODE_FIX_CONTENTS</H3>
<PRE>
public static final <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>GROUP_NODE_MODE_FIX_CONTENTS</B></PRE>
<DL>
<DD>Group node mode constant that can be used to tag a group node.
 Use the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#GROUP_NODE_MODE_DATA"><CODE>GROUP_NODE_MODE_DATA</CODE></A> DataProvider key to associate this constant
 with a group node to indicate that it can be moved like an ordinary group node however its
 contents should remain fixed relative to the position of the group node.
 Note that this implicitly fixes all descendants of the group node.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="PREFERRED_EDGE_LENGTH_DATA"><!-- --></A><H3>
PREFERRED_EDGE_LENGTH_DATA</H3>
<PRE>
public static final <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A> <B>PREFERRED_EDGE_LENGTH_DATA</B></PRE>
<DL>
<DD>The data provider key for specifying the preferred edge lengths for each edge
 The algorithm expects to find <A HREF="../../../y/base/DataProvider.html#getInt(java.lang.Object)"><CODE>DataProvider.getInt(Object)</CODE></A> integer values associated with
 each edge.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SmartOrganicLayouter()"><!-- --></A><H3>
SmartOrganicLayouter</H3>
<PRE>
public <B>SmartOrganicLayouter</B>()</PRE>
<DL>
<DD>Creates a new SmartOrganicLayouter instance
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="isMultiThreadingAllowed()"><!-- --></A><H3>
isMultiThreadingAllowed</H3>
<PRE>
public boolean <B>isMultiThreadingAllowed</B>()</PRE>
<DL>
<DD>Returns whether the algorithm may use multi-threading to reduce the runtime.
 By default this option is disabled (i.e., set to <code>false</code>).
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the algorithm may use multi-threading, and <code>false</code> otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="setMultiThreadingAllowed(boolean)"><!-- --></A><H3>
setMultiThreadingAllowed</H3>
<PRE>
public void <B>setMultiThreadingAllowed</B>(boolean&nbsp;multiThreadingAllowed)</PRE>
<DL>
<DD>Specifies whether the algorithm may use multi-threading to reduce the runtime.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>multiThreadingAllowed</CODE> - whether the algorithm may use multi-threading.</DL>
</DD>
</DL>
<HR>

<A NAME="getGroupNodeCompactness()"><!-- --></A><H3>
getGroupNodeCompactness</H3>
<PRE>
public double <B>getGroupNodeCompactness</B>()</PRE>
<DL>
<DD>Returns the group node compactness factor.
 <br>
 Note: the specified value is only considered if option <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutomaticGroupNodeCompactionEnabled(boolean)"><CODE>setAutomaticGroupNodeCompactionEnabled(boolean)</CODE></A>
 is disabled and if there is no partition grid structure.
 <p>By default this value is <code>0.4</code>.</p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupNodeCompactness(double)"><CODE>setGroupNodeCompactness(double)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutomaticGroupNodeCompactionEnabled(boolean)"><CODE>setAutomaticGroupNodeCompactionEnabled(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGroupNodeCompactness(double)"><!-- --></A><H3>
setGroupNodeCompactness</H3>
<PRE>
public void <B>setGroupNodeCompactness</B>(double&nbsp;groupNodeCompactness)</PRE>
<DL>
<DD>Sets the compactness of group nodes. Values should be in the range [0..1], where 0 results in group nodes not
 affecting the overall layout too much, whereas a value of 1 forces nodes in the same group to be clustered
 tightly.
 <br>
 Note: the specified value is only considered if option <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutomaticGroupNodeCompactionEnabled(boolean)"><CODE>setAutomaticGroupNodeCompactionEnabled(boolean)</CODE></A>
 is disabled and if there is no partition grid structure.
 <p>By default this value is <code>0.4</code>.</p>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if compactness value does not lie in [0..1]<DT><B>Parameters:</B><DD><CODE>groupNodeCompactness</CODE> - the new value.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutomaticGroupNodeCompactionEnabled(boolean)"><CODE>setAutomaticGroupNodeCompactionEnabled(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isAutomaticGroupNodeCompactionEnabled()"><!-- --></A><H3>
isAutomaticGroupNodeCompactionEnabled</H3>
<PRE>
public boolean <B>isAutomaticGroupNodeCompactionEnabled</B>()</PRE>
<DL>
<DD>Returns whether or not the automatic group node compaction is used.
 If this option is enabled the group node compactness
 is determined automatically, i.e., it only depends on the general compactness specified by option
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setCompactness(double)"><CODE>setCompactness(double)</CODE></A>). The value specified by option <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupNodeCompactness(double)"><CODE>setGroupNodeCompactness(double)</CODE></A> is
 ignored.
 <p>By default this option is enabled.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the automatic group node compaction is used.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutomaticGroupNodeCompactionEnabled(boolean)"><CODE>setAutomaticGroupNodeCompactionEnabled(boolean)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupNodeCompactness(double)"><CODE>setGroupNodeCompactness(double)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setCompactness(double)"><CODE>setCompactness(double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAutomaticGroupNodeCompactionEnabled(boolean)"><!-- --></A><H3>
setAutomaticGroupNodeCompactionEnabled</H3>
<PRE>
public void <B>setAutomaticGroupNodeCompactionEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>Specifies whether or not to use the automatic group node compaction. If this option is enabled the group node compactness
 is determined automatically, i.e., it only depends on the general compactness specified by option
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setCompactness(double)"><CODE>setCompactness(double)</CODE></A>). The value specified by option <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupNodeCompactness(double)"><CODE>setGroupNodeCompactness(double)</CODE></A> is
 ignored.
 <p>
 By default this option is enabled.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enabled</CODE> - whether to use the automatic group node compaction.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setGroupNodeCompactness(double)"><CODE>setGroupNodeCompactness(double)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setCompactness(double)"><CODE>setCompactness(double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isAutoClusteringEnabled()"><!-- --></A><H3>
isAutoClusteringEnabled</H3>
<PRE>
public boolean <B>isAutoClusteringEnabled</B>()</PRE>
<DL>
<DD>Returns whether or not a clustering algorithm should be applied.
 <p>
 By default, automatic clustering is not enabled.
 </p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutoClusteringEnabled(boolean)"><CODE>setAutoClusteringEnabled(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAutoClusteringEnabled(boolean)"><!-- --></A><H3>
setAutoClusteringEnabled</H3>
<PRE>
public void <B>setAutoClusteringEnabled</B>(boolean&nbsp;autoClusteringEnabled)</PRE>
<DL>
<DD>Specifies whether or not a clustering algorithm should be applied to the input graph.
 If this option is enabled, the following steps are performed during the layout:
 <ol>
 <li>a clustering algorithm is applied to the input graph.</li>
 <li>all nodes of the same cluster are put into a new group node.</li>
 <li>the common layout is applied to the modified graph.</li>
 <li>group nodes denoting clusters (inserted during step 2) are removed.</li>
 </ol>
 The user can also specify customized clusters by defining appropriate groups.
 <p>
 By default, automatic clustering is not enabled.
 </p><p>
 Note: the runtime of the clustering algorithm does not depend on the specified maximal duration (see method <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setMaximumDuration(long)"><CODE>setMaximumDuration(long)</CODE></A>).
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>autoClusteringEnabled</CODE> - whether the clustering should be applied.</DL>
</DD>
</DL>
<HR>

<A NAME="getAutoClusteringQuality()"><!-- --></A><H3>
getAutoClusteringQuality</H3>
<PRE>
public double <B>getAutoClusteringQuality</B>()</PRE>
<DL>
<DD>Returns the quality ratio of the clustering algorithm.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutoClusteringQuality(double)"><CODE>setAutoClusteringQuality(double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAutoClusteringQuality(double)"><!-- --></A><H3>
setAutoClusteringQuality</H3>
<PRE>
public void <B>setAutoClusteringQuality</B>(double&nbsp;autoClusteringQuality)</PRE>
<DL>
<DD>Specifies the quality measure of the clustering algorithm,
 if option <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setAutoClusteringEnabled(boolean)"><CODE>setAutoClusteringEnabled(boolean)</CODE></A> is enabled,
 Possible values are all doubles d with 0 &lt;= d &lt;= 1.
 The higher d the higher the clustering quality.
 Default value is 1.
 <p>
 Note: the expected runtime of the clustering algorithm increases with d.
 The runtime does not depend on the specified maximal duration (see method <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setMaximumDuration(long)"><CODE>setMaximumDuration(long)</CODE></A>).
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>autoClusteringQuality</CODE> - the quality ratio.</DL>
</DD>
</DL>
<HR>

<A NAME="isConsiderNodeLabelsEnabled()"><!-- --></A><H3>
isConsiderNodeLabelsEnabled</H3>
<PRE>
public boolean <B>isConsiderNodeLabelsEnabled</B>()</PRE>
<DL>
<DD>Returns whether or not node labels are considered for the next layout run.
 <p>
 Default value is <code>false</code>.
 </p>
 <p>
   Note that this option only works correctly if the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setLayoutOrientation(byte)"><CODE>layout orientation</CODE></A>
   is set to <A HREF="../../../y/layout/LayoutOrientation.html#TOP_TO_BOTTOM"><CODE>LayoutOrientation.TOP_TO_BOTTOM</CODE></A> (which is the default).
   Changing the layout orientation for an undirected layout algorithm like the
   <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html" title="class in y.layout.organic"><CODE>SmartOrganicLayouter</CODE></A> doesn't make sense.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code>, the labels of nodes are taken
 into account for the next layout run.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setConsiderNodeLabelsEnabled(boolean)"><CODE>setConsiderNodeLabelsEnabled(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setConsiderNodeLabelsEnabled(boolean)"><!-- --></A><H3>
setConsiderNodeLabelsEnabled</H3>
<PRE>
public void <B>setConsiderNodeLabelsEnabled</B>(boolean&nbsp;considerNodeLabelsEnabled)</PRE>
<DL>
<DD>Specifies whether or not to consider node labels for the next layout run.

 Enabling this setting overrides the value of <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeSizeAware(boolean)"><CODE>setNodeSizeAware(boolean)</CODE></A>, i.e.
 node sizes are always considered.
 <p>
 Default value is <code>false</code>.
 </p>
 <p>
   Note that this option only works correctly if the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#setLayoutOrientation(byte)"><CODE>layout orientation</CODE></A>
   is set to <A HREF="../../../y/layout/LayoutOrientation.html#TOP_TO_BOTTOM"><CODE>LayoutOrientation.TOP_TO_BOTTOM</CODE></A> (which is the default).
   Changing the layout orientation for an undirected layout algorithm like the
   <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html" title="class in y.layout.organic"><CODE>SmartOrganicLayouter</CODE></A> doesn't make sense.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>considerNodeLabelsEnabled</CODE> - if <code>true</code>, the labels of nodes are taken
 into account for the next layout run.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isConsiderNodeLabelsEnabled()"><CODE>isConsiderNodeLabelsEnabled()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGroupBoundsCalculator()"><!-- --></A><H3>
getGroupBoundsCalculator</H3>
<PRE>
public <A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping">GroupBoundsCalculator</A> <B>getGroupBoundsCalculator</B>()</PRE>
<DL>
<DD>Returns the <A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping"><CODE>GroupBoundsCalculator</CODE></A> instance used for calculating the size of group nodes.
 The default is <A HREF="../../../y/layout/grouping/MinimumSizeGroupBoundsCalculator.html" title="class in y.layout.grouping"><CODE>MinimumSizeGroupBoundsCalculator</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the instance being used currently</DL>
</DD>
</DL>
<HR>

<A NAME="isSmartComponentLayoutEnabled()"><!-- --></A><H3>
isSmartComponentLayoutEnabled</H3>
<PRE>
public boolean <B>isSmartComponentLayoutEnabled</B>()</PRE>
<DL>
<DD>Determines whether this instance should configure the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A>
 in such a way that it respects the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getScope()"><CODE>scope's</CODE></A> settings <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET"><CODE>SCOPE_SUBSET</CODE></A> and
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET"><CODE>SCOPE_MAINLY_SUBSET</CODE></A> by keeping other nodes pinned, even if they reside in different components.
 <p>
 The default is <code>false</code>.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Whether to <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#configureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><CODE>configure</CODE></A>
 the component layouter instance.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isSmartComponentLayoutEnabled()"><CODE>isSmartComponentLayoutEnabled()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSmartComponentLayoutEnabled(boolean)"><!-- --></A><H3>
setSmartComponentLayoutEnabled</H3>
<PRE>
public void <B>setSmartComponentLayoutEnabled</B>(boolean&nbsp;smartComponentLayoutEnabled)</PRE>
<DL>
<DD>Sets whether this instance should configure the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A>
 in such a way that it respects the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getScope()"><CODE>scope's</CODE></A> settings <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET"><CODE>SCOPE_SUBSET</CODE></A> and
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET"><CODE>SCOPE_MAINLY_SUBSET</CODE></A> by keeping other nodes pinned, even if they reside in different components.
 <p>
 The default is <code>false</code>.
 </p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#isSmartComponentLayoutEnabled()"><CODE>isSmartComponentLayoutEnabled()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGroupBoundsCalculator(y.layout.grouping.GroupBoundsCalculator)"><!-- --></A><H3>
setGroupBoundsCalculator</H3>
<PRE>
public void <B>setGroupBoundsCalculator</B>(<A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping">GroupBoundsCalculator</A>&nbsp;groupBoundsCalculator)</PRE>
<DL>
<DD>Sets the <A HREF="../../../y/layout/grouping/GroupBoundsCalculator.html" title="interface in y.layout.grouping"><CODE>GroupBoundsCalculator</CODE></A> instance used for calculating the size of group nodes.
 The default is <A HREF="../../../y/layout/grouping/MinimumSizeGroupBoundsCalculator.html" title="class in y.layout.grouping"><CODE>MinimumSizeGroupBoundsCalculator</CODE></A>.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html" title="class or interface in java.lang">NullPointerException</A></CODE> - if the argument is <code>null</code><DT><B>Parameters:</B><DD><CODE>groupBoundsCalculator</CODE> - the instance to use</DL>
</DD>
</DL>
<HR>

<A NAME="isNodeEdgeOverlapAvoided()"><!-- --></A><H3>
isNodeEdgeOverlapAvoided</H3>
<PRE>
public boolean <B>isNodeEdgeOverlapAvoided</B>()</PRE>
<DL>
<DD>Returns whether or not the layouter tries to avoid node/edge overlaps.
 Note that the current implementation does not guarantee the non-existence
 of overlaps but tries to avoid them. Furthermore, the post-processing step that removes node overlaps
 ignores node/edge overlaps, i.e., the number of node/edge overlaps may increase if option
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeOverlapsAllowed(boolean)"><CODE>setNodeOverlapsAllowed(boolean)</CODE></A> is disabled.
 <p>
 By default, this option is not enabled.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>whether the option is enabled<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeEdgeOverlapAvoided(boolean)"><CODE>setNodeEdgeOverlapAvoided(boolean)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeOverlapsAllowed(boolean)"><CODE>setNodeOverlapsAllowed(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setNodeEdgeOverlapAvoided(boolean)"><!-- --></A><H3>
setNodeEdgeOverlapAvoided</H3>
<PRE>
public void <B>setNodeEdgeOverlapAvoided</B>(boolean&nbsp;nodeEdgeOverlapAvoided)</PRE>
<DL>
<DD>Specifies whether or not the layouter tries to avoid node/edge overlaps.
 Note that the current implementation does not guarantee the non-existence
 of overlaps but tries to avoid them. Furthermore, the post-processing step that removes node overlaps
 ignores node/edge overlaps, i.e., the number of node/edge overlaps may increase if option
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeOverlapsAllowed(boolean)"><CODE>setNodeOverlapsAllowed(boolean)</CODE></A> is disabled.
 <p>
 By default, this option is not enabled.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeEdgeOverlapAvoided</CODE> - if <code>true</code>, the algorithm tries to avoid node/edge overlaps.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeOverlapsAllowed(boolean)"><CODE>setNodeOverlapsAllowed(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="configureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><!-- --></A><H3>
configureComponentLayouter</H3>
<PRE>
protected void <B>configureComponentLayouter</B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph,
                                          <A HREF="../../../y/layout/ComponentLayouter.html" title="class in y.layout">ComponentLayouter</A>&nbsp;layouter)</PRE>
<DL>
<DD>Configures the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A>
 and graph instance to adhere to the <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA"><CODE>NODE_SUBSET_DATA</CODE></A> in case
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL"><CODE>SCOPE_ALL</CODE></A> is not set, and to use <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getMinimalNodeDistance()"><CODE>getMinimalNodeDistance()</CODE></A> also for distances between components.
 This will result in the component layouter not rearranging components if they contain
 pinned-down nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph that will be arranged<DD><CODE>layouter</CODE> - the layouter to reconfigure<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#unconfigureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><CODE>unconfigureComponentLayouter(y.layout.LayoutGraph,y.layout.ComponentLayouter)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setSmartComponentLayoutEnabled(boolean)"><CODE>setSmartComponentLayoutEnabled(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="doLayout(y.layout.LayoutGraph)"><!-- --></A><H3>
doLayout</H3>
<PRE>
public void <B>doLayout</B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;layoutGraph)</PRE>
<DL>
<DD><B>Description copied from class: <CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#doLayout(y.layout.LayoutGraph)">CanonicMultiStageLayouter</A></CODE></B></DD>
<DD>Calculates a layout for the given graph. 
 The given graph will not be copied during the
 layout process and the layout will be 
 immediately applied to the given graph.
 This method is not side effect free in the sense that
 the order of edges or nodes in the input graph
 may change during the layout process.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../y/layout/Layouter.html#doLayout(y.layout.LayoutGraph)">doLayout</A></CODE> in interface <CODE><A HREF="../../../y/layout/Layouter.html" title="interface in y.layout">Layouter</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#doLayout(y.layout.LayoutGraph)">doLayout</A></CODE> in class <CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html" title="class in y.layout">CanonicMultiStageLayouter</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="unconfigureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><!-- --></A><H3>
unconfigureComponentLayouter</H3>
<PRE>
protected void <B>unconfigureComponentLayouter</B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph,
                                            <A HREF="../../../y/layout/ComponentLayouter.html" title="class in y.layout">ComponentLayouter</A>&nbsp;layouter)</PRE>
<DL>
<DD>Resets the <A HREF="../../../y/layout/CanonicMultiStageLayouter.html#getComponentLayouter()"><CODE>ComponentLayouter</CODE></A> from the previous
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#configureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><CODE>configureComponentLayouter(y.layout.LayoutGraph,y.layout.ComponentLayouter)</CODE></A>
 call.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph that has been arranged<DD><CODE>layouter</CODE> - the layouter to reset.<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#configureComponentLayouter(y.layout.LayoutGraph, y.layout.ComponentLayouter)"><CODE>configureComponentLayouter(y.layout.LayoutGraph,y.layout.ComponentLayouter)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setSmartComponentLayoutEnabled(boolean)"><CODE>setSmartComponentLayoutEnabled(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="canLayoutCore(y.layout.LayoutGraph)"><!-- --></A><H3>
canLayoutCore</H3>
<PRE>
protected boolean <B>canLayoutCore</B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph)</PRE>
<DL>
<DD><B>Description copied from class: <CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#canLayoutCore(y.layout.LayoutGraph)">CanonicMultiStageLayouter</A></CODE></B></DD>
<DD>Subclasses have to provide information whether or not they
 can layout the given graph.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#canLayoutCore(y.layout.LayoutGraph)">canLayoutCore</A></CODE> in class <CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html" title="class in y.layout">CanonicMultiStageLayouter</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="doLayoutCore(y.layout.LayoutGraph)"><!-- --></A><H3>
doLayoutCore</H3>
<PRE>
protected void <B>doLayoutCore</B>(<A HREF="../../../y/layout/LayoutGraph.html" title="class in y.layout">LayoutGraph</A>&nbsp;graph)</PRE>
<DL>
<DD><B>Description copied from class: <CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#doLayoutCore(y.layout.LayoutGraph)">CanonicMultiStageLayouter</A></CODE></B></DD>
<DD>Subclasses have to provide core layout code in this method.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html#doLayoutCore(y.layout.LayoutGraph)">doLayoutCore</A></CODE> in class <CODE><A HREF="../../../y/layout/CanonicMultiStageLayouter.html" title="class in y.layout">CanonicMultiStageLayouter</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getQualityTimeRatio()"><!-- --></A><H3>
getQualityTimeRatio</H3>
<PRE>
public double <B>getQualityTimeRatio</B>()</PRE>
<DL>
<DD>Returns the quality to time ratio.
 This setting determines the ratio of layout quality versus time consumption.
 The higher the ratio, the better the quality of the resulting layout but
 the longer it may take to perform the layout.
 <p>
 The default value is <code>0.6</code>.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Value of property qualityTimeRatio [0.0d .. 1.0d]</DL>
</DD>
</DL>
<HR>

<A NAME="setQualityTimeRatio(double)"><!-- --></A><H3>
setQualityTimeRatio</H3>
<PRE>
public void <B>setQualityTimeRatio</B>(double&nbsp;qualityTimeRatio)</PRE>
<DL>
<DD>Specifies the quality to time ratio.
 This setting determines the ratio of layout quality versus time consumption.
 <p>
 The default value is <code>0.6</code>.
 </p>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the specified ratio is less than
 <code>0</code> or greater than <code>1</code>.<DT><B>Parameters:</B><DD><CODE>qualityTimeRatio</CODE> - a value between 0.0 (low quality, fast)
                         and 1.0 (high quality, slow)<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getQualityTimeRatio()"><CODE>getQualityTimeRatio()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumDuration()"><!-- --></A><H3>
getMaximumDuration</H3>
<PRE>
public long <B>getMaximumDuration</B>()</PRE>
<DL>
<DD>Returns the maximum duration this algorithm is allowed to run. This is a soft limit
 <p>
 By default, the maximum duration is set to 30 seconds.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the maximum duration in milliseconds</DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumDuration(long)"><!-- --></A><H3>
setMaximumDuration</H3>
<PRE>
public void <B>setMaximumDuration</B>(long&nbsp;maximumDurationMillis)</PRE>
<DL>
<DD>Sets the soft limit for the maximum duration this algorithm is allowed to execute.
 <p>
 By default, the maximum duration is set to 30 seconds.
 </p>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the specified duration is less than
 <code>0</code>.<DT><B>Parameters:</B><DD><CODE>maximumDurationMillis</CODE> - the new soft limit for the duration in milliseconds</DL>
</DD>
</DL>
<HR>

<A NAME="getScope()"><!-- --></A><H3>
getScope</H3>
<PRE>
public byte <B>getScope</B>()</PRE>
<DL>
<DD>Returns the scope of the layout.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the scope, one of <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL"><CODE>SCOPE_ALL</CODE></A>, <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET"><CODE>SCOPE_SUBSET</CODE></A>, or <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET"><CODE>SCOPE_MAINLY_SUBSET</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)"><CODE>setScope(byte)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setScope(byte)"><!-- --></A><H3>
setScope</H3>
<PRE>
public void <B>setScope</B>(byte&nbsp;scope)</PRE>
<DL>
<DD>Sets the scope for the next layout run. The scope determines which of the nodes
 should be affected and how they should be affected by the layout run.
 <p>
 Defaults to <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL"><CODE>SCOPE_ALL</CODE></A>.
 </p><p>
 <b>Note:</b>
 For all scopes but <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL"><CODE>SCOPE_ALL</CODE></A>, a data provider for key
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA"><CODE>NODE_SUBSET_DATA</CODE></A> <em>has</em> to be registered.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scope</CODE> - the new scope, should be one of <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_ALL"><CODE>SCOPE_ALL</CODE></A>, <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_SUBSET"><CODE>SCOPE_SUBSET</CODE></A>, or <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#SCOPE_MAINLY_SUBSET"><CODE>SCOPE_MAINLY_SUBSET</CODE></A><DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getScope()"><CODE>getScope()</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#NODE_SUBSET_DATA"><CODE>NODE_SUBSET_DATA</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCompactness()"><!-- --></A><H3>
getCompactness</H3>
<PRE>
public double <B>getCompactness</B>()</PRE>
<DL>
<DD>Returns the property for the compactness of the resulting layout.
 Lower values result in less compact drawings.
 <p>
 The default value is <code>0.5</code>.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a value indicating the resulting compactness in [0.0d .. 1.0d].</DL>
</DD>
</DL>
<HR>

<A NAME="setCompactness(double)"><!-- --></A><H3>
setCompactness</H3>
<PRE>
public void <B>setCompactness</B>(double&nbsp;compactness)</PRE>
<DL>
<DD>Sets the compactness property for the next layout run.
 Smaller values result in less compact drawings, greater values result in more compact drawings
 with <code>0.5d</code> being a "normal" compactness.
 <p>
 The default value is <code>0.5</code>.
 </p>
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" title="class or interface in java.lang">IllegalArgumentException</A></CODE> - if the specified value is less than
 <code>0</code> or greater than <code>1</code>.<DT><B>Parameters:</B><DD><CODE>compactness</CODE> - the new compactness value [0.0d .. 1.0d]</DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredEdgeLength()"><!-- --></A><H3>
getPreferredEdgeLength</H3>
<PRE>
public double <B>getPreferredEdgeLength</B>()</PRE>
<DL>
<DD>Returns the currently set default preferred edge length. The algorithm will
 try to find a drawing where most of the edges have this length. This default
 is applied to all edges where there is no specific edge length given using the
 <code>double</code> DataProvider instance bound to the graph using the
 <A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#PREFERRED_EDGE_LENGTH_DATA"><CODE>PREFERRED_EDGE_LENGTH_DATA</CODE></A> key.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the preferred default length for edges</DL>
</DD>
</DL>
<HR>

<A NAME="setPreferredEdgeLength(double)"><!-- --></A><H3>
setPreferredEdgeLength</H3>
<PRE>
public void <B>setPreferredEdgeLength</B>(double&nbsp;preferredEdgeLength)</PRE>
<DL>
<DD>Sets the default preferred edge length for the next algorithm run.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preferredEdgeLength</CODE> - the new default preferred edge length<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#getPreferredEdgeLength()"><CODE>getPreferredEdgeLength()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredMinimalNodeDistance()"><!-- --></A><H3>
getPreferredMinimalNodeDistance</H3>
<PRE>
public double <B>getPreferredMinimalNodeDistance</B>()</PRE>
<DL>
<DD>Returns the current preferred minimal node distance this algorithm should use for
 pairs of nodes that are not directly connected by adjacent edges.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the preferred minimal distance</DL>
</DD>
</DL>
<HR>

<A NAME="setPreferredMinimalNodeDistance(double)"><!-- --></A><H3>
setPreferredMinimalNodeDistance</H3>
<PRE>
public void <B>setPreferredMinimalNodeDistance</B>(double&nbsp;preferredMinimalNodeDistance)</PRE>
<DL>
<DD>Sets the minimal node distance this algorithm should try to obey for the next run.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preferredMinimalNodeDistance</CODE> - the new preferred minimal distance between two nodes that are not directly connected to each other</DL>
</DD>
</DL>
<HR>

<A NAME="isNodeSizeAware()"><!-- --></A><H3>
isNodeSizeAware</H3>
<PRE>
public boolean <B>isNodeSizeAware</B>()</PRE>
<DL>
<DD>Determines whether the algorithm should consider the size of the nodes for the layout.
 If set to <CODE>true</CODE> the algorithm will take the node size into account
 for given preferred edge lengths.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>whether node sizes are considered during the core layout</DL>
</DD>
</DL>
<HR>

<A NAME="setNodeSizeAware(boolean)"><!-- --></A><H3>
setNodeSizeAware</H3>
<PRE>
public void <B>setNodeSizeAware</B>(boolean&nbsp;nodeSizeAware)</PRE>
<DL>
<DD>Specifies whether or not to consider node sizes for the next layout run.
 These settings do not affect the hard minimal node distance property.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeSizeAware</CODE> - if <code>true</code>, the sizes of nodes are taken
 into account for the next layout run.</DL>
</DD>
</DL>
<HR>

<A NAME="isDeterministic()"><!-- --></A><H3>
isDeterministic</H3>
<PRE>
public boolean <B>isDeterministic</B>()</PRE>
<DL>
<DD>Returns whether the algorithm will behave deterministically in the next layout run.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current setting for the next layout run</DL>
</DD>
</DL>
<HR>

<A NAME="setDeterministic(boolean)"><!-- --></A><H3>
setDeterministic</H3>
<PRE>
public void <B>setDeterministic</B>(boolean&nbsp;deterministic)</PRE>
<DL>
<DD>Sets this algorithm to deterministic mode. If set to <CODE>true</CODE>, the algorithm will yield
 the same results if given the exact same input and same settings.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>deterministic</CODE> - whether to operate in deterministic mode</DL>
</DD>
</DL>
<HR>

<A NAME="getMinimalNodeDistance()"><!-- --></A><H3>
getMinimalNodeDistance</H3>
<PRE>
public double <B>getMinimalNodeDistance</B>()</PRE>
<DL>
<DD>Returns the current minimal node distance this algorithm should enforce if the
 node overlaps allowance property is set to <CODE>true</CODE>.
 <p>
 The default value is <code>0</code>.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Value of property minimalNodeDistance.</DL>
</DD>
</DL>
<HR>

<A NAME="setMinimalNodeDistance(double)"><!-- --></A><H3>
setMinimalNodeDistance</H3>
<PRE>
public void <B>setMinimalNodeDistance</B>(double&nbsp;minimalNodeDistance)</PRE>
<DL>
<DD>Sets the minimal node distance this algorithm should enforce between all pairs of nodes
 for the next run.
 <p>
 The default value is <code>0</code>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minimalNodeDistance</CODE> - the minimal distance between nodes that are not interconnected by a common edge<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setNodeOverlapsAllowed(boolean)"><CODE>setNodeOverlapsAllowed(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isNodeOverlapsAllowed()"><!-- --></A><H3>
isNodeOverlapsAllowed</H3>
<PRE>
public boolean <B>isNodeOverlapsAllowed</B>()</PRE>
<DL>
<DD>Returns whether node overlaps are allowed (but not encouraged) for the next run.
 <p>
 By default, node overlaps are not allowed.
 </p>
 <p>
 <b>Note:</b> if scope is set to SCOPE_SUBSET or SCOPE_MAINLY_SUBSET, there might be some overlapping nodes even if
 this option is set to false.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>whether node overlaps are allowed to exist after the layout run</DL>
</DD>
</DL>
<HR>

<A NAME="setNodeOverlapsAllowed(boolean)"><!-- --></A><H3>
setNodeOverlapsAllowed</H3>
<PRE>
public void <B>setNodeOverlapsAllowed</B>(boolean&nbsp;nodeOverlapsAllowed)</PRE>
<DL>
<DD>Determines whether the next layout run should enforce non-overlapping nodes. The
 minimal distance between each pair of nodes is determined by the minimal
 node distance property.
 <p>
 By default, node overlaps are not allowed.
 </p>
 <p>
 <b>Note:</b> if scope is set to SCOPE_SUBSET or SCOPE_MAINLY_SUBSET, there might be some overlapping nodes even if
 this option is set to false.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeOverlapsAllowed</CODE> - whether to allow node overlaps<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setMinimalNodeDistance(double)"><CODE>setMinimalNodeDistance(double)</CODE></A>, 
<A HREF="../../../y/layout/organic/SmartOrganicLayouter.html#setScope(byte)"><CODE>setScope(byte)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOutputRestriction(y.layout.organic.OutputRestriction)"><!-- --></A><H3>
setOutputRestriction</H3>
<PRE>
public void <B>setOutputRestriction</B>(<A HREF="../../../y/layout/organic/OutputRestriction.html" title="class in y.layout.organic">OutputRestriction</A>&nbsp;restriction)</PRE>
<DL>
<DD>Sets a restriction on the output generated by this layouter
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>restriction</CODE> - the restriction to use<DT><B>See Also:</B><DD><A HREF="../../../y/layout/organic/OutputRestriction.html#NONE"><CODE>OutputRestriction.NONE</CODE></A>, 
<A HREF="../../../y/layout/organic/OutputRestriction.html" title="class in y.layout.organic"><CODE>OutputRestriction</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOutputRestriction()"><!-- --></A><H3>
getOutputRestriction</H3>
<PRE>
public <A HREF="../../../y/layout/organic/OutputRestriction.html" title="class in y.layout.organic">OutputRestriction</A> <B>getOutputRestriction</B>()</PRE>
<DL>
<DD>Returns the current OutputRestriction instance set for this instance.
 The default is <A HREF="../../../y/layout/organic/OutputRestriction.html#NONE"><CODE>OutputRestriction.NONE</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an OutputRestriction</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<ADDRESS><FONT CLASS="CopyrightFooterFont"><I>&#169; Copyright 2000-2016,<BR><A HREF="http://www.yworks.com" TARGET="_top">yWorks GmbH</A>.<BR>All rights reserved.</I></FONT></ADDRESS></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../y/layout/organic/ShuffleLayouter.html" title="class in y.layout.organic"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../y/layout/organic/SplitEdgeLayoutStage.html" title="class in y.layout.organic"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?y/layout/organic/SmartOrganicLayouter.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SmartOrganicLayouter.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>

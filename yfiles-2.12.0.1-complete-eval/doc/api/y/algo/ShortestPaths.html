<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Tue Mar 01 03:21:10 CET 2016 -->
<TITLE>
ShortestPaths (yFiles-2.12.0.1 API)
</TITLE>

<META NAME="keywords" CONTENT="y.algo.ShortestPaths class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../apistylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ShortestPaths (yFiles-2.12.0.1 API)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<FONT CLASS="ApiSearchFont" ><A HREF="http://kb.yworks.com/search/yfiles-api" TARGET="_Top">Search this API</A></FONT></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../y/algo/RankAssignments.html" title="class in y.algo"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../y/algo/Sorting.html" title="class in y.algo"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?y/algo/ShortestPaths.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ShortestPaths.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
y.algo</FONT>
<BR>
Class ShortestPaths</H2>
<PRE>
<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>y.algo.ShortestPaths</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>ShortestPaths</B><DT>extends <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></DL>
</PRE>

<P>
Provides diverse algorithms and helper methods for solving the shortest path problem
 on weighted graphs.
<P>

<P>
<DL>
<!-- generated by yDoc 3.0_01   http://www.yworks.com/products/ydoc/   b0ac8294e88f500d32e0d39d807e8289e759a8f1e278a9... -->
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)">acyclic</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
        <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
        <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
        <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
        <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, double[], double[], y.base.Edge[])"><CODE>acyclic(Graph, Node, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, double[], double[])">acyclic</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
        <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
        double[]&nbsp;cost,
        double[]&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the single-source shortest path problem for <b>acyclic</b> directed graphs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, double[], double[], y.base.Edge[])">acyclic</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
        <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
        double[]&nbsp;cost,
        double[]&nbsp;dist,
        <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, double[], double[])"><CODE>acyclic(Graph, Node, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#allPairs(y.base.Graph, boolean, double[], double[][])">allPairs</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
         boolean&nbsp;directed,
         double[]&nbsp;cost,
         double[][]&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the all-pairs shortest path problem for graphs with arbitrary
 edge costs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)">bellmanFord</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
            boolean&nbsp;directed,
            <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
            <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
            <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><CODE>bellmanFord(Graph, Node, boolean, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[])">bellmanFord</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
            boolean&nbsp;directed,
            double[]&nbsp;cost,
            double[]&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the single-source shortest path problem for arbitrary graphs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])">bellmanFord</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
            boolean&nbsp;directed,
            double[]&nbsp;cost,
            double[]&nbsp;dist,
            <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[])"><CODE>bellmanFord(Graph, Node, boolean, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.DataProvider)">constructEdgePath</A></B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                  <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node,Node,Edge[])</CODE></A> with the difference that
 the path edges are given by a DataProvider.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])">constructEdgePath</A></B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                  <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method that constructs an explicit edge path from the
 result yielded by one of the shortest paths methods defined in this class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/NodeList.html" title="class in y.base">NodeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.DataProvider)">constructNodePath</A></B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                  <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node,Node,Edge[])</CODE></A> with the difference that
 the path edges are given by a DataProvider.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/NodeList.html" title="class in y.base">NodeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])">constructNodePath</A></B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                  <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method that constructs an explicit node path from the
 result yielded by one of the shortest paths methods defined in this class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)">dijkstra</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
         boolean&nbsp;directed,
         <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
         <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
         <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><CODE>dijkstra(Graph, Node, boolean, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[])">dijkstra</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
         boolean&nbsp;directed,
         double[]&nbsp;cost,
         double[]&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the single-source shortest path problem for arbitrary graphs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])">dijkstra</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
         boolean&nbsp;directed,
         double[]&nbsp;cost,
         double[]&nbsp;dist,
         <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[])"><CODE>dijkstra(Graph, Node, boolean, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#findShortestUniformPaths(y.base.Graph, y.base.Node, y.base.DataProvider, boolean, int, y.base.EdgeList, y.base.NodeList)">findShortestUniformPaths</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                         <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;targetMap,
                         boolean&nbsp;directed,
                         int&nbsp;maxLength,
                         <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A>&nbsp;pathEdges,
                         <A HREF="../../y/base/NodeList.html" title="class in y.base">NodeList</A>&nbsp;pathNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds all nodes and edges that belong to a shortest path from <CODE>start</CODE> to a set of target nodes in the graph not
 farther away than a given distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#findShortestUniformPaths(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.EdgeMap)">findShortestUniformPaths</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;end,
                         boolean&nbsp;directed,
                         <A HREF="../../y/base/EdgeMap.html" title="interface in y.base">EdgeMap</A>&nbsp;pathMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Marks all edges that belong to a shortest path from <CODE>start</CODE> to <CODE>end</CODE> node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/YList.html" title="class in y.base">YList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#kShortestPaths(y.base.Graph, y.base.DataProvider, y.base.Node, y.base.Node, int)">kShortestPaths</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
               <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;costDP,
               <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
               <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;end,
               int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finds the <code>k</code> shortest paths  
 connecting a pair of nodes in a directed graph with non-negative edge costs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/YCursor.html" title="interface in y.base">YCursor</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#kShortestPathsCursor(y.base.Graph, y.base.DataProvider, y.base.Node, y.base.Node, int)">kShortestPathsCursor</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                     <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;costDP,
                     <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                     <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;end,
                     int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A variant of <A HREF="../../y/algo/ShortestPaths.html#kShortestPaths(y.base.Graph, y.base.DataProvider, y.base.Node, y.base.Node, int)"><CODE>kShortestPaths(Graph, DataProvider, Node, Node, int)</CODE></A> 
 that returns its result not as a list but as a special cursor that calculates
 the next path in the sequence only when needed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#shortestPair(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider)">shortestPair</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
             <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;source,
             <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;target,
             boolean&nbsp;directed,
             <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;costDP)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns two edge-disjoint paths from in a nonnegatively-weighted directed graph, so that both paths connect
 <code>s</code> and <code>t</code> and have minimum total length.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)">singleSource</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
             <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
             boolean&nbsp;directed,
             <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
             <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
             <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><CODE>singleSource(Graph, Node, boolean, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, double[], double[])">singleSource</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
             <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
             boolean&nbsp;directed,
             double[]&nbsp;cost,
             double[]&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the single-source shortest path problem for arbitrary graphs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])">singleSource</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
             <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
             boolean&nbsp;directed,
             double[]&nbsp;cost,
             double[]&nbsp;dist,
             <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, double[], double[])"><CODE>singleSource(Graph, Node, boolean, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider)">singleSourceSingleSink</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                       boolean&nbsp;directed,
                       <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to <A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap)"><CODE>singleSourceSingleSink(Graph,Node,Node,boolean,DataProvider,NodeMap)</CODE></A> 
 but instead of returning the shortest distance between the source and sink 
 the actual shortest edge path between these nodes will be returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap)">singleSourceSingleSink</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                       boolean&nbsp;directed,
                       <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
                       <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[], y.base.Edge[])"><CODE>singleSourceSingleSink(Graph, Node, Node, boolean, double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[])">singleSourceSingleSink</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                       boolean&nbsp;directed,
                       double[]&nbsp;cost)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to <A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[], y.base.Edge[])"><CODE>singleSourceSingleSink(Graph,Node,Node,boolean,double[],Edge[])</CODE></A> 
 but instead of returning the shortest distance between the source and sink 
 the actual shortest edge path between these nodes will be returned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[], y.base.Edge[])">singleSourceSingleSink</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                       <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                       boolean&nbsp;directed,
                       double[]&nbsp;cost,
                       <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the single-source single-sink shortest path problem
 for arbitrary graphs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, double[])">uniform</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
        <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
        boolean&nbsp;directed,
        double[]&nbsp;dist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method solves the single-source shortest path problem for arbitrary graphs
 where each edge has a <b>uniform cost of 1.0</b>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, double[], y.base.Edge[])">uniform</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
        <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
        boolean&nbsp;directed,
        double[]&nbsp;dist,
        <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, double[])"><CODE>uniform(Graph, Node, boolean, double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, y.base.NodeMap, y.base.NodeMap)">uniform</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
        <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
        boolean&nbsp;directed,
        <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
        <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like <A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, double[], y.base.Edge[])"><CODE>uniform(Graph, Node, boolean, double[], Edge[])</CODE></A> but uses NodeMaps instead of
 arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../y/algo/ShortestPaths.html#uniformCost(y.base.Graph)">uniformCost</A></B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience method that returns an array containing
 uniform edge costs of <CODE>1.0</CODE> for each edge
 of the given graph.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang">toString</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="uniform(y.base.Graph, y.base.Node, boolean, double[])"><!-- --></A><H3>
uniform</H3>
<PRE>
public static void <B>uniform</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                           <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                           boolean&nbsp;directed,
                           double[]&nbsp;dist)</PRE>
<DL>
<DD>This method solves the single-source shortest path problem for arbitrary graphs
 where each edge has a <b>uniform cost of 1.0</b>.
 This method yields the shortest distance from a given node <CODE>s</CODE> to all other nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>s</CODE> - the start node for the shortest path search<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>dist</CODE> - return value that will hold the shortest distance from node <CODE>s</CODE> to
 all other nodes. The distance from <CODE>s</CODE> to <CODE>v</CODE> is 
 <CODE>dist[v.index()]</CODE>. If there is no path from <CODE>s</CODE> to <CODE>v</CODE> 
 then <CODE>dist[v.index()] == Double.POSITIVE_INFINITY</CODE>.<DT><B>Complexity:</B></DT><DD>O(graph.N()+graph.E())</DD>
<DT><B>Precondition:</B></DT><DD>dist.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="uniform(y.base.Graph, y.base.Node, boolean, double[], y.base.Edge[])"><!-- --></A><H3>
uniform</H3>
<PRE>
public static void <B>uniform</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                           <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                           boolean&nbsp;directed,
                           double[]&nbsp;dist,
                           <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, double[])"><CODE>uniform(Graph, Node, boolean, double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - return value that holds for each node <CODE>t</CODE> the shortest 
 path edge <CODE>pred[t.index()]</CODE> which is the last edge on the shortest
 path from <CODE>s</CODE> to <CODE>t</CODE>. If <CODE>t == s</CODE> or if there
 is no shortest path from <CODE>s</CODE> to <CODE>t</CODE> then
 <CODE>pred[t.index()] == null</CODE>.<DT><B>See Also:</B><DD><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node, Node, Edge[])</CODE></A>, 
<A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node, Node, Edge[])</CODE></A><DT><B>Precondition:</B></DT><DD>pred.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="uniform(y.base.Graph, y.base.Node, boolean, y.base.NodeMap, y.base.NodeMap)"><!-- --></A><H3>
uniform</H3>
<PRE>
public static void <B>uniform</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                           <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                           boolean&nbsp;directed,
                           <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
                           <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#uniform(y.base.Graph, y.base.Node, boolean, double[], y.base.Edge[])"><CODE>uniform(Graph, Node, boolean, double[], Edge[])</CODE></A> but uses NodeMaps instead of
 arrays.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dist</CODE> - return value. the map will provide a double value for each node.<DD><CODE>pred</CODE> - return value. the map will provide an Edge for each node.</DL>
</DD>
</DL>
<HR>

<A NAME="acyclic(y.base.Graph, y.base.Node, double[], double[])"><!-- --></A><H3>
acyclic</H3>
<PRE>
public static boolean <B>acyclic</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                              double[]&nbsp;cost,
                              double[]&nbsp;dist)</PRE>
<DL>
<DD>This method solves the single-source shortest path problem for <b>acyclic</b> directed graphs.
 Associated with each edge is an arbitrary double value that represents the cost of that edge.
 This method yields the shortest distance from a given node <CODE>s</CODE> to all other nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>s</CODE> - the start node for the shortest path search<DD><CODE>cost</CODE> - holds the costs for traversing each edge. Edge <CODE>e</CODE> 
 has cost <CODE>cost[e.index()]</CODE>.<DD><CODE>dist</CODE> - return value that will hold the shortest distance from node <CODE>s</CODE> to
 all other nodes. The distance from <CODE>s</CODE> to <CODE>v</CODE> is 
 <CODE>dist[v.index()]</CODE>. If there is no path from <CODE>s</CODE> to <CODE>v</CODE> 
 then <CODE>dist[v.index()] == Double.POSITIVE_INFINITY</CODE>.
<DT><B>Returns:</B><DD><CODE>false</CODE> if the input graph was not acyclic.<DT><B>Complexity:</B></DT><DD>O(graph.N()+graph.E())</DD>
<DT><B>Preconditions:</B></DT><DD>GraphChecker.isAcyclic(graph)</DD><DD>cost.length == graph.E()</DD><DD>dist.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="acyclic(y.base.Graph, y.base.Node, double[], double[], y.base.Edge[])"><!-- --></A><H3>
acyclic</H3>
<PRE>
public static boolean <B>acyclic</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                              double[]&nbsp;cost,
                              double[]&nbsp;dist,
                              <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, double[], double[])"><CODE>acyclic(Graph, Node, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - return value that holds for each node <CODE>t</CODE> the shortest 
 path edge <CODE>pred[t.index()]</CODE> which is the last edge on the shortest
 path from <CODE>s</CODE> to <CODE>t</CODE>. If <CODE>t == s</CODE> or if there
 is no shortest path from <CODE>s</CODE> to <CODE>t</CODE> then
 <CODE>pred[t.index()] == null</CODE>.<DT><B>See Also:</B><DD><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node, Node, Edge[])</CODE></A>, 
<A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node, Node, Edge[])</CODE></A><DT><B>Precondition:</B></DT><DD>pred.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="acyclic(y.base.Graph, y.base.Node, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)"><!-- --></A><H3>
acyclic</H3>
<PRE>
public static boolean <B>acyclic</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                              <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
                              <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
                              <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#acyclic(y.base.Graph, y.base.Node, double[], double[], y.base.Edge[])"><CODE>acyclic(Graph, Node, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - must provide a double value for each edge.<DD><CODE>dist</CODE> - return value. the map will provide a double value for each node.<DD><CODE>pred</CODE> - return value. the map will provide an Edge for each node.</DL>
</DD>
</DL>
<HR>

<A NAME="dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[])"><!-- --></A><H3>
dijkstra</H3>
<PRE>
public static void <B>dijkstra</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                            boolean&nbsp;directed,
                            double[]&nbsp;cost,
                            double[]&nbsp;dist)</PRE>
<DL>
<DD>This method solves the single-source shortest path problem for arbitrary graphs.
 Associated with each edge is a <b>non-negative</b> double value that represents
 the cost of that edge.
 This method yields the shortest distance from a given node <CODE>s</CODE> to all other nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>s</CODE> - the start node for the shortest path search<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>cost</CODE> - holds the costs for traversing each edge. Edge <CODE>e</CODE> 
 has cost <CODE>cost[e.index()]</CODE>.<DD><CODE>dist</CODE> - return value that will hold the shortest distance from node <CODE>s</CODE> to
 all other nodes. The distance from <CODE>s</CODE> to <CODE>v</CODE> is 
 <CODE>dist[v.index()]</CODE>. If there is no path from <CODE>s</CODE> to <CODE>v</CODE> 
 then <CODE>dist[v.index()] == Double.POSITIVE_INFINITY</CODE>.<DT><B>Complexity:</B></DT><DD>O(graph.E()+graph.N()*log(graph.N())</DD>
<DT><B>Preconditions:</B></DT><DD>For each edge e: cost[e.index()] >= 0</DD><DD>cost.length == graph.E()</DD><DD>dist.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><!-- --></A><H3>
dijkstra</H3>
<PRE>
public static void <B>dijkstra</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                            boolean&nbsp;directed,
                            double[]&nbsp;cost,
                            double[]&nbsp;dist,
                            <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[])"><CODE>dijkstra(Graph, Node, boolean, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - return value that holds for each node <CODE>t</CODE> the shortest 
 path edge <CODE>pred[t.index()]</CODE> which is the last edge on the shortest
 path from <CODE>s</CODE> to <CODE>t</CODE>. If <CODE>t == s</CODE> or if there
 is no shortest path from <CODE>s</CODE> to <CODE>t</CODE> then
 <CODE>pred[t.index()] == null</CODE>.<DT><B>See Also:</B><DD><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node, Node, Edge[])</CODE></A>, 
<A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node, Node, Edge[])</CODE></A><DT><B>Precondition:</B></DT><DD>pred.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dijkstra(y.base.Graph, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)"><!-- --></A><H3>
dijkstra</H3>
<PRE>
public static void <B>dijkstra</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                            boolean&nbsp;directed,
                            <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
                            <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
                            <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#dijkstra(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><CODE>dijkstra(Graph, Node, boolean, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - must provide a double value for each edge.<DD><CODE>dist</CODE> - return value. the map will provide a double value for each node.<DD><CODE>pred</CODE> - return value. the map will provide an Edge for each node.</DL>
</DD>
</DL>
<HR>

<A NAME="singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[], y.base.Edge[])"><!-- --></A><H3>
singleSourceSingleSink</H3>
<PRE>
public static double <B>singleSourceSingleSink</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                            boolean&nbsp;directed,
                                            double[]&nbsp;cost,
                                            <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>This method solves the single-source single-sink shortest path problem
 for arbitrary graphs.
 Associated with each edge is a <b>non-negative</b> double value that represents
 the cost of that edge.
 This method returns the shortest distance from node <CODE>s</CODE> to node <CODE>t</CODE>.
 It also returns information to construct the actual path between these to nodes.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>s</CODE> - the source node for the shortest path search<DD><CODE>t</CODE> - the sink   node for the shortest path search<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>cost</CODE> - holds the costs for traversing each edge. Edge <CODE>e</CODE> 
 has cost <CODE>cost[e.index()]</CODE>.<DD><CODE>pred</CODE> - return value that holds for each node <CODE>v</CODE> on the 
 the shortest the path from <CODE>s</CODE> to <CODE>t</CODE> an edge 
 <CODE>pred[v.index()]</CODE> which is the last edge on
 the shortest path from <CODE>s</CODE> to <CODE>v</CODE>. If <CODE>v == s</CODE> or if there
 is no shortest path from <CODE>s</CODE> to <CODE>v</CODE> then
 <CODE>pred[v.index()] == null</CODE>.
<DT><B>Returns:</B><DD>the distance between <CODE>s</CODE> and <CODE>t</CODE> if a path between these two 
 nodes exist and <CODE>Double.POSITIVE_INFINITY</CODE> otherwise.<DT><B>See Also:</B><DD><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node, Node, Edge[])</CODE></A>, 
<A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node, Node, Edge[])</CODE></A><DT><B>Complexity:</B></DT><DD>O(graph.E()+graph.N()*log(graph.N())</DD>
<DT><B>Preconditions:</B></DT><DD>For each edge e: cost[e.index()] >= 0</DD><DD>cost.length == graph.E()</DD><DD>pred.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[])"><!-- --></A><H3>
singleSourceSingleSink</H3>
<PRE>
public static <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A> <B>singleSourceSingleSink</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                              boolean&nbsp;directed,
                                              double[]&nbsp;cost)</PRE>
<DL>
<DD>Similar to <A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[], y.base.Edge[])"><CODE>singleSourceSingleSink(Graph,Node,Node,boolean,double[],Edge[])</CODE></A> 
 but instead of returning the shortest distance between the source and sink 
 the actual shortest edge path between these nodes will be returned.
 If the returned path is empty then there is no path between the nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a shortest path between source and sink</DL>
</DD>
</DL>
<HR>

<A NAME="singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider)"><!-- --></A><H3>
singleSourceSingleSink</H3>
<PRE>
public static <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A> <B>singleSourceSingleSink</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                              <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                              boolean&nbsp;directed,
                                              <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost)</PRE>
<DL>
<DD>Similar to <A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap)"><CODE>singleSourceSingleSink(Graph,Node,Node,boolean,DataProvider,NodeMap)</CODE></A> 
 but instead of returning the shortest distance between the source and sink 
 the actual shortest edge path between these nodes will be returned.
 If the returned path is empty then there is no path between the nodes.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a shortest path between source and sink</DL>
</DD>
</DL>
<HR>

<A NAME="singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap)"><!-- --></A><H3>
singleSourceSingleSink</H3>
<PRE>
public static double <B>singleSourceSingleSink</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                            boolean&nbsp;directed,
                                            <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
                                            <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#singleSourceSingleSink(y.base.Graph, y.base.Node, y.base.Node, boolean, double[], y.base.Edge[])"><CODE>singleSourceSingleSink(Graph, Node, Node, boolean, double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - must provide a double value for each edge.<DD><CODE>pred</CODE> - return value. the map will provide an Edge for each node.</DL>
</DD>
</DL>
<HR>

<A NAME="bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[])"><!-- --></A><H3>
bellmanFord</H3>
<PRE>
public static boolean <B>bellmanFord</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                  boolean&nbsp;directed,
                                  double[]&nbsp;cost,
                                  double[]&nbsp;dist)</PRE>
<DL>
<DD>This method solves the single-source shortest path problem for arbitrary graphs.
 Associated with each edge is an arbitrary double value that represents
 the cost of that edge. In case the given weighted graph contains no <b>negative cost cycles</b>
 this method will yield the shortest distance from a given node <CODE>s</CODE> to all other nodes.
 If, on the other hand, the given graph contains negative-cost cycles this method will yield
 no reasonable result which will be indicated by the return value <CODE>false</CODE>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>s</CODE> - the start node for the shortest path search<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>cost</CODE> - holds the costs for traversing each edge. Edge <CODE>e</CODE> 
 has cost <CODE>cost[e.index()]</CODE>.<DD><CODE>dist</CODE> - return value that will hold the shortest distance from node <CODE>s</CODE> to
 all other nodes. The distance from <CODE>s</CODE> to <CODE>v</CODE> is 
 <CODE>dist[v.index()]</CODE>. If there is no path from <CODE>s</CODE> to <CODE>v</CODE> 
 then <CODE>dist[v.index()] == Double.POSITIVE_INFINITY</CODE>.
<DT><B>Returns:</B><DD><CODE>false</CODE> if this weighted graph contains a negative cost cycle, 
 <CODE>true</CODE> otherwise.<DT><B>Complexity:</B></DT><DD>O(graph.E()*min(D,graph.N())) where D is the maximal
 number of edges in any shortest path.</DD>
<DT><B>Preconditions:</B></DT><DD>cost.length == graph.E()</DD><DD>dist.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><!-- --></A><H3>
bellmanFord</H3>
<PRE>
public static boolean <B>bellmanFord</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                  boolean&nbsp;directed,
                                  double[]&nbsp;cost,
                                  double[]&nbsp;dist,
                                  <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[])"><CODE>bellmanFord(Graph, Node, boolean, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - return value that holds for each node <CODE>t</CODE> the shortest 
 path edge <CODE>pred[t.index()]</CODE> which is the last edge on the shortest
 path from <CODE>s</CODE> to <CODE>t</CODE>. If <CODE>t == s</CODE> or if there
 is no shortest path from <CODE>s</CODE> to <CODE>t</CODE> then
 <CODE>pred[t.index()] == null</CODE>.<DT><B>See Also:</B><DD><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node, Node, Edge[])</CODE></A>, 
<A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node, Node, Edge[])</CODE></A><DT><B>Precondition:</B></DT><DD>pred.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bellmanFord(y.base.Graph, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)"><!-- --></A><H3>
bellmanFord</H3>
<PRE>
public static boolean <B>bellmanFord</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                  <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                  boolean&nbsp;directed,
                                  <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
                                  <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
                                  <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#bellmanFord(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><CODE>bellmanFord(Graph, Node, boolean, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - must provide a double value for each edge.<DD><CODE>dist</CODE> - return value. the map will provide a double value for each node.<DD><CODE>pred</CODE> - return value. the map will provide an Edge for each node.</DL>
</DD>
</DL>
<HR>

<A NAME="singleSource(y.base.Graph, y.base.Node, boolean, double[], double[])"><!-- --></A><H3>
singleSource</H3>
<PRE>
public static boolean <B>singleSource</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                   <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                   boolean&nbsp;directed,
                                   double[]&nbsp;cost,
                                   double[]&nbsp;dist)</PRE>
<DL>
<DD>This method solves the single-source shortest path problem for arbitrary graphs.
 Depending on the structure of the given graph and the values of the given edge costs it
 delegates its job to the algorithm with the theoretically best running time.
 Please note that theory does not necessarily reflect practice.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>s</CODE> - the start node for the shortest path search<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>cost</CODE> - holds the costs for traversing each edge. Edge <CODE>e</CODE> 
 has cost <CODE>cost[e.index()]</CODE>.<DD><CODE>dist</CODE> - return value that will hold the shortest distance from node <CODE>s</CODE> to
 all other nodes. The distance from <CODE>s</CODE> to <CODE>v</CODE> is 
 <CODE>dist[v.index()]</CODE>. If there is no path from <CODE>s</CODE> to <CODE>v</CODE> 
 then <CODE>dist[v.index()] == Double.POSITIVE_INFINITY</CODE>.
<DT><B>Returns:</B><DD><CODE>false</CODE> if this weighted graph contains a negative cost cycle, 
 <CODE>true</CODE> otherwise.<DT><B>Preconditions:</B></DT><DD>cost.length == graph.E()</DD><DD>dist.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="singleSource(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><!-- --></A><H3>
singleSource</H3>
<PRE>
public static boolean <B>singleSource</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                   <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                   boolean&nbsp;directed,
                                   double[]&nbsp;cost,
                                   double[]&nbsp;dist,
                                   <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, double[], double[])"><CODE>singleSource(Graph, Node, boolean, double[], double[])</CODE></A> but additionally this method
 yields the path edges of each calculated shortest path.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - return value that holds for each node <CODE>t</CODE> the shortest 
 path edge <CODE>pred[t.index()]</CODE> which is the last edge on the shortest
 path from <CODE>s</CODE> to <CODE>t</CODE>. If <CODE>t == s</CODE> or if there
 is no shortest path from <CODE>s</CODE> to <CODE>t</CODE> then
 <CODE>pred[t.index()] == null</CODE>.<DT><B>See Also:</B><DD><A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node, Node, Edge[])</CODE></A>, 
<A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node, Node, Edge[])</CODE></A><DT><B>Precondition:</B></DT><DD>pred.length == graph.N()</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="singleSource(y.base.Graph, y.base.Node, boolean, y.base.DataProvider, y.base.NodeMap, y.base.NodeMap)"><!-- --></A><H3>
singleSource</H3>
<PRE>
public static boolean <B>singleSource</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                   <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                   boolean&nbsp;directed,
                                   <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;cost,
                                   <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;dist,
                                   <A HREF="../../y/base/NodeMap.html" title="interface in y.base">NodeMap</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#singleSource(y.base.Graph, y.base.Node, boolean, double[], double[], y.base.Edge[])"><CODE>singleSource(Graph, Node, boolean, double[], double[], Edge[])</CODE></A> 
 but uses NodeMaps and DataProviders instead of arrays.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cost</CODE> - must provide a double value for each edge.<DD><CODE>dist</CODE> - return value. the map will provide a double value for each node.<DD><CODE>pred</CODE> - return value. the map will provide an Edge for each node.</DL>
</DD>
</DL>
<HR>

<A NAME="allPairs(y.base.Graph, boolean, double[], double[][])"><!-- --></A><H3>
allPairs</H3>
<PRE>
public static boolean <B>allPairs</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                               boolean&nbsp;directed,
                               double[]&nbsp;cost,
                               double[][]&nbsp;dist)</PRE>
<DL>
<DD>This method solves the all-pairs shortest path problem for graphs with arbitrary
 edge costs. If the given graph contains a negative cost cycle, then <CODE>false</CODE> is
 returned and the values returned in <CODE>dist</CODE> are left unspecified.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>cost</CODE> - holds the costs for traversing each edge. Edge <CODE>e</CODE> 
 has cost <CODE>cost[e.index()]</CODE>.<DD><CODE>dist</CODE> - return value that will hold the shortest path distances from all pairs of
 nodes <CODE>s</CODE> and <CODE>t</CODE> in the graph.  
 The distance from <CODE>s</CODE> to <CODE>t</CODE> is 
 <CODE>dist[s.index()][t.index()]</CODE>. If there is no path from <CODE>s</CODE> to <CODE>t</CODE> 
 then <CODE>dist[s.index()][t.index()] == Double.POSITIVE_INFINITY</CODE>.
<DT><B>Returns:</B><DD>whether or not the given graph contains a negative cost cycle.<DT><B>Complexity:</B></DT><DD>O(graph.N())*O(singleSource)</DD>
<DT><B>Preconditions:</B></DT><DD>cost.length == graph.E();</DD><DD>dimension of dist: [graph.N()][graph.N()]]</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findShortestUniformPaths(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.EdgeMap)"><!-- --></A><H3>
findShortestUniformPaths</H3>
<PRE>
public static void <B>findShortestUniformPaths</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;end,
                                            boolean&nbsp;directed,
                                            <A HREF="../../y/base/EdgeMap.html" title="interface in y.base">EdgeMap</A>&nbsp;pathMap)</PRE>
<DL>
<DD>Marks all edges that belong to a shortest path from <CODE>start</CODE> to <CODE>end</CODE> node.
 This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the input graph<DD><CODE>start</CODE> - the start node<DD><CODE>end</CODE> - the end node<DD><CODE>directed</CODE> - whether or not to consider the graph as directed. If the graph is
 to be considered undirected then each edge can be traversed in both directions and
 the returned shortest paths can thus be undirected.<DD><CODE>pathMap</CODE> - the result. For each edge a boolean value will indicate whether or not
 it belongs to a shortest path connecting the two nodes.<DT><B>Complexity:</B></DT><DD>O(g.N()+g.E())</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="kShortestPaths(y.base.Graph, y.base.DataProvider, y.base.Node, y.base.Node, int)"><!-- --></A><H3>
kShortestPaths</H3>
<PRE>
public static <A HREF="../../y/base/YList.html" title="class in y.base">YList</A> <B>kShortestPaths</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                   <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;costDP,
                                   <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                                   <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;end,
                                   int&nbsp;k)</PRE>
<DL>
<DD>This method finds the <code>k</code> shortest paths  
 connecting a pair of nodes in a directed graph with non-negative edge costs.
 The result will be returned as a list of EdgeList objects.
 Note that the returned paths are not required to be simple, i.e. they may contain
 a node or an edge multiple times.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>costDP</CODE> - a data provider that provides a double-valued cost for each edge
 of the input graph.<DD><CODE>start</CODE> - start node of the shortest paths<DD><CODE>end</CODE> - the end node of the shortest paths<DD><CODE>k</CODE> - 
<DT><B>Returns:</B><DD>a list of EdgeList objects each of which representing a path from 
 <code>start</code> to <code>end</code> node. The i-th path in the 
 list contains the i-th shortest path between <code>start</code> and <code>end</code>
 node. Note that the returned list may contain less than <code>k</code> paths in case
 there are fewer directed paths between start and end node.<DT><B>Complexity:</B></DT><DD>O(graph.E() + graph.N()*log(graph.N()) + k)</DD>
<DT><B>Precondition:</B></DT><DD>For each edge e: costDP.getDouble(e) >= 0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="kShortestPathsCursor(y.base.Graph, y.base.DataProvider, y.base.Node, y.base.Node, int)"><!-- --></A><H3>
kShortestPathsCursor</H3>
<PRE>
public static <A HREF="../../y/base/YCursor.html" title="interface in y.base">YCursor</A> <B>kShortestPathsCursor</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                           <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;costDP,
                                           <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                                           <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;end,
                                           int&nbsp;k)</PRE>
<DL>
<DD>A variant of <A HREF="../../y/algo/ShortestPaths.html#kShortestPaths(y.base.Graph, y.base.DataProvider, y.base.Node, y.base.Node, int)"><CODE>kShortestPaths(Graph, DataProvider, Node, Node, int)</CODE></A> 
 that returns its result not as a list but as a special cursor that calculates
 the next path in the sequence only when needed.
 The returned cursor only supports the operation <A HREF="../../y/base/YCursor.html#ok()"><CODE>YCursor.ok()</CODE></A>, 
 <A HREF="../../y/base/YCursor.html#current()"><CODE>YCursor.current()</CODE></A> and <A HREF="../../y/base/YCursor.html#next()"><CODE>YCursor.next()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="uniformCost(y.base.Graph)"><!-- --></A><H3>
uniformCost</H3>
<PRE>
public static double[] <B>uniformCost</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph)</PRE>
<DL>
<DD>Convenience method that returns an array containing
 uniform edge costs of <CODE>1.0</CODE> for each edge
 of the given graph.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an array <CODE>cost[]</CODE> that contains uniform 
 edge costs of 1.0 for each edge <CODE>e: cost[e.index()] == 1.0</CODE>.</DL>
</DD>
</DL>
<HR>

<A NAME="constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><!-- --></A><H3>
constructNodePath</H3>
<PRE>
public static <A HREF="../../y/base/NodeList.html" title="class in y.base">NodeList</A> <B>constructNodePath</B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                         <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Convenience method that constructs an explicit node path from the
 result yielded by one of the shortest paths methods defined in this class.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the start node of the shortest path. This must be the 
 same start node that was specified when <CODE>pred</CODE> was calculated.<DD><CODE>t</CODE> - the end node of the path<DD><CODE>pred</CODE> - the shortest path edge result array returned by one of the
 shortest path edge methods defined in this class.
<DT><B>Returns:</B><DD>a node list that holds the nodes on the shortest path 
 from <CODE>s</CODE> to <CODE>t</CODE> in the correct order. If there
 is no path from <CODE>s</CODE> to <CODE>t</CODE> then an empty 
 list is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="constructNodePath(y.base.Node, y.base.Node, y.base.DataProvider)"><!-- --></A><H3>
constructNodePath</H3>
<PRE>
public static <A HREF="../../y/base/NodeList.html" title="class in y.base">NodeList</A> <B>constructNodePath</B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                         <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#constructNodePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructNodePath(Node,Node,Edge[])</CODE></A> with the difference that
 the path edges are given by a DataProvider.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - the shortest path edge result DataProvider returned by one of the
 shortest path edge methods defined in this class.</DL>
</DD>
</DL>
<HR>

<A NAME="constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><!-- --></A><H3>
constructEdgePath</H3>
<PRE>
public static <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A> <B>constructEdgePath</B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                         <A HREF="../../y/base/Edge.html" title="class in y.base">Edge</A>[]&nbsp;pred)</PRE>
<DL>
<DD>Convenience method that constructs an explicit edge path from the
 result yielded by one of the shortest paths methods defined in this class.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - the start node of the shortest path. This must be the 
 same start node that was specified when <CODE>pred</CODE> was calculated.<DD><CODE>t</CODE> - the end node of the path<DD><CODE>pred</CODE> - the shortest path edge result array returned by one of the
 shortest path edge methods defined in this class.
<DT><B>Returns:</B><DD>an edge list that holds the edges on the shortest path 
 from <CODE>s</CODE> to <CODE>t</CODE> in the correct order. If there
 is no path from <CODE>s</CODE> to <CODE>t</CODE> then an empty 
 list is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="constructEdgePath(y.base.Node, y.base.Node, y.base.DataProvider)"><!-- --></A><H3>
constructEdgePath</H3>
<PRE>
public static <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A> <B>constructEdgePath</B>(<A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;s,
                                         <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;t,
                                         <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;pred)</PRE>
<DL>
<DD>Like <A HREF="../../y/algo/ShortestPaths.html#constructEdgePath(y.base.Node, y.base.Node, y.base.Edge[])"><CODE>constructEdgePath(Node,Node,Edge[])</CODE></A> with the difference that
 the path edges are given by a DataProvider.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pred</CODE> - the shortest path edge result DataProvider returned by one of the
 shortest path edge methods defined in this class.</DL>
</DD>
</DL>
<HR>

<A NAME="findShortestUniformPaths(y.base.Graph, y.base.Node, y.base.DataProvider, boolean, int, y.base.EdgeList, y.base.NodeList)"><!-- --></A><H3>
findShortestUniformPaths</H3>
<PRE>
public static void <B>findShortestUniformPaths</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;start,
                                            <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;targetMap,
                                            boolean&nbsp;directed,
                                            int&nbsp;maxLength,
                                            <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A>&nbsp;pathEdges,
                                            <A HREF="../../y/base/NodeList.html" title="class in y.base">NodeList</A>&nbsp;pathNodes)</PRE>
<DL>
<DD>Finds all nodes and edges that belong to a shortest path from <CODE>start</CODE> to a set of target nodes in the graph not
 farther away than a given distance.
 This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the input graph<DD><CODE>start</CODE> - the start node<DD><CODE>targetMap</CODE> - a boolean data provider that marks the target nodes. If the data provider is <code>null</code>
 all nodes in the graph are assumed to be target nodes.<DD><CODE>directed</CODE> - whether or not to work on directed edges<DD><CODE>maxLength</CODE> - the maximum edge length of the shortest paths. Shortest paths
 that are longer than this value will not be considered.<DD><CODE>pathEdges</CODE> - a return value. If this parameter is not null, this algorithm first clears the list and then adds
                  all edges that belong to the detected shortest paths.<DD><CODE>pathNodes</CODE> - a return value. If this parameter is not null, this algorithm first clears the list and then adds
                  all nodes that belong to the detected shortest paths.<DT><B>Complexity:</B></DT><DD>O(g.N()+g.E())</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shortestPair(y.base.Graph, y.base.Node, y.base.Node, boolean, y.base.DataProvider)"><!-- --></A><H3>
shortestPair</H3>
<PRE>
public static final <A HREF="../../y/base/EdgeList.html" title="class in y.base">EdgeList</A>[] <B>shortestPair</B>(<A HREF="../../y/base/Graph.html" title="class in y.base">Graph</A>&nbsp;graph,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;source,
                                            <A HREF="../../y/base/Node.html" title="class in y.base">Node</A>&nbsp;target,
                                            boolean&nbsp;directed,
                                            <A HREF="../../y/base/DataProvider.html" title="interface in y.base">DataProvider</A>&nbsp;costDP)</PRE>
<DL>
<DD>Returns two edge-disjoint paths from in a nonnegatively-weighted directed graph, so that both paths connect
 <code>s</code> and <code>t</code> and have minimum total length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>graph</CODE> - the graph being acted upon<DD><CODE>source</CODE> - source node of the shortest pair<DD><CODE>target</CODE> - end node of the shortest pair<DD><CODE>directed</CODE> - whether or not to interpret the edges as directed or undirected<DD><CODE>costDP</CODE> - a data provider that provides a double-valued cost for each edge
 of the input graph.
<DT><B>Returns:</B><DD>a two-dimensional EdgeList array that holds the resulting edge-disjoint paths, or <code>null</code> if no such
 edge-disjoint paths exist.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<ADDRESS><FONT CLASS="CopyrightFooterFont"><I>&#169; Copyright 2000-2016,<BR><A HREF="http://www.yworks.com" TARGET="_top">yWorks GmbH</A>.<BR>All rights reserved.</I></FONT></ADDRESS></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../y/algo/RankAssignments.html" title="class in y.algo"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../y/algo/Sorting.html" title="class in y.algo"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?y/algo/ShortestPaths.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ShortestPaths.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>

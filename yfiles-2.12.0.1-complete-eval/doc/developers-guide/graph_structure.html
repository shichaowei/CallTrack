<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Graph Structure Functionality</title>
      <link rel="stylesheet" href="ystyle.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.65.1">
      <link rel="home" href="index.html" title="yFiles for Java Developer's Guide">
      <link rel="up" href="base.html" title="Chapter&nbsp;4.&nbsp;Working with the Graph Structure">
      <link rel="previous" href="base.html" title="Chapter&nbsp;4.&nbsp;Working with the Graph Structure">
      <link rel="next" href="events_and_listeners.html" title="Events and Listeners">
      <link rel="stylesheet" href="jsdt/toc.css" type="text/css"><script type="text/javascript" src="jsdt/jquery.min.js"></script><script type="text/javascript" src="jsdt/toc.js"></script><link type="text/css" rel="stylesheet" href="jssh/SyntaxHighlighter.css"><script type="text/javascript" src="jssh/shCore.js"></script><script type="text/javascript" src="jssh/shBrushJava.js"></script><script type="text/javascript" src="jssh/shBrushXml.js"></script><script type="text/javascript">
  function sh() {

    dp.SyntaxHighlighter.HighlightAll('programlisting', false, false, false, null, false);
  }
  </script></head>
   <body onload="sh()" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Graph Structure Functionality</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="base.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">Chapter&nbsp;4.&nbsp;Working with the Graph Structure</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="events_and_listeners.html">Next</a></td>
            </tr>
         </table>
         <div class="navline"></div>
         <div style="display:none"><img src="figures/navbg.jpg" alt=""><img src="figures/navline.jpg" alt=""></div>
      </div>
      <div class="section" lang="en">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title" style="clear: both"><a name="graph_structure"></a>Graph Structure Functionality
                  </h2>
               </div>
            </div>
            <div></div>
         </div>
         <p>
            The yFiles graph structure implementation as depicted in 
            <a href="graph_structure.html#basic graph structure" title="Figure&nbsp;4.1.&nbsp;The basic graph structure">Figure&nbsp;4.1, &#8220;The basic graph structure&#8221;</a> shows the main classes together with 
            their associations and multiplicity. 
            A graph can have an arbitrary number of nodes and edges, every node and edge, 
            though, has exactly one graph. 
            A node can have an arbitrary number of edges, but an edge always has two nodes 
            (its source node and its target node). 
            
            
            
         </p>
         <div class="figure"><a name="basic graph structure"></a><p class="title"><b>Figure&nbsp;4.1.&nbsp;The basic graph structure</b></p>
            <div class="informaltable">
               <center>
                  <table border="0">
                     <colgroup>
                        <col width="100%">
                     </colgroup>
                     <tbody>
                        <tr>
                           <td>
                              <div class="mediaobject" align="center"><img src="figures/basic_graph_structure.jpg" align="middle" alt="The yFiles basic graph structure."></div>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </center>
            </div>
         </div>
         <div class="section" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="Class Graph"></a>More About Class Graph
                     </h3>
                  </div>
               </div>
               <div></div>
            </div>
            <p>
               In addition to the functionality presented in 
               <a href="base.html#Creating Graphs and Graph Elements" title="Creating Graphs and Graph Elements">the section called &#8220;Creating Graphs and Graph Elements&#8221;</a>, which covers simple graph 
               element creation, class <a href="../api/y/base/Graph.html" title="Link to API documentation" target="_top">Graph<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> also 
               provides methods that offer more control in specific situations. 
               
            </p>
            <p>
               For example, in addition to the most frequently used simple edge creation, it 
               is also possible to specify the exact place where a newly created edge should 
               be inserted into both the sequence of outgoing edges at its source node and the 
               sequence of incoming edges at its target node. 
               Furthermore, an already existing edge can be completely remodeled, i.e., both 
               its end nodes as well as the insertion places at either end node can be 
               changed. 
               Reversing an edge, as another variant of changing an edge, is also supported. 
               
            </p>
            <p>
               
               <a href="graph_structure.html#Edge insertion" title="Example&nbsp;4.1.&nbsp;Exact edge insertion">Example&nbsp;4.1, &#8220;Exact edge insertion&#8221;</a> shows the respective line of code for 
               specifying the exact place of edge insertion. 
               
            </p><a class="indexterm" name="d0e1067"></a><a class="indexterm" name="d0e1074"></a><div class="example"><a name="Edge insertion"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Exact edge insertion</b></p><pre class="programlisting java">
// 'graph' is of type y.base.Graph. 
// 'source' and 'target' are of type y.base.Node. 

// Create a new edge at the second position of all incoming edges at the target 
// node. 
graph.createEdge(source, source.firstOutEdge(), 
                 target, target.firstInEdge(), graph.AFTER, graph.AFTER);
</pre></div>
            <p>
               <a href="graph_structure.html#fig_edge_insertion" title="Figure&nbsp;4.2.&nbsp;Exact edge insertion">Figure&nbsp;4.2, &#8220;Exact edge insertion&#8221;</a> shows the resulting graph. 
               The newly created edge is inserted after the first incoming edge at the target 
               node. 
               Observe how the sequence of incoming edges (indicated by the numbers near the 
               arrowheads) changes with the insertion. 
               
            </p>
            <div class="figure"><a name="fig_edge_insertion"></a><p class="title"><b>Figure&nbsp;4.2.&nbsp;Exact edge insertion</b></p>
               <div class="informaltable">
                  <center>
                     <table border="0">
                        <colgroup>
                           <col width="50%">
                           <col width="50%">
                        </colgroup>
                        <tbody>
                           <tr>
                              <td>
                                 <div class="mediaobject" align="center"><img src="figures/edge_order_7.jpg" align="middle" alt="Three incoming edges at target node."></div>
                              </td>
                              <td>
                                 <div class="mediaobject" align="center"><img src="figures/edge_order_7ins.jpg" align="middle" alt="Fourth incoming edge inserted at place two."></div>
                              </td>
                           </tr>
                           <tr align="center">
                              <td align="center">
                                 (a) Graph before... 
                                 
                                 
                              </td>
                              <td align="center">
                                 (b) ... and after edge insertion. 
                                 
                                 
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </center>
               </div>
            </div>
            <p><a name="removing_graph_elements"></a>
               The analogous operation to graph element creation is their removal. 
               Class <a href="../api/y/base/Graph.html" title="Link to API documentation" target="_top">Graph<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> offers methods to remove all 
               graph elements at once, or to remove only a single node or a single edge. 
               When removing either an instance of type Node or an instance of type Edge their 
               reference to the containing graph is cleared. 
               <a class="indexterm" name="d0e1126"></a>
               
               
               
            </p><pre class="programlisting java">
// 'graph' is of type y.base.Graph. 

// Remove single graph elements from the graph. 
// Note that all edges adjacent to the given node are removed prior to the node 
// itself. 
graph.removeNode(graph.firstNode());
graph.removeEdge(graph.lastEdge());

// Remove all graph elements from the graph at once. 
graph.clear();
</pre><p>
               
               
               
               
               
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
               <h3 class="title">Note</h3>
               <p>
                  When removing a single node from a graph, all its connecting edges are also 
                  removed. 
                  Technically, they are even removed before the node is, since an edge requires
                  both its source node and target node to reside in the same graph. 
                  
                  
               </p>
            </div>
            <p>
               
               
            </p>
            <p><a name="removing-vs-hiding"></a>
               An alternative to removing graph elements is to hide them. 
               Hiding is a technique to only <span class="emphasis"><em>temporarily</em></span> remove graph 
               elements, i.e., taking them away from the graph structure to perform some task 
               on the remaining graph, and thereafter putting them back into again, unhiding 
               them. 
               Note that both removing and hiding a graph element only takes them away from 
               the graph, the objects themselves still exist. 
               <a class="indexterm" name="d0e1144"></a>
               
               
               
            </p><pre class="programlisting java">
// 'graph' is of type y.base.Graph. 

// Hide single graph elements from the graph. 
// Note that all edges adjacent to 'exampleNode' are hidden prior to the node 
// itself. 
Node exampleNode = graph.firstNode();
graph.hide(exampleNode);

// Unhide single graph elements from the graph. 
// Note that *only* 'exampleNode' is unhidden, while its formerly adjacent edges 
// are not. 
graph.unhide(exampleNode);
</pre><p>
               
               
               
               
               In order to be able to unhide previously hidden graph elements, it is necessary 
               to retain them, for example, in a data structure. 
               Hiding of graph elements can also be performed utilizing specialized classes 
               which automatically keep track of all hidden elements. 
               These classes are described in <a href="graph_structure.html#graph_advanced" title="Advanced Topics">the section called &#8220;Advanced Topics&#8221;</a>. 
               
            </p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
               <h3 class="title">Important</h3>
               <p>
                  Hiding a graph element only differs from removing a graph element in that there 
                  is no graph event fired that signals the structural change. 
                  (Please see <a href="events_and_listeners.html" title="Events and Listeners">the section called &#8220;Events and Listeners&#8221;</a> for a description of graph 
                  events.) 
                  As a consequence, any listeners to such graph events won't be notified when 
                  either node or edge is hidden, which can easily result in data structures 
                  getting out of sync with the actual structure of the graph. 
                  
               </p>
               <p>
                  The most notable listener that strongly depends on proper notification of any 
                  structural changes to a graph is class 
                  <a href="../api/y/view/hierarchy/HierarchyManager.html" title="Link to API documentation" target="_top">HierarchyManager<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>. 
                  It is responsible for managing essential aspects of grouped graphs, and uses graph
                  events to synchronize its own data structures. 
                  (Please see <a href="view_hierarchy.html" title="Chapter&nbsp;7.&nbsp;Graph Hierarchies">Chapter&nbsp;7, <i>Graph Hierarchies</i></a> for the description of grouped graphs.)
                  
               </p>
               <p>
                  Therefore, when working with graph hierarchies graph elements must not be 
                  hidden, but instead should be removed. 
                  
               </p>
            </div>
            <p>
               In addition to the number of nodes and the number of edges an instance of type 
               Graph also knows whether a single graph element belongs to it or if there is 
               an edge connecting two nodes. 
               The latter feature is especially useful if there is no reference of an edge at 
               hand, for instance. 
               
            </p>
            <p>
               If a graph element has been hidden it does not belong to any graph until it is 
               unhidden again. 
               
               
               
               
            </p><pre class="programlisting java">
// 'graph' is of type y.base.Graph

// Get the number of nodes in the graph. 
// (Both methods are equivalent.) 
int nodeCount = graph.nodeCount();
int N = graph.N();

// Get the number of edges in the graph. 
// (Both methods are equivalent.) 
int edgeCount = graph.edgeCount();
int E = graph.E();

// Check if the graph is empty. 
boolean isEmpty = graph.isEmpty();

// Check if the first node belongs to the graph. 
boolean containsNode = graph.contains(graph.firstNode());

// Check if there is an edge between first and last node of the graph. 
boolean containsEdge = graph.containsEdge(graph.firstNode(), graph.lastNode());
</pre><p>
               
               
               
               
               
            </p>
            <p>
               Class Graph offers access to its graph elements in several different ways. 
               It returns either cursors to iterate over the respective sets of graph 
               elements, or creates arrays containing references to all nodes or all edges 
               from the graph. 
               As an additional convenience, there are methods to get the first, respectively 
               last element of any of the two sets. 
               
               While the returned cursors by definition have read-only behavior on the 
               underlying container, the returned arrays actually are copies of the respective 
               sets of elements from the graph at a certain point in time. 
               In effect, this means that, for example, a returned node array can be modified 
               in any way, i.e., nodes might be removed from the array or the sequence of 
               nodes might be changed, without affecting the node set from the graph. 
               
            </p>
            <p>
               To change the sequence of any of the graph element sets class Graph has methods 
               to move an element to the first or last position, respectively. 
               
               
            </p><pre class="programlisting java">
// 'graph' is of type y.base.Graph. 

// Get the first and last node of the node set from the graph. 
Node firstNode = graph.getFirstNode();
Node lastNode = graph.getLastNode();

// Exchange first and last node of the node set. 
graph.moveToLast(firstNode);
graph.moveToFirst(lastNode);

// Get the first and last edge of the edge set from the graph. 
Edge firstEdge = graph.getFirstEdge();
Edge lastEdge = graph.getLastEdge();

// Exchange first and last edge of the edge set. 
graph.moveToLast(firstEdge);
graph.moveToFirst(lastEdge);

// Get a cursor of all nodes from the graph. 
NodeCursor nc = graph.nodes();

// Get a cursor of all edges from the graph. 
EdgeCursor ec = graph.edges();

// Get an array of all nodes from the graph. 
Node nodes[] = graph.getNodeArray();

// Get an array of all edges from the graph. 
Edge edges[] = graph.getEdgeArray();
</pre><p>
               
               
               
               
               
            </p>
         </div>
         <div class="section" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="Graph Elements"></a>Graph Elements
                     </h3>
                  </div>
               </div>
               <div></div>
            </div>
            <p>
               Every instance of a graph element, i.e., every instance of type 
               <a href="../api/y/base/Node.html" title="Link to API documentation" target="_top">Node<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> and type 
               <a href="../api/y/base/Edge.html" title="Link to API documentation" target="_top">Edge<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> holds a reference to the instance of 
               type Graph it belongs to. 
               
               This reference is cleared when the graph element has been removed or hidden 
               from its graph.
               
               
            </p><pre class="programlisting java">
// 'node' is of type y.base.Node.

// Get the graph the node belongs to.
Graph graph = node.getGraph();
</pre><p>
               
               
               
               
               
            </p>
            <p>
               Furthermore, every graph element knows the position it has in the respective 
               set of elements within its graph. 
               More precisely, when an instance of type Graph is asked for an array of its 
               nodes, for example, this array reflects the node iteration sequence exactly, 
               i.e., a node at position 6 in the array will return the value 6 when asked for 
               its position. 
               
               
               
            </p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
               <h3 class="title">Important</h3>
               <p>
                  The position of a removed graph element is undefined. 
                  The same holds for a hidden graph element. 
                  
               </p>
            </div>
            <p>
               
               
               
               
               
            </p><pre class="programlisting java">
// 'graph' is of type y.base.Graph. 
// 'node' is of type y.base.Node. 

// Get the node's position. 
int index = node.index();

// Get an array of all nodes from the graph. 
Node nodes[] = graph.getNodeArray();
// Check the positions of all nodes. 
for (int i = 0; i &lt; graph.N(); i++)
{
  if (nodes[i].index() != i)
    throw new RuntimeException("Mismatch at position " + i + ".");
  else
    System.out.println("All is well at position " + i + ".");
}
</pre><p>
               
               
               
               
               
            </p>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a name="Class Node"></a>Class Node
                        </h4>
                     </div>
                  </div>
                  <div></div>
               </div>
               <p>
                  Class <a href="../api/y/base/Node.html" title="Link to API documentation" target="_top">Node<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> is responsible for everything 
                  that is related to its connecting edges. 
                  
                  More specifically, an instance of type Node knows the overall number of 
                  connecting edges (the so-called degree of the node) as well as the division 
                  into the number of incoming edges (in-degree) and the number outgoing edges 
                  (out-degree). 
                  <a class="indexterm" name="d0e1210"></a>
                  <a class="indexterm" name="d0e1214"></a>
                  <a class="indexterm" name="d0e1218"></a>
                  
                  
                  
               </p><pre class="programlisting java">
// 'node' is of type y.base.Node.

// Get the number of edges at a node. 
int degree = node.degree();

// Get the number of incoming edges at a node. 
int inDegree = node.inDegree();

// Get the number of outgoing edges at a node. 
int outDegree = node.outDegree();
</pre><p>
                  
                  
                  
                  
                  
               </p>
               <p>
                  A node also provides methods to easily test whether there is a connecting edge 
                  to another node. 
                  
                  
                  
               </p><pre class="programlisting java">
// 'graph' is of type y.base.Graph. 

Node firstNode = graph.firstNode();
Node lastNode = graph.lastNode();

// Check whether there is an edge between first and last node of the graph. 
// First check if there is a connecting edge outgoing to 'lastNode'. 
Edge e = firstNode.getEdgeTo(lastNode);
// If not, then check if there is a connecting edge incoming from 'lastNode'. 
if (e == null)
  e = firstNode.getEdgeFrom(lastNode);
</pre><p>
                  
                  
                  
                  
                  
               </p>
               <p>
                  Furthermore, it can give cursors to iterate over all connecting edges, 
                  iterate over all incoming edges, and iterate over all outgoing edges. 
                  When iterating over all edges incoming edges appear first, outgoing edges 
                  last. 
                  
               </p><pre class="programlisting java">
// 'node' is of type y.base.Node. 

// Get a cursor to iterate over all edges at a node. 
EdgeCursor edges = node.edges();

// Get a cursor to iterate over all incoming edges at a node. 
EdgeCursor inEdges = node.inEdges();

// Get a cursor to iterate over all outgoing edges at a node. 
EdgeCursor outEdges = node.outEdges();
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title"><a name="self_loop_specifics"></a>Important
                  </h3>
                  <p>
                     Since a self-loop is both an incoming and an outgoing edge at its node, it 
                     appears twice when iterating over all edges of the node. 
                     Also, a self-loop counts twice when asking for the degree of a node. 
                     
                  </p><a class="indexterm" name="d0e1243"></a></div>
               <p>
                  As a convenience, class Node furthermore provides cursors to iterate over all 
                  its neighbors, to iterate over all its predecessors, or to iterate over all 
                  its successors. 
                  Predecessors and successors mean the nodes at the opposite of an incoming edge, 
                  and an outgoing edge, respectively.
                  
               </p><pre class="programlisting java">
// 'node' is of type y.base.Node.

// Get a cursor to iterate over all neighbor nodes. 
NodeCursor neighbors = node.neighbors();

// Get a cursor to iterate over the source nodes of all incoming edges. 
// These nodes are called predecessors.
NodeCursor predecessors = node.predecessors();

// Get a cursor to iterate over the target nodes of all outgoing edges. 
// These nodes are called successors.
NodeCursor successors = node.successors();
</pre></div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a name="Class Edge"></a>Class Edge
                        </h4>
                     </div>
                  </div>
                  <div></div>
               </div>
               <p>
                  The most important information an instance of type 
                  <a href="../api/y/base/Edge.html" title="Link to API documentation" target="_top">Edge<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> provides is its source node and its 
                  target node. 
                  Closely related is the method to get the opposite when holding one of the 
                  edge's end nodes. 
                  <a class="indexterm" name="d0e1257"></a>
                  <a class="indexterm" name="d0e1267"></a>
                  
                  
                  
               </p><pre class="programlisting java">
// 'edge' is of type y.base.Edge. 

// Get the two end nodes of an edge. 
Node source = edge.source();
Node target = edge.target();

// Getting the opposite when holding one of either source or target node. 
Node opposite = edge.opposite(source);
</pre><p>
                  
                  
                  
                  
                  
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>
                     Although a hidden edge holds no reference to a graph, it can still provide 
                     access to its source and target node, independent of their status. 
                     
                     
                  </p>
               </div>
               <p>
                  As a convenience, class Edge additionally offers information whether it is a 
                  self-loop. 
                  
                  
               </p><pre class="programlisting java">
// 'edge' is of type y.base.Edge. 

// Ask the edge whether it is a self-loop. 
boolean isSelfLoop = edge.isSelfLoop();
</pre><p>
                  
                  
                  
                  
                  
               </p>
            </div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
               <h3 class="title">Note</h3>
               <p>
                  Ignoring the directedness of the yFiles graph structure implementation and 
                  instead interpreting it undirected would be done using method 
                  <a href="../api/y/base/Node.html#neighbors()" title="Link to API documentation" target="_top">neighbors<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> of class 
                  Node, or a combination of methods 
                  <a href="../api/y/base/Node.html#edges()" title="Link to API documentation" target="_top">edges<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> of class Node and 
                  <a href="../api/y/base/Edge.html#opposite(y.base.Node)" title="Link to API documentation" target="_top">opposite<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> 
                  of class Edge. 
                  
                  
                  
               </p>
            </div>
         </div>
         <div class="section" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="Complexity"></a>Complexity
                     </h3>
                  </div>
               </div>
               <div></div>
            </div>
            <p>
               
               <a href="graph_structure.html#Time complexity..." title="Table&nbsp;4.1.&nbsp;Time complexities in package y.base">Table&nbsp;4.1, &#8220;Time complexities in package y.base&#8221;</a> shows time 
               <a href="glossary.html#complexity"><i class="firstterm">complexities</i></a> for several of the 
               most frequent tasks when working with the yFiles graph structure 
               implementation. 
               
            </p><a class="indexterm" name="d0e1304"></a><p>
               Creation of graph elements takes constant time as does the removal of an edge. 
               Removing a node, though, implies the removal of all its connecting edges first, 
               so this task takes linear time, i.e., time proportional to the number of 
               connecting edges. 
               
               Also, all iteration is done in linear time. 
               
               Checking whether a given node or edge belong to a graph is done in constant 
               time, while testing if there is an edge connecting two nodes takes linear time. 
               
            </p>
            <div class="striped"><a name="Time complexity..."></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Time complexities in package y.base</b></p>
               <table summary="Time complexities in package y.base" width="100%" border="0">
                  <colgroup>
                     <col width="42%" align="left">
                     <col width="29%" align="left">
                     <col width="29%" align="left">
                  </colgroup>
                  <thead valign="top">
                     <tr>
                        <th align="left">Task</th>
                        <th align="left">Involved Class(es)</th>
                        <th align="left">Complexity</th>
                     </tr>
                  </thead>
                  <tbody valign="top">
                     <tr>
                        <td align="left">Creating a node</td>
                        <td align="left">Graph</td>
                        <td align="left">O(1)</td>
                     </tr>
                     <tr class="evenrow">
                        <td align="left">Creating an edge</td>
                        <td align="left">Graph</td>
                        <td align="left">O(1)</td>
                     </tr>
                     <tr>
                        <td align="left">Removing/hiding a node</td>
                        <td align="left">Graph</td>
                        <td align="left">O(Node.degree())</td>
                     </tr>
                     <tr class="evenrow">
                        <td align="left">Removing/hiding an edge</td>
                        <td align="left">Graph</td>
                        <td align="left">O(1)</td>
                     </tr>
                     <tr>
                        <td align="left">Clearing the graph</td>
                        <td align="left">Graph</td>
                        <td align="left">O(Graph.N() + Graph.E())</td>
                     </tr>
                     <tr class="evenrow">
                        <td align="left">Iterating over the node set</td>
                        <td align="left">Graph, NodeCursor</td>
                        <td align="left">O(Graph.N())</td>
                     </tr>
                     <tr>
                        <td align="left">Iterating over the edge set</td>
                        <td align="left">Graph, EdgeCursor</td>
                        <td align="left">O(Graph.E())</td>
                     </tr>
                     <tr class="evenrow">
                        <td align="left">Iterating over all edges connecting to a node</td>
                        <td align="left">Node, EdgeCursor</td>
                        <td align="left">O(Node.degree())</td>
                     </tr>
                     <tr>
                        <td align="left">Iterating over all incoming edges</td>
                        <td align="left">Node, EdgeCursor</td>
                        <td align="left">O(Node.inDegree())</td>
                     </tr>
                     <tr class="evenrow">
                        <td align="left">Iterating over all outgoing edges</td>
                        <td align="left">Node, EdgeCursor</td>
                        <td align="left">O(Node.outDegree())</td>
                     </tr>
                     <tr>
                        <td align="left">Checking if a node belongs to a graph</td>
                        <td align="left">Graph</td>
                        <td align="left">O(1)</td>
                     </tr>
                     <tr class="evenrow">
                        <td align="left">Checking if an edge belongs to a graph</td>
                        <td align="left">Graph</td>
                        <td align="left">O(1)</td>
                     </tr>
                     <tr>
                        <td align="left">Checking if there is an edge connecting two nodes</td>
                        <td align="left">Graph</td>
                        <td align="left">O(min(source.outDegree(), target.inDegree()))</td>
                     </tr>
                  </tbody>
               </table>
            </div>
         </div>
         <div class="section" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="graph_advanced"></a>Advanced Topics
                     </h3>
                  </div>
               </div>
               <div></div>
            </div>
            <p>
               
            </p>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a name="Hiding Graph Elements"></a>Hiding Graph Elements
                        </h4>
                     </div>
                  </div>
                  <div></div>
               </div>
               <p>
                  Support for hiding graph elements is further completed by classes 
                  <a href="../api/y/util/GraphHider.html" title="Link to API documentation" target="_top">GraphHider<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> and 
                  <a href="../api/y/util/GraphPartitionManager.html" title="Link to API documentation" target="_top">GraphPartitionManager<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> from package 
                  <a href="../api/y/util/package-summary.html" title="Link to API documentation" target="_top">y.util<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>.
                  In addition to the methods from class Graph, GraphHider offers various methods 
                  to hide arbitrary collections of graph elements or even all elements from the 
                  graph at once. 
                  Moreover, it automatically keeps track of all elements hidden as a result of 
                  such method calls. 
                  
               </p><a class="indexterm" name="d0e1434"></a><p>
                  To unhide graph elements, class GraphHider provides a small set of methods that 
                  collectively employ all-at-once behavior when unhiding, i.e., all elements 
                  previously hidden are unhidden at once. 
                  
                  
                  
               </p>
               <p>
                  Class GraphPartitionManager extends the idea from class GraphHider in a way so 
                  that it is possible to mark parts of the graph as so-called "partitions" and 
                  hide/unhide these. 
                  <a href="analysis.html#connect_ex" title="Example&nbsp;4.18.&nbsp;Making a graph connected">Example&nbsp;4.18, &#8220;Making a graph connected&#8221;</a> is a rather extensive code snippet where an 
                  instance of GraphPartitionManager is used to hide/unhide connected components. 
                  
               </p>
               <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Important</h3>
                  <p>
                     When working with graph hierarchies graph elements must not be hidden, but 
                     instead should be removed. 
                     
                  </p>
               </div>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a name="graph_copying"></a>Copying a Graph
                        </h4>
                     </div>
                  </div>
                  <div></div>
               </div><a class="indexterm" name="d0e1451"></a><a class="indexterm" name="d0e1456"></a><a class="indexterm" name="d0e1461"></a><a class="indexterm" name="d0e1466"></a><p>
                  Class <a href="../api/y/util/GraphCopier.html" title="Link to API documentation" target="_top">GraphCopier<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> provides convenient 
                  support for copying an object of type y.base.Graph. 
                  It enables the complete range from copying the entire Graph to copying only 
                  sets of graph elements. 
                  Optionally, any data associated to either nodes or edges by means of data 
                  accessors, i.e., data providers or node maps and edge maps, respectively, can 
                  also be copied.
                  
               </p>
               <p>
                  GraphCopier relies on implementations of static inner interface 
                  <a href="../api/y/util/GraphCopier.CopyFactory.html" title="Link to API documentation" target="_top">GraphCopier.CopyFactory<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> to delegate the 
                  actual work of copying nodes and edges from one graph to another to. 
                  
                  
                  
                  A simple default implementation for a copy factory that is capable of handling 
                  a Graph object is provided by class 
                  <a href="../api/y/base/GraphCopyFactory.html" title="Link to API documentation" target="_top">GraphCopyFactory<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>. 
                  Initially, i.e., when no other copy factory has been set, class Graph returns a 
                  similar implementation when its 
                  <a href="../api/y/base/Graph.html#getGraphCopyFactory()" title="Link to API documentation" target="_top">getGraphCopyFactory<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a> 
                  method is invoked.
                  
               </p>
               <div class="example"><a name="ex_GraphCopier_creation"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Creating a GraphCopier</b></p><pre class="programlisting java">
// 'graph' is of type y.base.Graph.

// Create a new GraphCopier that uses the copy factory which is registered with 
// the graph.
GraphCopier gc = new GraphCopier(graph.getGraphCopyFactory());
</pre></div>
               <p>
                  The following methods from class GraphCopier can be used to copy either an entire
                  Graph object or the subgraph that is induced by a given set of nodes from a given
                  source graph:
                  
               </p>
               <div class="techn_templ">
                  <center>
                     <table width="100%" border="1">
                        <colgroup>
                           <col width="16%" align="left">
                           <col width="84%" align="left">
                        </colgroup>
                        <tbody valign="top">
                           <tr class="techn_api">
                              <td colspan="2" align="left"><pre class="programlisting ignore"><a href="../api/y/util/GraphCopier.html#copy(y.base.Graph)" title="Link to API documentation" target="_top">Graph copy(Graph sourceGraph)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
<a href="../api/y/util/GraphCopier.html#copy(y.base.Graph, y.base.Graph)" title="Link to API documentation" target="_top">NodeList copy(Graph sourceGraph, Graph targetGraph)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
</pre></td>
                           </tr>
                           <tr class="spacing">
                              <td align="left">Description</td>
                              <td align="left">Copies an entire graph.</td>
                           </tr>
                           <tr class="techn_api">
                              <td colspan="2" align="left"><pre class="programlisting ignore"><a href="../api/y/util/GraphCopier.html#copy(y.base.Graph, y.base.NodeCursor)" title="Link to API documentation" target="_top">Graph copy(Graph sourceGraph, NodeCursor sourceNodes)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
<a href="../api/y/util/GraphCopier.html#copy(y.base.Graph, y.base.NodeCursor, y.base.Graph)" title="Link to API documentation" target="_top">NodeList copy(Graph sourceGraph, NodeCursor sourceNodes, Graph targetGraph)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
</pre></td>
                           </tr>
                           <tr class="spacing">
                              <td align="left">Description</td>
                              <td align="left">Copies the subgraph induced by the given nodes.</td>
                           </tr>
                        </tbody>
                     </table>
                  </center>
               </div>
               <p>
                  By default, copying a Graph object or a set of nodes does not include any data 
                  associated with either the nodes or edges. 
                  The following methods can be used to control whether the contents of data accessors,
                  i.e., both data providers and node maps and edge maps, respectively, that are registered
                  with the source graph are copied over to the target graph, too.
                  
               </p>
               <div class="techn_templ">
                  <center>
                     <table width="100%" border="1">
                        <colgroup>
                           <col width="16%" align="left">
                           <col width="84%" align="left">
                        </colgroup>
                        <tbody valign="top">
                           <tr class="techn_api">
                              <td colspan="2" align="left"><pre class="programlisting ignore"><a href="../api/y/util/GraphCopier.html#setDataProviderContentCopying(boolean)" title="Link to API documentation" target="_top">void setDataProviderContentCopying(boolean dataProviderContentCopying)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
</pre></td>
                           </tr>
                           <tr class="spacing">
                              <td align="left">Description</td>
                              <td align="left">Controls whether to copy data provider contents.</td>
                           </tr>
                           <tr class="techn_api">
                              <td colspan="2" align="left"><pre class="programlisting ignore"><a href="../api/y/util/GraphCopier.html#setNodeMapCopying(boolean)" title="Link to API documentation" target="_top">void setNodeMapCopying(boolean nodeMapCopying)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
<a href="../api/y/util/GraphCopier.html#setEdgeMapCopying(boolean)" title="Link to API documentation" target="_top">void setEdgeMapCopying(boolean edgeMapCopying)<sup xmlns="http://www.w3.org/1999/xhtml" xmlns:fo="http://www.w3.org/1999/XSL/Format"><img src="figures/icon_api.gif" align="bottom" border="0"></img></sup></a>
</pre></td>
                           </tr>
                           <tr class="spacing">
                              <td align="left">Description</td>
                              <td align="left">
                                 Determines whether to copy the contents of node maps and edge maps registered with
                                 the source graph.
                                 
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </center>
               </div>
               <p>
                  Data accessors are presented in <a href="data_accessors.html" title="Binding Data to Graph Elements">the section called &#8220;Binding Data to Graph Elements&#8221;</a>.
                  
               </p>
            </div>
         </div>
      </div>
      <table class="copyright" border="0" cellpadding="0" cellspacing="0" width="100%">
         <tbody>
            <tr>
               <td align="right">
                  <p class="copyright">Copyright &copy;2004-2015, yWorks GmbH. All rights reserved.</p>
               </td>
            </tr>
         </tbody>
      </table>
      <div class="navfooter">
         <div class="navline2"></div>
         <div style="display:none"><img src="figures/navline2.jpg" alt=""><img src="figures/navbg2.jpg" alt=""></div>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="base.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center"><a accesskey="u" href="base.html">Up</a></td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="events_and_listeners.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Working with the Graph Structure&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html" target="_top">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Events and Listeners</td>
            </tr>
         </table>
      </div>
   </body>
</html>
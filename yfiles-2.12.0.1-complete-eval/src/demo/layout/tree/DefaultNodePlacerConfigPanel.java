/****************************************************************************
 * This demo file is part of yFiles for Java 2.12.0.1.
 * Copyright (c) 2000-2016 by yWorks GmbH, Vor dem Kreuzberg 28,
 * 72070 Tuebingen, Germany. All rights reserved.
 * 
 * yFiles demo files exhibit yFiles for Java functionalities. Any redistribution
 * of demo files in source code or binary form, with or without
 * modification, is not permitted.
 * 
 * Owners of a valid software license for a yFiles for Java version that this
 * demo is shipped with are allowed to use the demo source code as basis
 * for their own yFiles for Java powered applications. Use of such programs is
 * governed by the rights and conditions as set out in the yFiles for Java
 * license agreement.
 * 
 * THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 * NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ***************************************************************************/
package demo.layout.tree;

import y.base.Node;
import y.layout.DefaultLayoutGraph;
import y.layout.tree.DefaultNodePlacer;
import y.layout.tree.DefaultPortAssignment;
import y.layout.tree.GenericTreeLayouter;
import y.layout.tree.NodePlacer;
import y.layout.tree.PortAssignment;
import y.util.DataProviders;

import javax.swing.BorderFactory;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.Border;
import javax.swing.border.EtchedBorder;
import javax.swing.event.ChangeEvent;
import java.awt.Dimension;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.util.Hashtable;

/**
 * Property editor panel used by
 * {@link demo.layout.tree.IncrementalTreeLayouterDemo} 
 * to provide means for configuring the generic tree layouter.
 * 
 */
class DefaultNodePlacerConfigPanel extends javax.swing.JPanel
{
  
  private DefaultNodePlacer placer;
  private GenericTreeLayouter treeLayouter;

  /** Creates new form DefaultNodePlacerConfigPanel */
  public DefaultNodePlacerConfigPanel()
  {
    initComponents();
    DefaultLayoutGraph graph = new DefaultLayoutGraph();
    Node root = graph.createNode();
    graph.getNodeLayout(root).setSize(30,30);
    for (int i = 0; i < 3; i++){
      Node child = graph.createNode();
      graph.getNodeLayout(child).setSize(50 - i * 10 ,30);
      graph.createEdge(root, child);
    }
    this.placer = new DefaultNodePlacer(DefaultNodePlacer.PLACEMENT_HORIZONTAL_DOWNWARD, 40, 40);
    this.treeLayouter = new GenericTreeLayouter();
    layoutPreviewPanel.setGraph(graph);
    layoutPreviewPanel.setPreferredSize(new Dimension(160,160));
    graph.addDataProvider(GenericTreeLayouter.NODE_PLACER_DPKEY, DataProviders.createConstantDataProvider(placer));
//    layoutPreviewPanel.setLayouter(new GenericTreeLayouter());
    layoutPreviewPanel.setLayouter(this.treeLayouter);
    updateFromPlacer();
    updateFromPort();
    layoutPreviewPanel.update();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents()//GEN-BEGIN:initComponents
  {
    java.awt.GridBagConstraints gridBagConstraints;

    childPlacementLabel = new javax.swing.JLabel();
    rootAlignmentLabel = new javax.swing.JLabel();
    alignmentSlider = new javax.swing.JSlider();
    horizontalSlider = new javax.swing.JSlider();
    hSpacingLabel = new javax.swing.JLabel();
    placementComboBox = new javax.swing.JComboBox();
    verticalSlider = new javax.swing.JSlider();
    vSpacingLabel = new javax.swing.JLabel();
    previewPanel = new javax.swing.JPanel();
    layoutPreviewPanel = new demo.layout.withoutview.LayoutPreviewPanel();
    routingStyleLabel = new javax.swing.JLabel();
    routingStyleComboBox = new javax.swing.JComboBox();
    ratioLabel = new javax.swing.JLabel();
    ratioSlider = new javax.swing.JSlider( javax.swing.JSlider.HORIZONTAL, 0, 200, 100);
    minFirstSegmentLabel = new javax.swing.JLabel();
    minLastSegmentLabel = new javax.swing.JLabel();
    minFirstSegmentSlider = new javax.swing.JSlider();
    minLastSegmentSlider = new javax.swing.JSlider();
    slopeLabel = new javax.swing.JLabel();
    slopeSlider = new javax.swing.JSlider( javax.swing.JSlider.HORIZONTAL, 0, 200, 0);
    slopeHeightLabel = new javax.swing.JLabel();
    slopeHeightSlider = new javax.swing.JSlider();
    distributedCheckBox = new JCheckBox("Distributed Port Assignment Style");

    setLayout(new java.awt.GridBagLayout());

    setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(6, 6, 6, 6)));

    //////////////////
    // Drop down box for the alignment of children in respect to their parents
    //////////////////

    childPlacementLabel.setText("Child Placement");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    add(childPlacementLabel, gridBagConstraints);

    placementComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Horizontally Downwards", "Horizontally Upwards", "Vertically to Left", "Vertically to Right" }));
    placementComboBox.addItemListener(new java.awt.event.ItemListener()
    {
      public void itemStateChanged(java.awt.event.ItemEvent evt)
      {
        placementComboBoxItemStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 4);
    add(placementComboBox, gridBagConstraints);

    //////////////////
    // Drop down box for the selection of the routing style between nodes
    //////////////////

    routingStyleLabel.setText("Routing Style");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    add(routingStyleLabel, gridBagConstraints);

    routingStyleComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Fork", "Fork at Root", "Poly Line Connect" }));
    routingStyleComboBox.addItemListener(new java.awt.event.ItemListener()
    {
      public void itemStateChanged(java.awt.event.ItemEvent evt)
      {
        routingStyleComboBoxItemStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 3;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 5);
    add(routingStyleComboBox, gridBagConstraints);

    //////////////////
    // Slider for the horizontal spacing between nodes
    //////////////////

    hSpacingLabel.setText("Horizontal Spacing");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 5;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    add(hSpacingLabel, gridBagConstraints);

    horizontalSlider.setMinorTickSpacing(5);
    horizontalSlider.setPaintTicks(true);
    horizontalSlider.addChangeListener(new javax.swing.event.ChangeListener()
    {
      public void stateChanged(javax.swing.event.ChangeEvent evt)
      {
        horizontalSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 6;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(horizontalSlider, gridBagConstraints);

    //////////////////
    // Slider for the vertical spacing between nodes
    //////////////////

    vSpacingLabel.setText("Vertical Spacing");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 7;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    add(vSpacingLabel, gridBagConstraints);

    verticalSlider.setMinorTickSpacing(5);
    verticalSlider.setPaintTicks(true);
    verticalSlider.addChangeListener(new javax.swing.event.ChangeListener()
    {
      public void stateChanged(javax.swing.event.ChangeEvent evt)
      {
        verticalSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 8;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(verticalSlider, gridBagConstraints);

    //////////////////
    // Slope related items here. Slopes are only available for ROUTE_FORK routing style for now.
    //////////////////
    // Slider for the minimum length of the segment from the port of the parent node to the first bend of the outgoing edge
    //////////////////
    Border border = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED);
    JPanel slopeItems = new JPanel(new GridBagLayout());
    slopeItems.setBorder(BorderFactory.createTitledBorder(border, "Slopes"));

    minFirstSegmentLabel.setText("Min First Segment Length");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    slopeItems.add(minFirstSegmentLabel, gridBagConstraints);

    minFirstSegmentSlider.setMinorTickSpacing(5);
    minFirstSegmentSlider.setPaintTicks(true);
    minFirstSegmentSlider.addChangeListener(new javax.swing.event.ChangeListener() {
      public void stateChanged(javax.swing.event.ChangeEvent evt) {
        minFirstSegSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    slopeItems.add(minFirstSegmentSlider, gridBagConstraints);

    //////////////////
    // Slider for the minimum length of the segment from the last bend of an edge to the port of the child node
    //////////////////

    minLastSegmentLabel.setText("Min Last Segment Length");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    slopeItems.add(minLastSegmentLabel, gridBagConstraints);

    minLastSegmentSlider.setMinorTickSpacing(5);
    minLastSegmentSlider.setPaintTicks(true);
    minLastSegmentSlider.addChangeListener(new javax.swing.event.ChangeListener() {
      public void stateChanged(javax.swing.event.ChangeEvent evt) {
        minLastSegSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 3;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    slopeItems.add(minLastSegmentSlider, gridBagConstraints);

    //////////////////
    // Slider for the minimum slope
    //////////////////

    slopeLabel.setText("Min Slope");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 4;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    slopeItems.add(slopeLabel, gridBagConstraints);

    slopeSlider.setMinorTickSpacing(5);
    slopeSlider.setPaintTicks(true);
    slopeSlider.setPaintLabels(true);
    Hashtable slopeLabelTable = new Hashtable();
    slopeLabelTable.put(new Integer(0), new JLabel("0"));
    slopeLabelTable.put(new Integer(100), new JLabel("1.0"));
    slopeLabelTable.put(new Integer(200), new JLabel("2.0"));
    slopeSlider.setLabelTable(slopeLabelTable);
    slopeSlider.addChangeListener(new javax.swing.event.ChangeListener() {
      public void stateChanged(javax.swing.event.ChangeEvent evt) {
        slopeSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 5;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    slopeItems.add(slopeSlider, gridBagConstraints);

    //////////////////
    // Slider for the minimum slope height
    //////////////////

    slopeHeightLabel.setText("Min Slope Height");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 6;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    slopeItems.add(slopeHeightLabel, gridBagConstraints);

    slopeHeightSlider.setMinorTickSpacing(5);
    slopeHeightSlider.setPaintTicks(true);
    slopeHeightSlider.addChangeListener(new javax.swing.event.ChangeListener() {
      public void stateChanged(javax.swing.event.ChangeEvent evt) {
        slopeHeightSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 7;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    slopeItems.add(slopeHeightSlider, gridBagConstraints);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 9;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    add(slopeItems, gridBagConstraints);

    // END Slope related items.

    //////////////////
    //  Port assignment related items
    //////////////////
    //  Slider for the ratio of the port's border gap to port gap
    //////////////////

    JPanel portItems = new JPanel(new GridBagLayout());
    portItems.setBorder(BorderFactory.createTitledBorder(border, "Port Assignment"));

    //////////////////
    // A check box that indicates whether or not the ports of a node should be distributed (true) or on the same point
    //////////////////

    distributedCheckBox.addActionListener(new ActionListener() {
      public void actionPerformed(final ActionEvent e) {
        boolean selected = ((JCheckBox) e.getSource()).isSelected();
        DefaultNodePlacerConfigPanel.this.ratioLabel.setEnabled(selected);
        DefaultNodePlacerConfigPanel.this.ratioSlider.setEnabled(selected);
        assignPortAssignment(selected);
        layoutPreviewPanel.update();
        fireChangeListenerStateChanged(new ChangeEvent(DefaultNodePlacerConfigPanel.this));
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(5, 4, 0, 5);
    portItems.add(distributedCheckBox, gridBagConstraints);

    ratioLabel.setText("Port Border Gap Ratio");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    portItems.add(ratioLabel, gridBagConstraints);

    ratioSlider.setMinorTickSpacing(5);
    ratioSlider.setPaintTicks(true);
    ratioSlider.setPaintLabels(true);
    Hashtable ratioLabelTable = new Hashtable();
    ratioLabelTable.put(new Integer(0), new JLabel("0"));
    ratioLabelTable.put(new Integer(50), new JLabel("1:2"));
    ratioLabelTable.put(new Integer(100), new JLabel("1:1"));
    ratioLabelTable.put(new Integer(150), new JLabel("3:2"));
    ratioLabelTable.put(new Integer(200), new JLabel("2:1"));
    ratioSlider.setLabelTable(ratioLabelTable);
    ratioSlider.addChangeListener(new javax.swing.event.ChangeListener()
    {
      public void stateChanged(javax.swing.event.ChangeEvent evt)
      {
        ratioSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 2;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    portItems.add(ratioSlider, gridBagConstraints);

    // END port assignment related items

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 10 ;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(portItems, gridBagConstraints);


    //////////////////
    // Root Alignment Slider - Leading, Center, Median, Trailing etc.
    //////////////////

    rootAlignmentLabel.setText("Root Alignment");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 11;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHWEST;
    gridBagConstraints.insets = new java.awt.Insets(7, 0, 0, 0);
    add(rootAlignmentLabel, gridBagConstraints);

    alignmentSlider.setMaximum(5);
    alignmentSlider.setMinorTickSpacing(1);
    alignmentSlider.setPaintLabels(true);
    alignmentSlider.setPaintTicks(true);
    alignmentSlider.setSnapToTicks(true);

    Hashtable labelTable = new Hashtable();
    labelTable.put( new Integer( 0 ), new JLabel("Leading") );
    labelTable.put( new Integer( 3 ), new JLabel("Median") );
    labelTable.put( new Integer( 5 ), new JLabel("Trailing") );
    alignmentSlider.setLabelTable( labelTable );
    alignmentSlider.addChangeListener(new javax.swing.event.ChangeListener()
    {
      public void stateChanged(javax.swing.event.ChangeEvent evt)
      {
        alignmentSliderStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 12;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    add(alignmentSlider, gridBagConstraints);

    //////////////////
    // Preview Window
    //////////////////

    previewPanel.setLayout(new java.awt.BorderLayout());
    previewPanel.setBorder(new javax.swing.border.TitledBorder("Preview"));
    layoutPreviewPanel.setBackground(new java.awt.Color(255, 255, 255));
    previewPanel.add(layoutPreviewPanel, java.awt.BorderLayout.CENTER);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 13;
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    add(previewPanel, gridBagConstraints);

  }//GEN-END:initComponents

  /**
   * Calculates settings for the placement of children and enables the distribution of the ports.
   */
  private void assignPortAssignment(boolean selected){
    final DefaultPortAssignment dpa = (DefaultPortAssignment) treeLayouter.getDefaultPortAssignment();
    if (!selected){
      // center port assignment, no reversion needed.
      dpa.setMode(DefaultPortAssignment.MODE_NONE);
      dpa.setReversedPortOrder(false);
    }
    else {
      final int placementSelection = this.placementComboBox.getSelectedIndex();
      final boolean  leading = this.alignmentSlider.getValue() < 2 || this.alignmentSlider.getValue() == 7; //  center and median are excluded
      final boolean  trailing = this.alignmentSlider.getValue() > 3 && this.alignmentSlider.getValue() != 7;
      final boolean rootForking = this.routingStyleComboBox.getSelectedIndex() == 1;
      if (placementSelection == 0 ){
        // placement is horizontally downwards. For proper distribution, the relative position of the root to it's children must be checked.
        if (rootForking){
          if (leading){
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_EAST);
            dpa.setReversedPortOrder(true);
          }
          else if (trailing){
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_WEST);
            dpa.setReversedPortOrder(false);
          }
          else { // center or median
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_SOUTH);
            dpa.setReversedPortOrder(false);
          }
        }
        else {
          dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_SOUTH);
          dpa.setReversedPortOrder(false);
        }
      }
      else if (placementSelection == 1) {
        // placement is horizontally upwards. For proper distribution, the relative position of the root to it's children must be checked.
        if (rootForking) {
          if (leading) {
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_EAST);
            dpa.setReversedPortOrder(false);
          } else if (trailing) {
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_WEST);
            dpa.setReversedPortOrder(true);
          } else { // center or median
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_NORTH);
            dpa.setReversedPortOrder(false);
          }
        } else {
          dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_NORTH);
          dpa.setReversedPortOrder(false);
        }
      } else if (placementSelection == 2) {
        // placement is vertically left. For proper distribution, the relative position of the root to it's children must be checked.
        if (rootForking) {
          if (leading) {
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_SOUTH);
            dpa.setReversedPortOrder(false);
          } else if (trailing) {
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_NORTH);
            dpa.setReversedPortOrder(true);
          } else { // center or median
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_WEST);
            dpa.setReversedPortOrder(false);
          }
        } else {
          dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_WEST);
          dpa.setReversedPortOrder(false);
        }
      } else if (placementSelection == 3) {
        // placement is vertically right. For proper distribution, the relative position of the root to it's children must be checked.
        if (rootForking) {
          if (leading) {
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_SOUTH);
            dpa.setReversedPortOrder(true);
          } else if (trailing) {
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_NORTH);
            dpa.setReversedPortOrder(false);
          } else { // center or median
            dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_EAST);
            dpa.setReversedPortOrder(false);
          }
        } else {
          dpa.setMode(DefaultPortAssignment.MODE_PORT_DISTRIBUTED_EAST);
          dpa.setReversedPortOrder(false);
        }
      }
    }
  }

  private void ratioSliderStateChanged(ChangeEvent evt) //GEN-FIRST:event_ratioSliderStateChanged
  {//GEN-HEADEREND:event_ratioSliderStateChanged
    ((DefaultPortAssignment)treeLayouter.getDefaultPortAssignment()).setBorderGapToPortGapRatio(ratioSlider.getValue() * 0.01d);
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_ratioSliderStateChanged

  private void routingStyleComboBoxItemStateChanged(java.awt.event.ItemEvent evt)//GEN-FIRST:event_routingStyleComboBoxItemStateChanged
  {//GEN-HEADEREND:event_routingStyleComboBoxItemStateChanged
    if (evt.getStateChange() == ItemEvent.SELECTED){
      switch (routingStyleComboBox.getSelectedIndex()){
        case 0:
          placer.setRoutingStyle(DefaultNodePlacer.ROUTING_FORK);
          enableSlopePanel(true);
          break;
        case 1:
          placer.setRoutingStyle(DefaultNodePlacer.ROUTING_FORK_AT_ROOT);
          enableSlopePanel(false);
          break;
        case 2:
          placer.setRoutingStyle(DefaultNodePlacer.ROUTING_POLY_LINE);
          enableSlopePanel(false);
          break;
      }
      assignPortAssignment(this.distributedCheckBox.isSelected());
      layoutPreviewPanel.update();
      fireChangeListenerStateChanged(new ChangeEvent(this));
    }
  }//GEN-LAST:event_routingStyleComboBoxItemStateChanged

  private void verticalSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_verticalSliderStateChanged
  {//GEN-HEADEREND:event_verticalSliderStateChanged
    placer.setVerticalDistance(verticalSlider.getValue());
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_verticalSliderStateChanged

  private void horizontalSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_horizontalSliderStateChanged
  {//GEN-HEADEREND:event_horizontalSliderStateChanged
    placer.setHorizontalDistance(horizontalSlider.getValue());
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_horizontalSliderStateChanged

  private void minFirstSegSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_minFirstSegSliderStateChanged
  {//GEN-HEADEREND:minFirstSegSliderStateChanged
    placer.setMinFirstSegmentLength(minFirstSegmentSlider.getValue());
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_minFirstSegSliderStateChanged

  private void minLastSegSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_minLastSegSliderStateChanged
  {//GEN-HEADEREND:minLastSegSliderStateChanged
    placer.setMinLastSegmentLength(minLastSegmentSlider.getValue());
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_minlastSegSliderStateChanged

  private void slopeSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_slopeSliderStateChanged
  {//GEN-HEADEREND:event_slopeSliderStateChanged
    placer.setMinSlope(slopeSlider.getValue()*0.01d);
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_slopeSliderStateChanged

  private void slopeHeightSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_slopeHeightSliderStateChanged
  {//GEN-HEADEREND:event_slopeHeightSliderStateChanged
    placer.setMinSlopeHeight(slopeHeightSlider.getValue());
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_slopeHeightSliderStateChanged

  private void alignmentSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_alignmentSliderStateChanged
  {//GEN-HEADEREND:event_alignmentSliderStateChanged
    placer.setRootAlignment( (byte) alignmentSlider.getValue());
    assignPortAssignment(this.distributedCheckBox.isSelected());
    layoutPreviewPanel.update();
    fireChangeListenerStateChanged(new ChangeEvent(this));
  }//GEN-LAST:event_alignmentSliderStateChanged

  private void placementComboBoxItemStateChanged(java.awt.event.ItemEvent evt)//GEN-FIRST:event_placementComboBoxItemStateChanged
  {//GEN-HEADEREND:event_placementComboBoxItemStateChanged
    if (evt.getStateChange() == ItemEvent.SELECTED){
      switch (placementComboBox.getSelectedIndex()){
        case 0:
          placer.setChildPlacement(DefaultNodePlacer.PLACEMENT_HORIZONTAL_DOWNWARD);
          break;
        case 1:
          placer.setChildPlacement(DefaultNodePlacer.PLACEMENT_HORIZONTAL_UPWARD);
          break;
        case 2:
          placer.setChildPlacement(DefaultNodePlacer.PLACEMENT_VERTICAL_TO_LEFT);
          break;
        case 3:
          placer.setChildPlacement(DefaultNodePlacer.PLACEMENT_VERTICAL_TO_RIGHT);
          break;
      }
      assignPortAssignment(this.distributedCheckBox.isSelected());
      layoutPreviewPanel.update();
      fireChangeListenerStateChanged(new ChangeEvent(this));
    }
  }//GEN-LAST:event_placementComboBoxItemStateChanged

  /**
   * Enables or disables all slope related items.
   * @param enabled whether the slope related items should be enabled or not.
   */
  private void enableSlopePanel(boolean enabled){
    this.minFirstSegmentLabel.setEnabled(enabled);
    this.minFirstSegmentSlider.setEnabled(enabled);
    this.minLastSegmentLabel.setEnabled(enabled);
    this.minLastSegmentSlider.setEnabled(enabled);
    this.slopeLabel.setEnabled(enabled);
    this.slopeSlider.setEnabled(enabled);
    this.slopeHeightLabel.setEnabled(enabled);
    this.slopeHeightSlider.setEnabled(enabled);
  }

  /**
   * Updates the current model to the values of the current {@link NodePlacer}.
   */
  public void updateFromPlacer(){
    switch (placer.getChildPlacement()){
      case DefaultNodePlacer.PLACEMENT_HORIZONTAL_DOWNWARD:
        placementComboBox.setSelectedIndex(0);
        break;
      case DefaultNodePlacer.PLACEMENT_HORIZONTAL_UPWARD:
        placementComboBox.setSelectedIndex(1);
        break;
      case DefaultNodePlacer.PLACEMENT_VERTICAL_TO_LEFT:
        placementComboBox.setSelectedIndex(2);
        break;
      case DefaultNodePlacer.PLACEMENT_VERTICAL_TO_RIGHT:
        placementComboBox.setSelectedIndex(3);
        break;
    }
    switch (placer.getRoutingStyle()){
      case DefaultNodePlacer.ROUTING_FORK:
        routingStyleComboBox.setSelectedIndex(0);
        break;
      case DefaultNodePlacer.ROUTING_FORK_AT_ROOT:
        routingStyleComboBox.setSelectedIndex(1);
        break;
      case DefaultNodePlacer.ROUTING_POLY_LINE:
        routingStyleComboBox.setSelectedIndex(2);
        break;
    }
    alignmentSlider.setValue(placer.getRootAlignment());
    horizontalSlider.setValue((int)placer.getHorizontalDistance());
    verticalSlider.setValue((int)placer.getVerticalDistance());
    minFirstSegmentSlider.setValue((int) placer.getMinFirstSegmentLength());
    minLastSegmentSlider.setValue((int) placer.getMinLastSegmentLength());
    slopeSlider.setValue((int) (placer.getMinSlope() * 100));
    slopeHeightSlider.setValue((int) (placer.getMinSlopeHeight()));
  }

  /**
   * Updates the current model to the values of the current {@link DefaultPortAssignment}.
   */
  public void updateFromPort(){
    DefaultPortAssignment dpa = (DefaultPortAssignment) treeLayouter.getDefaultPortAssignment();
    boolean distributed = dpa.getMode() != DefaultPortAssignment.MODE_NONE;
    distributedCheckBox.setSelected(distributed);
    ratioLabel.setEnabled(distributed);
    ratioSlider.setEnabled(distributed);
    ratioSlider.setValue((int) (dpa.getBorderGapToPortGapRatio()*100));
  }

  /**
   * Updates the current node placer with the values of the given node placer.
   * Also invokes <code>updateFromPlacer()</code>.
   * @param fromPlacer the {@link NodePlacer} to get the new values from.
   */
  public void adoptPlacerValues(NodePlacer fromPlacer){
    if (fromPlacer instanceof DefaultNodePlacer){
      DefaultNodePlacer p = (DefaultNodePlacer) fromPlacer;
      this.placer.setRoutingStyle(p.getRoutingStyle());
      this.placer.setChildPlacement(p.getChildPlacement());
      this.placer.setVerticalDistance(p.getVerticalDistance());
      this.placer.setHorizontalDistance(p.getHorizontalDistance());
      this.placer.setRootAlignment(p.getRootAlignment());
      this.placer.setMinFirstSegmentLength(p.getMinFirstSegmentLength());
      this.placer.setMinLastSegmentLength(p.getMinLastSegmentLength());
      this.placer.setMinSlope(p.getMinSlope());
      this.placer.setMinSlopeHeight(p.getMinSlopeHeight());
      updateFromPlacer();
    }
  }

  /**
   * Updates the current port assignment with the values of the given port assignment.
   * Also invokes <code>updateFromPort()</code>.
   * @param fromPort the {@link DefaultPortAssignment} to get the new values from.
   */
  public void adoptPortValues(PortAssignment fromPort){
    if (fromPort instanceof DefaultPortAssignment){
      DefaultPortAssignment p = (DefaultPortAssignment) fromPort;
      DefaultPortAssignment to = (DefaultPortAssignment) this.treeLayouter.getDefaultPortAssignment();
      to.setMode(p.getMode());
      to.setBorderGapToPortGapRatio(p.getBorderGapToPortGapRatio());
      to.setReversedPortOrder(p.isReversedPortOrder());
      updateFromPort();
    }
  }

  /**
   * Creates a new clone of the placer.
   * @return a new instance of the <code>NodePlacer</code> with the same settings.
   */
  public NodePlacer createPlacerCopy(){
    return (NodePlacer) placer.clone();
  }

  /**
   * Creates a new clone of the DefaultPortAssignment.
   * @return a new instance of the <code>DefaultPortAssignment</code> with the same settings.
   */
  public DefaultPortAssignment createPortAssignmentCopy(){
    DefaultPortAssignment dpa = (DefaultPortAssignment)this.treeLayouter.getDefaultPortAssignment();
    DefaultPortAssignment copy = new DefaultPortAssignment (dpa.getMode(), dpa.getBorderGapToPortGapRatio());
    copy.setReversedPortOrder(dpa.isReversedPortOrder());
    return copy;
  }
  
  /**
   * Registers ChangeListener to receive events.
   * @param listener The listener to register.
   */
  public synchronized void addChangeListener(javax.swing.event.ChangeListener listener)
  {
    if (changeListenerList == null )
    {
      changeListenerList = new java.util.ArrayList();
    }
    changeListenerList.add(listener);
  }
  
  /**
   * Removes ChangeListener from the list of listeners.
   * @param listener The listener to remove.
   */
  public synchronized void removeChangeListener(javax.swing.event.ChangeListener listener)
  {
    if (changeListenerList != null )
    {
      changeListenerList.remove(listener);
    }
  }
  
  /**
   * Notifies all registered listeners about the event.
   *
   * @param event The event to be fired
   */
  private void fireChangeListenerStateChanged(javax.swing.event.ChangeEvent event)
  {
    java.util.ArrayList list;
    synchronized (this)
    {
      if (changeListenerList == null) return;
      list = (java.util.ArrayList)changeListenerList.clone();
    }
    for (int i = 0; i < list.size(); i++)
    {
      ((javax.swing.event.ChangeListener)list.get(i)).stateChanged(event);
    }
  }
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JSlider alignmentSlider;
  private javax.swing.JLabel childPlacementLabel;
  private javax.swing.JLabel hSpacingLabel;
  private javax.swing.JSlider horizontalSlider;
  private demo.layout.withoutview.LayoutPreviewPanel layoutPreviewPanel;
  private javax.swing.JComboBox placementComboBox;
  private javax.swing.JPanel previewPanel;
  private javax.swing.JLabel rootAlignmentLabel;
  private javax.swing.JComboBox routingStyleComboBox;
  private javax.swing.JLabel routingStyleLabel;
  private javax.swing.JLabel vSpacingLabel;
  private javax.swing.JSlider verticalSlider;
  private javax.swing.JSlider ratioSlider;
  private javax.swing.JLabel ratioLabel;
  private javax.swing.JSlider minFirstSegmentSlider;
  private javax.swing.JSlider minLastSegmentSlider;
  private javax.swing.JLabel minFirstSegmentLabel;
  private javax.swing.JLabel minLastSegmentLabel;
  private javax.swing.JSlider slopeSlider;
  private javax.swing.JLabel slopeLabel;
  private javax.swing.JSlider slopeHeightSlider;
  private javax.swing.JLabel slopeHeightLabel;
  private JCheckBox distributedCheckBox;
  // End of variables declaration//GEN-END:variables
  /**
   * Utility field holding list of ChangeListeners.
   */
  private transient java.util.ArrayList changeListenerList;  
   
}

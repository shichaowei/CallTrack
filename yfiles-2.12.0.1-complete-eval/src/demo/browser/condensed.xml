<?xml version="1.0" encoding="UTF-8"?>
<y:content xmlns="http://www.w3.org/1999/xhtml" xmlns:y="http://www.yworks.com/demo">
  <y:package javaname="demo">
  <y:displayname>Demos</y:displayname>
  <y:description>
    <h1>yFiles Demo Programs</h1>

    <p>
      The yFiles distributions contain a variety of tutorial Java programs
      accompanied by their source code. These programs demonstrate how to 
      use essential features of the yFiles library.
    </p>

    <p>
      Not all of the listed demos may be part of your yFiles distribution type.
      <b>yFiles Complete</b> contains all demo programs, <b>yFiles Viewer</b>
      contains all demos except the layout demos, <b>yFiles Layout</b>
      contains the graph, the graph algorithm, and the viewer independent
      layout demos in demo/layout. <b>yFiles Basic</b> contains only 
      the basic graph and graph algorithm demos.
    </p>

    <h2>Running the Demos</h2>

    <h3>From Within an IDE</h3>

    <p>
      Set <tt>&lt;yFilesDir&gt;/src</tt> as your source directory. 
      Then add <tt>&lt;yFilesDir&gt;/lib/y.jar</tt> <b>and</b> the source folder 
      <tt>&lt;yFilesDir&gt;/src</tt> to your classpath. 
      Now you should be ready to compile and run all executable demo classes. 
    </p>

    <p>
      If your IDE supports executing targets from ANT build files, the simplest
      way to run one of the demo programs is by calling the appropriate target
      from the demo build script <a href="build.xml">build.xml</a> located
      in this directory. See below for more information on the available ANT
      targets.
    </p>

    <h3>With Ant</h3>

    <p>
      First make sure you have the <a href="http://ant.apache.org">build tool Ant</a> 
      installed on your system. 
      Now you can use the demo build script <a href="build.xml">build.xml</a> located 
      in this directory to launch each demo by specifying its simple class name 
      as a target. 
    </p>

    <p>
      <b>Note:</b> 
      As an alternative, you can also use the build script's <tt>run</tt> target 
      to launch the DemoBrowser application, an interactive "shell" that allows 
      convenient access to all demos. 
      It features execution of each demo, and also displays both its source code 
      and documentation. 
    </p>

    <h2>Tutorial Demos</h2>

    <h3>Basic Graph Demos</h3>

    <p>
      Tutorial programs that show how to use the graph data type and related classes
      from the yFiles base package <a href="../../doc/api/y/base/package-summary.html">y.base</a>
      are located in the folder <a href="base/README.html">demo/base</a>. 
    </p>

    <h3>Graph Algorithm Demos</h3>

    <p>
      The graph algorithm demos are located in the folder 
      <a href="algo/README.html">demo/algo</a>. These tutorial
      demos show how to use some of the included graph and network algorithms
      that are located in the yFiles package <a href="../../doc/api/y/algo/package-summary.html">y.algo</a>.
    </p>

    <h3>Graph Viewer Demos</h3>

    <p>
      Programs that demonstrate how to use the yFiles graph viewer components in 
      an application are located in the folder <a href="view/README.html">demo/view</a>.
      <br/>
      Further aspects related to the viewer components and the visual representation of 
      graphs and their elements are demonstrated in several subpackages: 
    </p>
    <ul>
      <li>
        rendering in <a href="view/rendering/README.html">demo/view/rendering</a>
      </li>
      <li>
        node realizer and edge realizer customization in 
        <a href="view/realizer/README.html">demo/view/realizer</a> (and also in 
        <a href="view/advanced/README.html">demo/view/advanced</a> -- see below) 
      </li>
      <li>
        user interaction in 
        <a href="view/viewmode/README.html">demo/view/viewmode</a>
      </li>
    </ul>
    <p>
      The following subpackages present additional topics: 
    </p>
    <ul>
      <li>
        an extensive demo application that presents an organization chart in a visually 
        rich manner in <a href="view/orgchart/README.html">demo/view/orgchart</a>
      </li>
      <li>
        an extensive demo application that presents a simple network monitoring
        tool in
        <a href="view/networkmonitoring/README.html">demo/view/networkmonitoring</a>
      </li>
      <li>
        an extensive demo application for creating and editing UML class
        diagrams in
        <a href="view/uml/README.html">demo/view/uml</a>
      </li>
      <li>
        an extensive demo application that displays graphs in an isometric
        fashion to create the impression of a 3-dimensional view in
        <a href="view/isometry/README.html">demo/view/isometry</a>
      </li>
      <li>
        an extensive demo application that presents a basic, yet powerful mind
        map editor in
        <a href="view/mindmap/README.html">demo/view/mindmap</a>
      </li>
      <li>
        a demo application that presents a flowchart editor in
        <a href="view/flowchart/README.html">demo/view/flowchart</a>
      </li>
      <li>
        a demo application that presents a entity-relationship editor in
        <a href="view/entityrelationship/README.html">demo/view/entityrelationship</a>
      </li>
      <li>
        a demo application that shows how to explore large graphs interactively
        in <a href="view/graphexplorer/README.html">demo/view/graphexplorer</a>
      </li>
      <li>
        application-related functionality (undo/redo, print preview, etc.) in 
        <a href="view/application/README.html">demo/view/application</a>
      </li>
      <li>
        deploying yFiles viewer functionality as an applet inside web browsers in 
        <a href="view/applet/README.html">demo/view/applet</a>
      </li>
      <li>
        special node realizer features and how to support them with file I/O in 
        <a href="view/advanced/README.html">demo/view/advanced</a>
      </li>
    </ul>

    <h3>Graph Animation Demos</h3>

    <p>
      Programs that demonstrate how to add animated effects to graphs and views
      can be found in <a href="view/anim/README.html">demo/view/anim</a>.
    </p>

    <h3>Graph Hierarchy Demos</h3>
    <p>
      Sample applications that show how to use the nested graph hierarchy features 
      of yFiles are located in <a href="view/hierarchy/README.html">demo/view/hierarchy</a>.
    </p>

    <h3>Graph Layout Demos</h3>

    <p>
      Programs that demonstrate how to use the API of the diverse yFiles graph layout 
      algorithms can be found in the folder <a href="layout/README.html">demo/layout</a> 
      and its sub-folders. 
      Folder <a href="layout/withoutview/README.html">demo/layout/withoutview</a> contains
      demos that show how to use the layout and labeling
      functionality for various algorithms when the yFiles Viewer distribution is not present.              		      
    </p>

    <h3>Graph I/O Demos</h3>

    <p>
      Programs that show how to read and write graphs from and to different formats
      are located in <a href="io/README.html">demo/io</a>. This folder also 
      includes an example on how to customize and extend existing graph formats 
      to personal needs.
      <br/>
      The demos in <a href="io/graphml/README.html">demo/io/graphml</a> show how
      to use and how to customize the GraphML I/O functionality.
    </p>

    <h3>GUI Utility Demo</h3>

    <p>
      An example program that depicts the functionality of the yFiles 
      <a href="../../doc/api/y/option/package-summary.html">y.option</a>
      package of the yFiles Viewer distribution
      can be found in <a href="option/README.html">demo/option</a>.
    </p>

    <h2>yEd Lite Graph Editor Application</h2>

    <p>
      yEd Lite is a powerful multi-purpose
      graph editor. It exhibits most of the features available in
      the library. This source code demo is available as a separate download through our
      software download center.
    </p>


    <h2>yFiles Obfuscation Demo</h2>

    <p>
      <a href="obfuscation/README.html">This demo</a> shows how to obfuscate the yFiles 
      classes before they can be deployed as a part of an applet or application.
      In this demo the obfuscation process will be  performed by the Ant-based obfuscator 
      yGuard (<a href="http://www.yworks.com/products/yguard">yGuard home page</a>). 
    </p>
  </y:description>

<y:package javaname="demo.algo">
  <y:displayname>Graph Analysis Algorithms</y:displayname>
  <y:summary>Contains algorithmic demos for graph analysis.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Graph Algorithm Demos</h1>

    <p>
      The following graph algorithmic demos are in this package:
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Algorithm Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.algo.CyclesTest" source="CyclesTest.java">
    <y:displayname>Cycle Detection Algorithms</y:displayname>
    <y:summary>Tests consistency and performance of two different cycle detection mechanisms provided by yFiles for Java.</y:summary>
    <y:description>


    Tests consistency and performance of two different cycle detection mechanisms
          provided by yFiles.</y:description>
  <y:keywords>
<y:keyword>Cycles</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>cycle</y:keyword>
<y:keyword>detection</y:keyword>
<y:keyword>performance</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.GraphConnectivityTest" source="GraphConnectivityTest.java">
    <y:displayname>Graph Connectivity Algorithms</y:displayname>
    <y:summary>Compares performance and results of some graph connectivity algorithms available in yFiles for Java.</y:summary>
    <y:description>
      
      
    Compares the performance and results of some graph connectivity algorithms available
          in yFiles.</y:description>
  <y:keywords>
<y:keyword>GraphConnectivity</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>connected</y:keyword>
<y:keyword>biconnected</y:keyword>
<y:keyword>connection</y:keyword>
<y:keyword>component</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.SpanningTreeTest" source="SpanningTreeTest.java">
    <y:displayname>Spanning Tree Algorithms</y:displayname>
    <y:summary>Compares performance of minimum spanning tree algorithms available in yFiles for Java.</y:summary>
    <y:description>


    Compares the performance of minimum spanning tree algorithms available in yFiles.</y:description>
  <y:keywords>
<y:keyword>SpanningTrees</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>spanning</y:keyword>
<y:keyword>tree</y:keyword>
<y:keyword>performance</y:keyword>
<y:keyword>Prim</y:keyword>
<y:keyword>Kruskal</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.ShortestPathTest" source="ShortestPathTest.java">
    <y:displayname>Shortest Path Algorithms</y:displayname>
    <y:summary>Compares performance and results of some shortest path algorithms available in yFiles for Java.</y:summary>
    <y:description>


    Compares the performance and results of some shortest path
          algorithms available in yFiles.</y:description>
  <y:keywords>
<y:keyword>ShortestPaths</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>shortest</y:keyword>
<y:keyword>path</y:keyword>
<y:keyword>performance</y:keyword>
<y:keyword>Dijkstra</y:keyword>
<y:keyword>Bellman</y:keyword>
<y:keyword>Ford</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.ShortestPathDemo" source="ShortestPathDemo.java">
    <y:displayname>Shortest Path</y:displayname>
    <y:summary>Demonstrates how to use a Shortest Path Algorithm.</y:summary>
    <y:description>


    Demonstrates how to use a Shortest Path Algorithm.</y:description>
  <y:keywords>
<y:keyword>ShortestPaths</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>shortest</y:keyword>
<y:keyword>path</y:keyword>
<y:keyword>weight</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.TopologicalTest" source="TopologicalTest.java">
    <y:displayname>Topological Sort Algorithms</y:displayname>
    <y:summary>Compares different methods that calculate a topological node ordering on the nodes of an acyclic graph.</y:summary>
    <y:description>


    Compares different methods that calculate a topological
          node ordering on the nodes of an acyclic graph.</y:description>
  <y:keywords>
<y:keyword>NodeOrders</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>performance</y:keyword>
<y:keyword>topological</y:keyword>
<y:keyword>DFS</y:keyword>
<y:keyword>completion</y:keyword>
<y:keyword>node</y:keyword>
<y:keyword>ordering</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.algo.TopologicalSortDemo" source="TopologicalSortDemo.java">
    <y:displayname>Topological Sort</y:displayname>
    <y:summary>Demonstrates how to implement a topological sort algorithm using depth-first search.</y:summary>
    <y:description>


    Demonstrates how to implement a topological sort algorithm
          by using the generic depth-first search class y.algo.Dfs.</y:description>
  <y:keywords>
<y:keyword>Dfs</y:keyword>
<y:keyword>algorithm</y:keyword>
<y:keyword>topological</y:keyword>
<y:keyword>sorting</y:keyword>
<y:keyword>depth</y:keyword>
<y:keyword>acyclic</y:keyword>
</y:keywords>
</y:demo>

</y:package>
    <y:package javaname="demo.base">
  <y:displayname>Graph Structure Demos</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:summary>Contains demos that present base classes of yFiles for Java</y:summary>
  <y:description>
    <h1>yFiles Tutorial Base Demos</h1>

    <p>The following tutorial base demos are in this package:</p>
  </y:description>
  <y:keywords>
    <y:keyword>Basic Graph Demos</y:keyword>
    <y:keyword>Base Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.base.ListDemo" source="ListDemo.java">
    <y:displayname>YList</y:displayname>
    <y:summary>Shows how to use the linked list data type YList provided by yFiles for Java.</y:summary>
    <y:description>
      Demonstrates how to use the yFiles linked list data type y.base.YList.
    </y:description>
    <y:keywords>
      <y:keyword>YCursor</y:keyword>
      <y:keyword>YList</y:keyword>
      <y:keyword>linked</y:keyword>
      <y:keyword>list</y:keyword>
      <y:keyword>cursor</y:keyword>
      <y:keyword>iteration</y:keyword>
      <y:keyword>ListCell</y:keyword>
      <y:keyword>sort</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.GraphDemo" source="GraphDemo.java">
    <y:displayname>Graph</y:displayname>
    <y:summary>Shows how to use the directed graph data type Graph provided by yFiles for Java.</y:summary>
    <y:description>
      Demonstrates how to use the yFiles directed graph data type y.base.Graph.
    </y:description>
    <y:keywords>
      <y:keyword>Graph</y:keyword>
      <y:keyword>directed</y:keyword>
      <y:keyword>additional</y:keyword>
      <y:keyword>data</y:keyword>
      <y:keyword>NodeMap</y:keyword>
      <y:keyword>EdgeMap</y:keyword>
      <y:keyword>NodeCursor</y:keyword>
      <y:keyword>EdgeCursor</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.NodeMapTest" source="NodeMapTest.java">
    <y:displayname>Node Maps</y:displayname>
    <y:summary>Presents mechanisms to bind data to the nodes of a graph.</y:summary>
    <y:description>
      Demonstrates how to use node maps. The demo compares the performance of different
      mechanisms to bind extra data to the nodes of a graph.
    </y:description>
    <y:keywords>
      <y:keyword>NodeMap</y:keyword>
      <y:keyword>additional</y:keyword>
      <y:keyword>data</y:keyword>
      <y:keyword>HashMap</y:keyword>
      <y:keyword>performance</y:keyword>
      <y:keyword>IndexNodeMap</y:keyword>
      <y:keyword>HashedNodeMap</y:keyword>
      <y:keyword>array</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.ExtendedGraph" source="ExtendedGraph.java">
    <y:displayname>Extended Graph</y:displayname>
    <y:summary>Presents an extended Graph object whose nodes and edges carry additional data.</y:summary>
    <y:description>
      This class represents an extended Graph object whose nodes
      and edges carry additional data.
    </y:description>
    <y:keywords>
      <y:keyword>graph</y:keyword>
      <y:keyword>extending</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>additional</y:keyword>
      <y:keyword>data</y:keyword>
      <y:keyword>bind</y:keyword>
      <y:keyword>NodeMap</y:keyword>
      <y:keyword>EdgeMap</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.base.RandomGraphGenerator" source="RandomGraphGenerator.java">
    <y:displayname>Random Graphs</y:displayname>
    <y:summary>Shows how to create random graphs.</y:summary>
    <y:description>
      Implementation of a random graph generator. The size of the graph and other options
      may be specified. These options influence the properties of the created graph.
    </y:description>
    <y:keywords>
      <y:keyword>Graph</y:keyword>
      <y:keyword>random</y:keyword>
      <y:keyword>generate</y:keyword>
      <y:keyword>generation</y:keyword>
      <y:keyword>density</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
    <y:package javaname="demo.io">
  <y:displayname>Graph I/O</y:displayname>
    <y:displaypriority>50</y:displaypriority>
  <y:summary>Contains demos that show how to use, customize, and extend the graph input and output facilities provided by yFiles.</y:summary>
  <y:description>
    <h1>yFiles Tutorial I/O Demos</h1>
    <p>
    The following demos show how to use, customize, and extend
    the graph input and output facilities provided by yFiles.
    </p>
    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="graphml/README.html">demo.io.graphml</a>
        </td>
        <td>
          Contains demos that focus on how to use, customize, and extend
          the GraphML graph interchange format input and output facilities
          provided by yFiles.
        </td>
      </tr>
    </table>
  </y:description>
  <y:keywords>
    <y:keyword>Graph I/O Demos</y:keyword>
    <y:keyword>Graph IO Demos</y:keyword>
    <y:keyword>Demos for I/O</y:keyword>
    <y:keyword>I/O Demos</y:keyword>
    <y:keyword>IO Demos</y:keyword>
  </y:keywords>


  <y:demo javaname="demo.io.GraphFormatConverter" source="GraphFormatConverter.java" executable="false">
    <y:displayname>GraphFormatConverter</y:displayname>
    <y:description>
This class implements a command line driven graph format converter. 
Possible input formats are GraphML, ZIPGraphML, GML, or YGF. Output formats are 
GraphML, ZIPGraphML, GML, YGF, GIF, and JPG. 
Additionally, it is possible to write to the formats PDF, EMF, SWF, EPS, SVG, and 
SVGZ in case the corresponding yFiles extension packages ySVG and yExport are installed. 
The size of some output formats can be specified.
    </y:description>
  <y:keywords>
<y:keyword>converter</y:keyword>
<y:keyword>YGF</y:keyword>
<y:keyword>GML</y:keyword>
<y:keyword>ySVG</y:keyword>
<y:keyword>SVG</y:keyword>
<y:keyword>SVGZ</y:keyword>
<y:keyword>GraphML</y:keyword>
<y:keyword>Zip</y:keyword>
<y:keyword>GIF</y:keyword>
<y:keyword>JPG</y:keyword>
<y:keyword>yExport</y:keyword>
<y:keyword>EMF</y:keyword>
<y:keyword>SWF</y:keyword>
<y:keyword>PDF</y:keyword>
<y:keyword>EPS</y:keyword>
<y:keyword>IOHandler</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.io.ImageMapDemo" source="ImageMapDemo.java" browser="displayOnly">
    <y:displayname>Image Map Export</y:displayname>
    <y:summary>Shows how to export a graph as an image and as a hyperlinked HTML image map.</y:summary>
    <y:description>This class shows how to generate an image and a hyperlinked
HTML image map of a graph.
</y:description>
  <y:keywords>
<y:keyword>ImageMapOutputHandler</y:keyword>
<y:keyword>HTML</y:keyword>
<y:keyword>image</y:keyword>
<y:keyword>map</y:keyword>
<y:keyword>hyperlink</y:keyword>
<y:keyword>static</y:keyword>
<y:keyword>image</y:keyword>
<y:keyword>LinkMap</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.io.TiledImageDemo" source="TiledImageDemo.java" browser="displayOnly">
    <y:displayname>Tiled Image Export</y:displayname>
    <y:summary>Shows how to export a graph as a collection of multiple image tiles.</y:summary>
    <y:description>
This class shows how to export a diagram to multiple image tiles. 
Also, this demo shows how to add a title to the exported diagram.
</y:description>
  <y:keywords>
<y:keyword>TiledImageOutputHandler</y:keyword>
<y:keyword>image</y:keyword>
<y:keyword>tiling</y:keyword>
<y:keyword>tile</y:keyword>
<y:keyword>title</y:keyword>
<y:keyword>header</y:keyword>
<y:keyword>HTML</y:keyword>
<y:keyword>Drawable</y:keyword>
<y:keyword>header</y:keyword>
</y:keywords>
</y:demo>
<y:package javaname="demo.io.graphml">
  <y:displayname>GraphML</y:displayname>
  <y:summary>A collection of demos that show how to use, customize, and extend the GraphML input and output facilities provided by yFiles.</y:summary>
  <y:description>
    <h1>GraphML I/O Demos</h1>
    <p>
      The following demos show how to use, customize, and extend
      the GraphML input and output facilities provided by yFiles.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph I/O Demos</y:keyword>
    <y:keyword>Graph IO Demos</y:keyword>
    <y:keyword>Demos for I/O</y:keyword>
    <y:keyword>I/O Demos</y:keyword>
    <y:keyword>IO Demos</y:keyword>
    <y:keyword>Demos for GraphML I/O</y:keyword>
    <y:keyword>GraphML I/O Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.io.graphml.GraphMLDemo" source="GraphMLDemo.java">
    <y:displayname>GraphML</y:displayname>
    <y:summary>Shows how to use GraphMLIOHandler to load and save a graph in GraphML file format.</y:summary>
    <y:description>Demonstrates basic usage of GraphMLIOHandler to load and save in the GraphML file format.
    </y:description>
    <y:keywords>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
      <y:keyword>undo</y:keyword>
      <y:keyword>redo</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.GenericNodeRealizerSerializationDemo" source="GenericNodeRealizerSerializationDemo.java">
    <y:displayname>GenericNodeRealizer Serialization</y:displayname>
    <y:summary>Shows how to (de-)serialize customized GenericNodeRealizers.</y:summary>
    <y:description>Demonstrates how to create customized node realizers of type GenericNodeRealizer,
      how to add user data and how to read and write these customized types in GraphML format.
    </y:description>
    <y:keywords>
      <y:keyword>GenericNodeRealizer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.CustomNodeRealizerSerializerDemo" source="CustomNodeRealizerSerializerDemo.java">
    <y:displayname>Custom NodeRealizer Serialization</y:displayname>
    <y:summary>Shows how to write a specific (de-)serializer for GraphMLIOHandler&gt; for a custom NodeRealizer.</y:summary>
    <y:description>
      A simple customization of the basic GraphMLDemo that uses objects of type
      CustomNodeRealizer as the graph's default node realizer.
      To enable encoding and parsing of this node realizer type a specific serializer
      implementation is registered with the GraphMLIOHandler.
    </y:description>
    <y:keywords>
      <y:keyword>NodeRealizer</y:keyword>
      <y:keyword>NodeRealizerSerializer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.CustomNodeRealizer" source="CustomNodeRealizer.java" executable="false">
    <y:displayname>CustomNodeRealizer</y:displayname>
    <y:description>Custom NodeRealizer for use with CustomNodeRealizerSerializerDemo.
    </y:description>
    <y:keywords>
      <y:keyword>NodeRealizer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
      <y:keyword>ShapeNodeRealizer</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.CustomNodeRealizerSerializer" source="CustomNodeRealizerSerializer.java" executable="false">
    <y:displayname>CustomNodeRealizerSerializer</y:displayname>
    <y:description>Custom NodeRealizerSerializer that handles GraphML reading and writing of CustomNodeRealizer.
    </y:description>
    <y:keywords>
      <y:keyword>NodeRealizer</y:keyword>
      <y:keyword>NodeRealizerSerializer</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
      <y:keyword>ShapeNodeRealizerSerializer</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.SimpleAttributesDemo" source="SimpleAttributesDemo.java">
    <y:displayname>Simple Attributes</y:displayname>
    <y:summary>Demonstrates how to configure GraphMLIOHandler to be able to handle simple attributes.</y:summary>
    <y:description>Demonstrates how to configure GraphMLIOHandler to be able to handle extra
      node and edge data of simple type. Additional data for a node or an edge can be edited by
      right-clicking on the corresponding element.
    </y:description>
    <y:keywords>
      <y:keyword>attributes</y:keyword>
      <y:keyword>simple</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.DynamicAttributesDemo" source="DynamicAttributesDemo.java">
    <y:displayname>Dynamic Attributes</y:displayname>
    <y:summary>Demonstrates how to configure GraphMLIOHandler to be able to handle attributes dynamically.</y:summary>
    <y:description>Demonstrates how to configure GraphMLIOHandler to be able to handle attributes dynamically. Input handlers
      for unhandled content are created automatically and the data is saved as DocumentFragments. The data can be serialized
      fully dynamically later on.
      <br/>
      Things to try:
      <ul>
        <li>Load an arbitrary graph that contains custom graphml attributes. Two sample graphs are already provided. Note
          how the text in the lower pane shows what becomes of the data during a load/save round-trip (the demo does not just display the
          text content of the original graphml file).
        </li>
        <li>
          Edit/delete/introduce custom attribute data in the graphml text pane and apply the changes to the graph. This will
          trigger a load/save round-trip.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>attributes</y:keyword>
      <y:keyword>dynamic</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.PostprocessorDemo" source="PostprocessorDemo.java">
    <y:displayname>Postprocessor</y:displayname>
    <y:summary>Shows how to process a parsed graph structure before it gets returned by the GraphML parser.</y:summary>
    <y:description>Demonstrates postprocessing actions that can be specified
      within a GraphML file. These actions allow to process the parsed graph structure
      before it gets returned by the GraphML parser.
    </y:description>
    <y:keywords>
      <y:keyword>YModule</y:keyword>
      <y:keyword>Postprocessor</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.io.graphml.XmlXslDemo" source="XmlXslDemo.java">
    <y:displayname>Xml and Xsl</y:displayname>
    <y:summary>Demonstrates how to use XmlXslIOHandler to read XML content with help of additional style sheets.</y:summary>
    <y:description>
      <p>
        In order to read arbitrary XML content, an additional stylesheet is required that transforms the XML
        into valid GraphML. The demo already provides some stylesheets for Ant build scripts, OWL data and representation
        of the XML tree structure. The <code>sample files</code> combo box contains some predefined combinations.
        <br/>
        Note that the graphml pane is not editable for this demo.
      </p>
      <h3>Third Party Licenses:</h3>
      <p>
        The OWL web ontology that is used in this demo is based on
        <a href="http://owl.semanticweb.org/page/TestCase:WebOnt-miscellaneous-002">WebOnt-miscellaneous-002
        by Michael K. Smith, Chris Welty, and Deborah L. McGuinness</a>
        and licensed under the
        <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported</a>
        license.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>YModule</y:keyword>
      <y:keyword>Postprocessor</y:keyword>
      <y:keyword>GraphML</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>output</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
    </y:package>
    <y:package javaname="demo.layout">
  <y:displayname>Automatic Layout</y:displayname>
  <y:displaypriority>90</y:displaypriority>
  <y:summary>Demos about all aspects of layouting</y:summary>
  <y:description>
    <h1>yFiles Tutorial View Demos for Automatic Layout</h1>

    <p>
      This package and all of its subpackages provide tutorial demos that center around 
      automatic layout, routing and labeling features for diagrams.
    </p>
    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="hierarchic/README.html">demo.layout.hierarchic</a>
        </td>
        <td>Showcases diverse aspects and variants of hierarchical layout.</td>
      </tr>

      <tr>
        <td>
          <a href="organic/README.html">demo.layout.organic</a>
        </td>
        <td>Showcases diverse aspects and variants of organic layout.</td>
      </tr>

      <tr>
        <td>
          <a href="orthogonal/README.html">demo.layout.orthogonal</a>
        </td>
        <td>Showcases diverse aspects and variants of orthogonal layout.</td>
      </tr>

      <tr>
        <td>
          <a href="radial/README.html">demo.layout.radial</a>
        </td>
        <td>Showcases diverse aspects and variants of radial layout.</td>
      </tr>

      <tr>
        <td>
          <a href="tree/README.html">demo.layout.tree</a>
        </td>
        <td>Showcases diverse aspects and variants of tree layout.</td>
      </tr>

      <tr>
        <td>
          <a href="labeling/README.html">demo.layout.labeling</a>
        </td>
        <td>Showcases diverse aspects and variants of automatic labeling.</td>
      </tr>

      <tr>
        <td>
          <a href="router/README.html">demo.layout.router</a>
        </td>
        <td>Showcases diverse aspects of automatic edge routing.</td>
      </tr>

      <tr>
        <td>
          <a href="genealogy/README.html">demo.layout.genealogy</a>
        </td>
        <td>Showcases various aspects of the yFiles layout facilities for
            genealogical data.</td>
      </tr>

      <tr>
        <td>
          <a href="partial/README.html">demo.layout.partial</a>
        </td>
        <td>Showcases diverse aspects and variants of partial layout.</td>
      </tr>

      <tr>
        <td>
          <a href="mixed/README.html">demo.layout.mixed</a>
        </td>
        <td>Showcases how to produce mixed layouts for grouped graphs using
            recursive group layout.</td>
      </tr>


      <tr>
        <td>
          <a href="module/README.html">demo.layout.module</a>
          </td>
        <td>Showcases how to use modules for interactive layout configuration. Also contains the complete source
        code of all layout modules that are part of yFiles.</td>
      </tr>

      <tr>
        <td>
          <a href="withoutview/README.html">demo.layout.withoutview</a>
          </td>
        <td>Showcases how to use the yFiles layout algorithms when the yFiles Viewer distribution is not present.
        </td>
      </tr>
      
    </table>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.LayoutDemo" source="LayoutDemo.java">
    <y:displayname>Automatic Layouts</y:displayname>
    <y:summary>Presents several layout styles provided by yFiles for Java</y:summary>
    <y:shortdescription>
      <p>
        <b>
              <i>yFiles for Java</i>
            </b> comes with a set of algorithms that calculate various <b>graph layouts</b>.
      </p>
        Take a look at the <b>different styles</b> the library offers:
        <ul>
          <li>Hierarchic Layout</li>
          <li>Organic Layout</li>
          <li>Orthogonal Layout</li>
          <li>Tree Layout</li>
          <li>Circular Layout</li>
          <li>Balloon Layout</li>
          <li>Radial Layout</li>
        </ul>
      <p>
        For further exploration of the layouts, you can edit the given graph or even replace it with your own graph.
      </p>
    </y:shortdescription>
    <y:description>
      This demo shows the main layout styles provided by yFiles for Java.
      The user can switch between a video mode and an edit mode using the play/pause button in the lower
      left corner of the screen.

      <h2>Video Mode</h2>
      Different layouts are calculated for the current graph and displayed one after the other. In the upper left corner
      the name of the current layouter appears.

      <h2>Edit Mode</h2>
      The user can interactively change the graph.
      <dl>
        <dt>Add Nodes</dt>
        <dd>Click on the screen to add a new node.</dd>
        <dt>Resize Nodes</dt>
        <dd>Click on a node and then drag the hotspots to resize a node.</dd>
        <dt>Add Edges</dt>
        <dd>Drag from a node to another node to add a new edge.</dd>
        <dt>Remove Nodes and Edges</dt>
        <dd>Click on a node or an edge and remove it by pressing<code>delete</code>.</dd>
        <dt>Undo/Redo Changes</dt>
        <dd>Press the buttons in the toolbar to undo or redo graph changes.</dd>
        <dt>Recalculate Layout</dt>
        <dd>Click on the refresh button aside from the pause button to recalculate the layout for a changed graph.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>OrthogonalLayouter</y:keyword>
      <y:keyword>SmartOrganicLayouter</y:keyword>
      <y:keyword>TreeLayouter</y:keyword>
      <y:keyword>BalloonLayouter</y:keyword>
      <y:keyword>CircularLayouter</y:keyword>
      <y:keyword>RadialLayouter</y:keyword>
      <y:keyword>TreeReductionStage</y:keyword>
      <y:keyword>LayoutMorpher</y:keyword>
      <y:keyword>Drawable</y:keyword>
      <y:keyword>Animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.Graph2DLayoutExecutorDemo" source="Graph2DLayoutExecutorDemo.java">
    <y:displayname>Layout Execution</y:displayname>
    <y:summary>Presents different ways to apply an automatic layout to a graph</y:summary>
    <y:description>Demonstrates how Graph2DLayoutExecutor can be used to apply automatic layout
    to a graph that is displayed within a viewer component.
    The demo shows different ways of executing the layout asynchronously and synchronously.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>automatic</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>morphing</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>Thread</y:keyword>
      <y:keyword>threading</y:keyword>
      <y:keyword>blocking</y:keyword>
      <y:keyword>non-blocking</y:keyword>
      <y:keyword>asynchronous</y:keyword>
      <y:keyword>synchronous</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
    </y:keywords>
  </y:demo>

<y:package javaname="demo.layout.component">
  <y:displayname>Component</y:displayname>
  <y:displaypriority>50</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase various aspects of the yFiles component layout facilities.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Component Layout</h1>
    <p>
      This package contains tutorial source code demos that showcase
      various aspects of the yFiles layout facilities for component arrangement.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Component Layout</y:keyword>
    <y:keyword>Component Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.component.ComponentLayouterDemo" source="ComponentLayouterDemo.java">
    <y:displayname>ComponentLayouterDemo</y:displayname>
    <y:summary>
      The ComponentLayouter arranges the connected components of a graph. This demo shows how the components can be
      arranged using different arrangement styles. The demo uses the size of the view as the preferred layout size.
    </y:summary>
    <y:description>
      The ComponentLayouter arranges the connected components of a graph. This demo shows how the components can be
      arranged using different arrangement styles. The demo uses the size of the view as the preferred layout size.
      <h3>Usage:</h3>
      Create a graph with different components or load one of the sample graphs. Choose an arrangement style and specify
      the spacing between the components. Change the graph by adding or removing nodes and edges and press "Layout" to
      rearranges the components.
      <h3>Available Styles</h3>
      <dl>
        <dt>Multiple Rows</dt>
        <dd>
          Tries to place components in multiple rows so that the overall aspect ratio of all components gets as close to
          the aspect ratio of the preferred layout size as possible.
        </dd>

        <dt>Single Row</dt>
        <dd>
          Places components next to each other in a single row.
        </dd>

        <dt>Single Column</dt>
        <dd>
          Places components above each other in a single column.
        </dd>

        <dt>Packed Rectangle</dt>
        <dd>
          Tries to place components like in a rectangular cloud around the biggest component.
        </dd>

        <dt>Compact Rectangle</dt>
        <dd>
          Similar to <i>Packed Rectangle</i> but components might even be placed in empty spaces inside other components.
        </dd>

        <dt>Packed Circle</dt>
        <dd>
          Tries to place components like in a cloud around the biggest component.
        </dd>

        <dt>Compact Circle</dt>
        <dd>
          Similar to <i>Packed Circle</i> but components might even be placed in empty spaces inside other components.
        </dd>

        <dt>Nested Rows</dt>
        <dd>
          Places components in multiple rows. In contrast to <i>Multiple Rows</i>, each row may also be divided into
          further sub-rows, thus especially being advantageous, if there are few very large components and many
          significantly smaller ones. The strategy tries to arrange the components such that the aspect ratio of the final
          component placement gets as close as possible to the aspect ratio of the preferred layout size.
        </dd>

        <dt>Compact Nested Rows</dt>
        <dd>
          Similar to <i>Nested Rows</i> but this strategy tries not always to come as close to the preferred view ratio,
          if not necessary, i.e. if a ratio close to the preferred ratio only induces a lot of unused view space. This
          unused space will be minimized.
        </dd>

        <dt>Width Constrained Nested Rows</dt>
        <dd>
          It uses the same core strategy as <i>Nested Rows</i>, but under the restriction that the resulting width does
          not exceed the preferred width.
        </dd>

        <dt>Height Constrained Nested Rows</dt>
        <dd>
          It uses the same core strategy as <i>Nested Rows</i>, but under the restriction that the resulting height does
          not exceed the preferred width.
        </dd>

        <dt>Width Constrained Compact Nested Rows</dt>
        <dd>
          Similar to <i>Width Constrained Nested Rows</i> but the result will be compacted, in order to minimize unused
          view space induced by components that are large in height.
        </dd>

        <dt>Height Constrained Compact Nested Rows</dt>
        <dd>
          Similar to <i>Height Constrained Nested Rows</i> but the result will be compacted, in order to minimize unused
          view space induced by components that are large in width.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>ComponentLayouter</y:keyword>
      <y:keyword>component</y:keyword>
      <y:keyword>arrangement styles</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.genealogy">
  <y:displayname>Genealogy</y:displayname>
  <y:displaypriority>50</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase various aspects of the yFiles layout facilities for genealogical data.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Genealogical Layout</h1>
    <p>
      This package contains tutorial source code demos that showcase
      various aspects of the yFiles layout facilities for genealogical data.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Genealogical Layout</y:keyword>
    <y:keyword>Genealogical Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.genealogy.FamilyTreeDemo" source="FamilyTreeDemo.java">
    <y:displayname>Family Trees</y:displayname>
    <y:summary>Shows how to load and layout a family tree.</y:summary>
    <y:description>
      <p>
      This Demo shows how to use the FamilyTreeLayouter.
      </p>
            <p>
      <b>Usage:</b>
      </p>
            <p>
      Load a Gedcom file with "Load..." from the "File" menu. The gedcom file is
      converted on the fly into a graph by the <code>GedcomHandler</code>.
      After loading, the graph will be laid out by the <code>FamilyTreeLayouter</code>.
      <br/>
      NOTE: You will find some sample files in your &lt;yfiles&gt;/src/demo/layout/genealogy/samples folder.
      </p>
            <p>
      To load one of the four sample graphs provided with this demo, select the
      corresponding entry from the "Example Graphs" menu. The samples have
      different sizes and complexities.
      </p>
            <p>
      To re-layout the graph press the "layout" button. An options dialog will open where you can modify
      some basic and advanced settings. Clicking "OK" will calculate a new layout with the new settings.
      </p>
            <p>
      Clicking on a node will collapse the graph to two generations around the clicked node.
      The "Show all" button will expand the graph again.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>family</y:keyword>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>GEDCOM</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>FamilyTreeLayouter</y:keyword>
      <y:keyword>genealogy</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.hierarchic">
  <y:displayname>Hierarchic Layouts</y:displayname>
  <y:displaypriority>100</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase various aspects of the yFiles hierarchical layout facilities.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Hierarchical Layout</h1>
    <p>
    This package contains tutorial source code demos that showcase
    various aspects of the yFiles hierarchical layout facilities.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Hierarchical Layout</y:keyword>
    <y:keyword>Hierarchical Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.hierarchic.IncrementalHierarchicLayouterDemo" source="IncrementalHierarchicLayouterDemo.java">
    <y:displayname>Incremental Hierarchic Layouter</y:displayname>
    <y:summary>Shows how to use IncrementalHierarchicLayouter together with sophisticated customized view modes.</y:summary>
    <y:description>
      This demo shows how to use IncrementalHierarchicLayouter together
      with sophisticated customized view modes. The application will automatically perform
      a new layout whenever the user makes changes to the graph. The layout does not change
      the layer assignment of the nodes. Moreover, the sequence of nodes within each layer
      is preserved.
      <br/>
      The incremental layout aligns the centers of the nodes within a layer. Thus moving a
      node up or down a little bit such that its layer assignment does not change is normally
      immediately reverted by the following incremental layout. Similarly, moving a node
      a little bit to the left or right such that the sequence within its layer does not change
      also gets reverted by the following incremental layout.
      <p>
        Things to try:
      </p>
      <ul>
        <li>
          Create new nodes. The mouse location is used to determine the layer for the new node.
          Nodes created far away from the existing nodes are added to a new bottom layer.
        </li>
        <li>
          Move existing nodes. This is treated like creating new nodes. Additionally the target
          layer for the moved node is visually indicated.
        </li>
        <li>
          Create new edges.
        </li>
        <li>
          Move the first/last bend of an edge. This creates a port constraint (PC) which is
          visually indicated.
        </li>
        <li>
          Select a node and choose "Optimize Node". This triggers a layout which tries
          to improve the layout by ignoring the current layer assignment and sequence
          information for the selected node.
        </li>
        <li>
          The context menu for a set of selected nodes provides actions for fixing the layer
          or sequence coordinates of the selected nodes. Fixing the layer coordinates of at least
          two nodes within a layer means that they can be moved such that their centers are at
          different y coordinates and that the next incremental layout will preserve the difference
          of the y coordinates. Similarly, fixing the sequence coordinates of at least two nodes
          within a layer allows to control their distances in the direction of the x axis. Fixing
          the coordinates means fixing layer coordinates as well as sequence coordinates.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>automatic</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>layering</y:keyword>
      <y:keyword>sequence</y:keyword>
      <y:keyword>Drawable</y:keyword>
      <y:keyword>BridgeCalculator</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>MoveSelectionMode</y:keyword>
      <y:keyword>PopupMode</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>HotSpotMode</y:keyword>
      <y:keyword>cut</y:keyword>
      <y:keyword>copy</y:keyword>
      <y:keyword>paste</y:keyword>
      <y:keyword>CopyFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SwimlaneGroupDemo" source="SwimlaneGroupDemo.java">
    <y:displayname>Swimlanes and Groups</y:displayname>
    <y:summary>Shows the effect of combining IncrementalHierarchicLayouter's support for grouping and swim lanes.</y:summary>
    <y:description>
      <p>
        This demo shows the effect of combining
        <code>IncrementalHierarchicLayouter</code>'s support for grouping and
        swim lanes.
      </p>
      <p>
        <b>Things to try:</b>
      </p>
      <ul>
        <li>
          Drag a node or set of nodes into another swim lane.
          This will automatically trigger an incremental layout calculation.
        </li>
        <li>
          Create a new node. It will be assigned to either a new swim lane if
          created to the left or right of the existing lanes or to the lane in
          which the node's center lies.
          This will automatically trigger an incremental layout calculation.
        </li>
        <li>
          Open/close folder/group nodes. Upon closing a group node, the resulting
          folder node will be assigned to the minimum swim lane of the group's
          child nodes.
          This will automatically trigger an incremental layout calculation.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>swimlane</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>collapse</y:keyword>
      <y:keyword>expand</y:keyword>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>TableGroupNodeRealizer</y:keyword>
      <y:keyword>GenericGroupNodeRealizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.IncrementalHierarchicGroupDemo" source="IncrementalHierarchicGroupDemo.java">
    <y:displayname>Groups</y:displayname>
    <y:summary>Shows how to use IncrementalHierarchicLayouter on nested graphs.</y:summary>
    <y:description>
      This demo shows how IncrementalHierarchicLayouter can be used to fully or incrementally
      layout hierarchically nested graphs. The demo supports automatic relayout after expanding folder nodes,
      collapsing group nodes. Furthermore it provides toolbar buttons that
      trigger full layout and incremental relayout. A settings dialog for group layout options is provided as well.
      In incremental layout mode all selected elements are added incrementally to the existing layout.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>incremental</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>expand</y:keyword>
      <y:keyword>collapse</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>IncrementalHintsFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.LayerConstraintsDemo" source="LayerConstraintsDemo.java">
    <y:displayname>Layer Constraints</y:displayname>
    <y:summary>Shows how to apply layer constraints when calculating hierarchical layouts.</y:summary>
    <y:description>
      Demo that shows how to apply layer constraints when calculating hierarchical layouts.
      <p>With the buttons on the left side of the GUI,
        various constraints can be set on the currently selected nodes (either absolute
        top/bottom level or relative layering constraints). The "Top-most"/"Bottom-most"
        buttons set absolute layering constraints, whereas the other buttons assign
        relative layering constraints. The top button ("Remove constraints") clears all
        constraints from the currently selected nodes.
      </p>
      <p>
        Additionally, a DataProvider is registered under the key
        <code>ConstraintIncrementalLayerer.EDGE_WEIGHTS_DPKEY</code>, and if a numeric
        edge label is set, that label gets set as
        value for that DataProvider.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>constraint</y:keyword>
      <y:keyword>absolute</y:keyword>
      <y:keyword>relative</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>ConstraintIncrementalLayerer</y:keyword>
      <y:keyword>cut</y:keyword>
      <y:keyword>copy</y:keyword>
      <y:keyword>paste</y:keyword>
      <y:keyword>CopyFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.PortCandidateDemo" source="PortCandidateDemo.java">
    <y:displayname>Port Candidates</y:displayname>
    <y:summary>Shows how to control the connecting points of edges on nodes during automatic layout.</y:summary>
    <y:description>
      This demo shows how port candidate sets can be used with the incremental hierarchic layouter
      to control from what side edges connect to certain node types in the automatic layout process.
      <br/>
      Usage: The template nodes in the list to the left have different port candidate sets. Try changing
      the graph using the templates and note the effect for a new layout.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>port candidate</y:keyword>
      <y:keyword>portcandidateset</y:keyword>
      <y:keyword>chart</y:keyword>
      <y:keyword>DragAndDrop</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SequenceConstraintsDemo" source="SequenceConstraintsDemo.java">
    <y:displayname>Sequence Constraints</y:displayname>
    <y:summary>Shows how to apply sequence constraints when calculating hierarchical layouts.</y:summary>
    <y:description>
      Demonstrates how to apply sequence constraints when calculating hierarchical
      layouts. For hierarchical layouts, a sequence is the in-layer order of nodes,
      e.g. with layout direction from top to bottom, a sequence is the left to
      right order of nodes.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>constraint</y:keyword>
      <y:keyword>absolute</y:keyword>
      <y:keyword>relative</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>sequence</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>order</y:keyword>
      <y:keyword>head</y:keyword>
      <y:keyword>tail</y:keyword>
      <y:keyword>SequenceConstraintFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SimpleSwimlaneLayouterDemo" source="SimpleSwimlaneLayouterDemo.java">
    <y:displayname>Swimlanes</y:displayname>
    <y:summary>Demonstrates the swim lane feature of the IncrementalHierarchicLayouter.</y:summary>
    <y:description>
      <p>
        This simple demo shows how to use the swim lane feature of the
        IncrementalHierarchicLayouter.
      </p>
      <p>
        It can either calculate a new layout or calculate a new layout given the current
        sketch or incrementally layout selected nodes to an already existing graph whose
        layout is read from the current sketch.
      </p>
      <p>
        <b>Things to try:</b>
        <br/>
        Create a graph and assign nodes to layers by editing the label of the nodes.
        Nodes with the same layer will be placed into the same swim lane. Swim lanes
        are sorted from left to right in ascending label order.
        <br/>
        Use the
        <b>Layout</b>
        button to lay it out from scratch.
        Modify the graph (move nodes and or bends), deselect all elements and
        choose
        <b>Layout from Sketch</b>
        to recalculate the layout using the given sketch
        Add some nodes and connect them to the graph, select the newly added nodes
        and choose
        <b>Layout Incrementally</b>
        to incrementally "add" the selected
        elements optimally into the existing graph.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>swimlane</y:keyword>
      <y:keyword>sketch</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.SimpleIncrementalHierarchicLayouterDemo" source="SimpleIncrementalHierarchicLayouterDemo.java">
    <y:displayname>Incremental Hierarchic Layout</y:displayname>
    <y:summary>Shows three variants how to use IncrementalHierarchicLayouter: from scratch, from sketch or incrementally.</y:summary>
    <y:description>
      This simple demo shows how to use the IncrementalHierarchicLayouter
      to either calculate a new layout or calculate a new layout given the current
      sketch or incrementally layout selected nodes to an already existing graph whose
      layout is read from the current sketch.
      <br/>
      <br/>
      Things to try:
      <br/>
      Create a graph and use the
      <b>Layout</b>
      button to lay it out from scratch.
      Modify the graph (move nodes and or bends), deselect all elements and
      choose
      <b>Layout From Sketch</b>
      to recalculate the layout using the given sketch
      Add some nodes and connect them to the graph, select the newly added nodes
      and choose
      <b>Layout Incrementally</b>
      to incrementally "add" the selected
      elements optimally into the existing graph.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>incremental</y:keyword>
      <y:keyword>sketch</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.HierarchicLayouterDemo" source="HierarchicLayouterDemo.java">
    <y:displayname>Hierarchic Layout</y:displayname>
    <y:summary>Demonstrates various aspects of the HierarchicLayouter.</y:summary>
    <y:description>
      This Demo shows how HierarchicLayouter can handle port constraints,
      how it can take edge labels into consideration when laying out
      a graph and how to specify groups of nodes, which will be placed next to
      each other on each layer.
      <br/>
      <br/>
      <b>Usage:</b>
      <br/>
      After starting the demo create a graph manually in the graph editor
      pane. Now click on the "Layout" Button in the toolbar to
      start the hierarchic layouter.
      <br/>
      Additional port constraints can be specified for HierarchicLayouter.
      A port constraint expresses on what side of a node the source and/or
      target point of an edge should connect. To add a port constraint to an edge
      first select the edge by clicking on it. Then choose the desired source and target
      port constraint for the selected edge with the radio button panel on the left of
      the graph pane. Selecting "South" from the "Source Port" choice for example
      means the edge selected edge should connect to the bottom side of the source node.
      Alternatively once can simply move or create the first or last bend of an edge.
      A visual clue will appear that determines the PortConstraint.
      <br/>
      A port constraint that is marked as "strong", means that the associated
      port coordinate given to the layouter will not be modified by the layouter.
      <br/>
      After the port constraints have been set up it is time to press the
      "layout" button again. Now the resulting layout is a hierarchic layout
      that obeys the additional port constraints.
      <br/>
      To activate the edge labeling feature check the box named "Label Edges" just below
      the port constraint selector pane.
      If this feature is turned on then on there will be edge labels visible that
      display the type of port constraint activated for the source and target port
      of each edge. Now by pressing the "Layout" button again the resulting layout
      will consider these edge labels as well. One can see that none of the labels
      overlap and that the size of the layout has increased.
      <br/>
      The toolbar button "Option..." allows to specify diverse layout parameters
      for the layouter. Not all of these options are important to this demo.
      Noteworthy options for this demo are "Edge Routing: Orthogonal" and in tab
      "Node Rank" the ranking policy "From Sketch".
      <br/>
      "Edge Routing: Orthogonal" has the effect of routing all edges orthogonally,
      i.e. by using only horizontal and vertical line segments.
      <br/>
      "Ranking Policy: From Sketch" has the effect that the layer partitions will be
      established by the given drawing heuristically (looking at the y-coordinates
      of the nodes). By this option it is possible to put nodes in the same layer that
      are connected by an edge.
      <br/>
      <br/>
      Node Groups:
      By clicking on one of the colored buttons in the left bar, the currently selected
      nodes will be assigned to the corresponding group. This grouping will be
      indicated by the node color. When being layouted, nodes on the same layer
      having the same group (color) will be placed next to each other as a compound
      group.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
      <y:keyword>port</y:keyword>
      <y:keyword>constraint</y:keyword>
      <y:keyword>strong</y:keyword>
      <y:keyword>integrated</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>labeling</y:keyword>
      <y:keyword>nodegroup</y:keyword>
      <y:keyword>routing</y:keyword>
      <y:keyword>rank</y:keyword>
      <y:keyword>sketch</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>cut</y:keyword>
      <y:keyword>copy</y:keyword>
      <y:keyword>paste</y:keyword>
      <y:keyword>CopyFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.CriticalPathDemo" source="CriticalPathDemo.java">
    <y:displayname>Critical Path</y:displayname>
    <y:summary>Demonstrates how to align the nodes of a critical path such that the interconnecting edges can be routed in a straight, vertical fashion.</y:summary>
    <y:description>
      <p>
        This demo presents the critical edge feature of the hierarchic layouter. The layouter tries to vertically align each node pair
        that is connected by an edge marked as "critical". This feature can be utilized to highlight different edge paths that are relevant for a user.
        The demo allows to manually mark/unmark critical edges by selecting some edges and, then, pressing button "Mark Selected Edges"/"Unmark Selected Edges".
        Critical edges are colored red, common edges are colored black. The current state of selected edges can be toggled by double-clicking.
        Pressing the "Apply Layout" button calculates a new layout of the current graph.
      <br/>
        Pressing button "Mark Longest Path" allows to automatically select all edges that belong to a longest path of the graph.
        If two nodes of the graph are marked as selected, pressing button "Mark Path Between Two Nodes" selects all edges
        of the shortest-path between this nodes.
      </p>
      <h3>Layout Settings</h3>
      <p>
        The demo allows to specify the following layout properties:
      </p>
      <dl>
        <dt>Minimal Layer Distance:</dt>
        <dd>Specifies the minimum distance between two adjacent layers.</dd>
        <dt>Minimal Node Distance:</dt>
        <dd>Specifies the minimum distance between two adjacent nodes.</dd>
        <dt>Use Orthogonal Edge Routes:</dt>
        <dd>Whether or not edges are routed orthogonally. If this option is disabled, edges are routed polyline.</dd>
        <dt>Enable Backloop Routing:</dt>
        <dd>Whether or not reverse edges are routed as backloops, i.e., such that they also leave their source node at the bottom
        and enter their target node at the top.</dd>
        <dt>Enable Edge Straightening:</dt>
        <dd>Whether or not an edge straightening optimization should be applied. This optimization tries to further reduce the number of bends.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
      <y:keyword>shortest</y:keyword>
      <y:keyword>path</y:keyword>
      <y:keyword>undo</y:keyword>
      <y:keyword>redo</y:keyword>
      <y:keyword>critical path</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.hierarchic.CellSpanLayoutDemo" source="CellSpanLayoutDemo.java">
    <y:displayname>Cell Span Layout</y:displayname>
    <y:description>
      <p>
        Demonstrates <code>IncrementalHierarchicLayouter</code>'s support for
        multi-cells in <code>PartitionGrid</code>s.
      </p>
            <p>
        Multi-cells impose less restrictions on node placement than normal cells:
        A node that belongs to a multi-cell may be placed in each of the 
        multi-cell's columns and rows.
      </p>

      <h2>Feature Description</h2>

      <h3>Design Mode</h3>
      <p>
        In this mode, the table structure may be modified (see below), cell spans
        may be defined (see below), and nodes may be assigned to specified cells or
        cell spans. Nodes are assigned to cells or cell spans simply by moving the
        node into the corresponding cell or cell span area.
        <br/>
        Cell spans are translated into multi-cells when switching to Diagram
        Mode (see below).
      </p>
      <dl>
        <dt>Creating Cell Spans</dt>
        <dd>
          Press and hold <code>CTRL</code> while dragging the mouse across the
          table cells that should be combined. The cells combined in this way will
          be assigned a common color. There may be at most ten cell spans.
        </dd>

        <dt>Removing Cell Spans</dt>
        <dd>
          Press and hold <code>CTRL</code> and <code>ALT</code> while dragging the
          mouse across the table cells that should be separated.
        </dd>

        <dt>Creating Nodes</dt>
        <dd>
          Left-click inside the table structure.
        </dd>

        <dt>Adding and Removing Columns and Rows</dt>
        <dd>
          Right-click inside the table structure to open the context menu.
        </dd>
      </dl>

      <h3>Diagram Mode</h3>
      <p>
        Arranges the diagram created in Design Mode with cell spans represented
        by group nodes whose color matches the corresponding cell span.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
      <y:keyword>partition</y:keyword>
      <y:keyword>cell</y:keyword>
      <y:keyword>span</y:keyword>
      <y:keyword>group</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.layout.hierarchic.CellSpanActionFactory" source="CellSpanActionFactory.java" executable="false">
    <y:displayname>CellSpanActionFactory</y:displayname>
    <y:description>
      <p>
        Creates all user actions for the <code>CellSpanLayoutDemo</code>, most
        notably the action for switching from design mode to diagram mode.
        When doing so, a <code>y.view.tabular.TableLayoutConfigurator</code>
        subclass converts colored cell spans into group nodes which in
        turn are interpreted as multi-cells by
        <code>demo.layout.hierarchic.GroupNodeTransformerStage</code>.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
      <y:keyword>partition</y:keyword>
      <y:keyword>cell</y:keyword>
      <y:keyword>span</y:keyword>
      <y:keyword>group</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.layout.hierarchic.GroupNodeTransformerStage" source="GroupNodeTransformerStage.java" executable="false">
    <y:displayname>GroupNodeTransformerStage</y:displayname>
    <y:description>
      <p>
        Interprets group nodes directly contained in a table group node as
        multi-cells for the purpose of placing the other nodes assigned to the
        corresponding partition grid cells.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>hierarchic</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
      <y:keyword>partition</y:keyword>
      <y:keyword>cell</y:keyword>
      <y:keyword>span</y:keyword>
      <y:keyword>group</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.labeling">
  <y:displayname>Labeling</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase automatic node and edge labeling.</y:summary>
  <y:description>
   <h1>yFiles Tutorial Demos for Automatic Labeling</h1>
   <p>
   This package contains tutorial source code demos that showcase automatic node
   and edge labeling.
   </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Labeling</y:keyword>
    <y:keyword>Automatic Labeling Demos</y:keyword>
  </y:keywords>

   <y:demo javaname="demo.layout.labeling.NodeLabelingDemo" source="NodeLabelingDemo.java">
     <y:displayname>Node Labeling</y:displayname>
     <y:summary>Shows how to configure node labels and their label models as well as how to apply the generic node labeling algorithm.</y:summary>
       <y:description>
           <p>
               This demo shows how to configure node labels and the corresponding node label models as well as how to
               apply the generic node labeling algorithm.
           </p>

           <h3>Usage</h3>

           <dl>
             <dt>Adding a new City</dt>
             <dd>
               A new city (node) can be added by left-clicking on the corresponding map location.
             </dd>
             <dt>Editing a Label</dt>
             <dd>
               To change a label text, use <code>Edit Label</code> from the label's context menu.
               Labels can be moved by drag and drop to another valid position.
             </dd>

             <dt>Automatic Label Placement</dt>
             <dd>
               The generic labeling algorithm is applied automatically after changing any of the properties in the side
               bar. To manually apply the generic labeling algorithm click on <code>Place Labels</code> in the tool bar.
             </dd>
           </dl>

           <h3>Properties</h3>

           <dl>
               <dt>Label Model</dt>
               <dd>
                   The label model of the node labels. A label model defines the set of valid positions of
                   labels. Note: since the <code>Free</code> label model allows any position, it usually offers the best
                   results.
               </dd>

               <dt>Label Size</dt>
               <dd>
                   The font size of the text of the labels.
               </dd>
           </dl>

           <h3>Third Party Licenses:</h3>
           <p>
             The USA map that is used as background in this demo is based on
             <a href="http://commons.wikimedia.org/wiki/File:Blank_US_Map.svg">Blank_US_Map.svg by Theshibboleth</a>
             and licensed under the
             <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported</a>
             license.
           </p>
       </y:description>
       <y:keywords>
           <y:keyword>labeling</y:keyword>
           <y:keyword>automatic</y:keyword>
           <y:keyword>algorithm</y:keyword>
           <y:keyword>GreedyMISLabeling</y:keyword>
           <y:keyword>SALabeling</y:keyword>
           <y:keyword>label</y:keyword>
           <y:keyword>node label</y:keyword>
           <y:keyword>model</y:keyword>
           <y:keyword>BackgroundRenderer</y:keyword>
           <y:keyword>background</y:keyword>
           <y:keyword>configuration</y:keyword>
           <y:keyword>OptionHandler</y:keyword>
       </y:keywords>
   </y:demo>
     <y:demo javaname="demo.layout.labeling.EdgeLabelingDemo" source="EdgeLabelingDemo.java">
         <y:displayname>Edge Labeling</y:displayname>
         <y:summary>Shows how to configure edge labels and their label models as well as how to apply the generic edge labeling algorithm.</y:summary>
       <y:description>
         <p>
           This demo shows how to configure edge labels and the corresponding edge label models as well as
           how to apply the generic edge labeling algorithm.
         </p>

         <h3>Usage</h3>

         <dl>
           <dt>Adding a new Label</dt>
           <dd>
             To add a new edge label right-click on an edge and choose item <code>Add Label</code>.
           </dd>

           <dt>Editing a Label</dt>
           <dd>
             To change a label text, use <code>Edit Label</code> from the label's context menu. Labels can be moved by
             drag and drop to another valid position.
           </dd>

           <dt>Automatic Label Placement</dt>
           <dd>
             The generic labeling algorithm is applied automatically after changing any of the properties in the side
             bar. To manually apply the generic labeling algorithm click on <code>Place Labels</code> in the tool bar.
           </dd>
         </dl>

         <h3>Properties</h3>

         <dl>
           <dt>Rotation Angle</dt>
           <dd>
             The rotation angle (in degrees) of the edge labels. If auto rotation is enabled, this angle is added to the
             angle calculated by auto rotation.
           </dd>

           <dt>Auto Flipping</dt>
           <dd>
             If enabled, automatically flips the presentation of a label when it is upside-down.
           </dd>

           <dt>Label Model</dt>
           <dd>
             The label model of the edge labels. A label model defines the set of valid positions of each label.
           </dd>

           <dt>Auto Rotation</dt>
           <dd>
             If enabled, labels are placed in parallel to their corresponding edge segment. The specified rotation angle
             is added to the angle calculated by this feature.
           </dd>

           <dt>Allow 90 Degree Deviation</dt>
           <dd>
             If enabled, allows additional positions which are rotated by 90 degrees with respect to the positions
             calculated by auto rotation.
           </dd>

           <dt>Edge To Label Distance</dt>
           <dd>
             Specifies the minimum distance between an edge label and the corresponding edge segment.
           </dd>
         </dl>

       </y:description>
       <y:keywords>
             <y:keyword>labeling</y:keyword>
             <y:keyword>automatic</y:keyword>
             <y:keyword>algorithm</y:keyword>
             <y:keyword>GreedyMISLabeling</y:keyword>
             <y:keyword>SALabeling</y:keyword>
             <y:keyword>label</y:keyword>
             <y:keyword>edge label</y:keyword>
             <y:keyword>model</y:keyword>
             <y:keyword>configuration</y:keyword>
             <y:keyword>OptionHandler</y:keyword>
             <y:keyword>ProfitModel</y:keyword>
             <y:keyword>undo</y:keyword>
             <y:keyword>redo</y:keyword>
       </y:keywords>
     </y:demo>
  <y:demo javaname="demo.layout.labeling.PreferredLabelPlacementDemo" source="PreferredLabelPlacementDemo.java">
    <y:displayname>Preferred Placement</y:displayname>
    <y:summary>Demonstrates how to use PreferredPlacementDescriptor of edge labels to specify the label placement of different layouters.</y:summary>
    <y:description>
      <p>
        This demo shows how to configure the <code>PreferredPlacementDescriptor</code>
        of edge labels and how this effects the label placement of different layouters.
      </p>
      <h3>Usage</h3>

      <dl>
        <dt>Adding a new Label</dt>
        <dd>
          To add a new edge label right-click on an edge and choose item<code>Add Label</code>.
        </dd>

        <dt>Editing the Placement Descriptor Settings of a Label</dt>
        <dd>
          Select one or several labels and see how the properties in the side bar are updated to show the common
          settings
          of these labels. Any change of these settings is applied to all selected labels and a new layout is calculated
          to visualize the result of these settings.
        </dd>

        <dt>Automatic Layout Calculation</dt>
        <dd>
          The selected labeling algorithm is applied automatically after changing any of the properties in the side bar.
          To
          manually apply the selected labeling algorithm click on
          <code>Run layout</code>
          in the tool bar.
        </dd>
      </dl>

      <h3>Properties</h3>

      <dl>
        <dt>Placement along the Edge</dt>
        <dd>
          Whether the label should be placed near the source or target node, centered between source and target or
          anywhere.
        </dd>
        <dt>Side of the Edge</dt>
        <dd>
          Whether the label should be placed centered on or left or right beneath the edge.
        </dd>
        <dt>Side Interpretation</dt>
        <dd>
          Determines if 'left' or 'right' of the edge is interpreted relative to the edge flow or using the absolute
          position.
          In the latter case the edge side would be ambiguous for horizontal segments so either the left or the right
          side
          can be put North to the edge.
        </dd>

        <dt>Angle (in degrees)</dt>
        <dd>
          The rotation angle (in degrees) of the edge labels.
        </dd>
        <dt>Angle Reference</dt>
        <dd>
          Whether the rotation angle is relative to the edge slope or absolute.
        </dd>
        <dt>Angle Rotation on Right Side</dt>
        <dd>
          While the rotation angle for labels on the edge and left of the edge is always interpreted clockwise,
          the rotation angle for labels on the right side can either be interpreted Co-rotating with those labels or
          Counter-rotating, that means counter-clockwise.
        </dd>
        <dt>Add 180 degree on Right Side</dt>
        <dd>
          Whether additional 180 degrees should be added to the rotation of labels that are right of the edge.
        </dd>
        <dt>Distance to Edge</dt>
        <dd>
          The distance between the edge and the closest label corner.
        </dd>

      </dl>

      <h3>Label Visualization</h3>
      <p>
        Using the drop down box in the top menu you can choose to either
        'Visualize Label Descriptor' or 'Visualize Label Bounds'.
      </p>
      <dl>
        <dt>Visualize Label Descriptor</dt>
        <dd>
          Different visual amendments are used to visualize the label descriptor
          settings of an edge:

          <ul>
            <li>
              The arrow-shaped background with the color gradient visualizes the
              final label orientation.
            </li>
            <li>
              A blue line with a small arc shows how label is rotated by the set
                angle.
            </li>
            <li>
              A red line with a semi-circle shows when an additional 180 degree
              offset has been added for right-side
              labels.
            </li>
            <li>
              A green line with two filled semi-circles runs between the center
              of the closest label side and its foot of a dropped perpendicular
              on the edge.
            </li>
            <li>
              An orange text shows the set side of the label.
            </li>
          </ul>
        </dd>
        <dt>Visualize Label Bounds</dt>
        <dd>
          Visualizes the oriented rectangular bounds of the label:

          <ul>
            <li>a red circle marks the anchor point</li>
            <li>an orange arrow visualizes the up-vector (scaled by the labels height)</li>
            <li>green and blue double-pointed arrows indicate the width and height</li>
          </ul>
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>labeling</y:keyword>
      <y:keyword>automatic</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GreedyMISLabeling</y:keyword>
      <y:keyword>SALabeling</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>edge label</y:keyword>
      <y:keyword>model</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>OptionHandler</y:keyword>
      <y:keyword>integrated</y:keyword>
      <y:keyword>PreferredPlacementDescriptor</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>TreeReductionStage</y:keyword>
      <y:keyword>OrthogonalLayouter</y:keyword>
    </y:keywords>

  </y:demo>
</y:package>
      <y:package javaname="demo.layout.mixed">
  <y:displayname>Mixed Layouts</y:displayname>
  <y:displaypriority>70</y:displaypriority>
  <y:summary>Contains tutorials that show how to produce mixed layouts for grouped graphs using the recursive group layouter.</y:summary>
  <y:description>
    <h1>yFiles Tutorial for Mixed Layouts</h1>
    <p>
    The following tutorial shows how to produce mixed layouts for grouped graphs using the recursive group layouter.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Mixed Layout</y:keyword>
    <y:keyword>Mixed Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.mixed.MixedLayoutDemo" source="MixedLayoutDemo.java">
    <y:displayname>Mixed Layouts</y:displayname>
    <y:summary>Shows how to use the RecursiveGroupLayouter to apply distinct layout styles to different group nodes.</y:summary>
    <y:description>
      <p>
        Shows how to use the Recursive Group Layouter to apply distinct layout styles to different group nodes.
      </p>

      <h3>Things to do</h3>

      <ul>
        <li>Load an <em>example graph</em>.</li>
        <li>Modify the graph and press the <code>Layout</code> button to run a layout.</li>
        <li>
                <em>Close groups</em> or <em>open folders</em> and see how the layout changes.</li>
        <li>Toggle the <code>From Sketch</code> button to enable/disable the 'From Sketch' mode of the hierarchic
          layout.</li>
      </ul>

      <h3>Table-like Example</h3>

      <p>
        A table-like structure: each group represents a table, the regular nodes represent the table rows, and edges are
        connected to specific rows. The rows are sorted according to their y-coordinate in the initial drawing.
      </p>

      <h3>Three-Tier Example</h3>

      <p>
        Distinct layouts of elements assigned to different tiers. Each group can be assigned to either the left, right
        or middle tier (depending on a group's label). '<code>left</code>' groups are drawn using a TreeLayouter with
        orientation left-to-right. Analogously, '<code>right</code>' groups are drawn using a TreeLayouter with
        orientation right-to-left. Elements not labeled 'left' or 'right' are laid out in the middle using a hierarchic
        layout with orientation left-to-right. Note that groups not labeled 'left' or 'right' are handled
        non-recursively.
      </p>
    </y:description>
    <y:keywords>
        <y:keyword>HierarchyManager</y:keyword>
        <y:keyword>recursive</y:keyword>
        <y:keyword>group</y:keyword>
        <y:keyword>node</y:keyword>
        <y:keyword>nested</y:keyword>
        <y:keyword>grouping</y:keyword>
        <y:keyword>hierarchical</y:keyword>        
        <y:keyword>RecursiveGroupLayouter</y:keyword>
        <y:keyword>TreeReductionStage</y:keyword>
        <y:keyword>PortCandidate</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.layout.mixed.RecursiveLayoutDemo" source="RecursiveLayoutDemo.java">
    <y:displayname>Recursive Layouts</y:displayname>
    <y:summary>Shows how to use the RecursiveGroupLayouter to apply a specified layout style to each group node separately.</y:summary>
    <y:description>
      <p>
        Shows how to use the Recursive Group Layouter to apply a specified layout style to each group node separately.
      </p>

      <h3>Things to do</h3>

      <ul>
        <li>Select a <em>different layout style</em>.</li>
        <li>
                <em>Close groups</em> or <em>open folders</em> and see how the layout changes.</li>
        <li>Modify the graph and press the <code>Layout</code> button to run a layout.</li>
        <li>Toggle the <code>Inter-Edge Routing</code> button. If enabled, an edge router is used for routing the green
          inter-group edges (edges which traverse the boundaries of group nodes). In a recursive layout, the core layout
          often doesn't produce satisfiable edge routes for such edges.
        </li>
      </ul>
    </y:description>
    <y:keywords>
        <y:keyword>HierarchyManager</y:keyword>
        <y:keyword>recursive</y:keyword>
        <y:keyword>group</y:keyword>
        <y:keyword>node</y:keyword>
        <y:keyword>nested</y:keyword>
        <y:keyword>grouping</y:keyword>
        <y:keyword>hierarchical</y:keyword>
        <y:keyword>RecursiveGroupLayouter</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.module">
  <y:displayname>Interactive Layout Configuration</y:displayname>
  <y:summary>The following source code samples demonstrate how to use and write yFiles modules.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Module Demos</h1>
    <p>
      The following source code samples demonstrate how to use and
      write yFiles modules.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Module Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.module.LayoutModuleDemo" source="LayoutModuleDemo.java">
    <y:displayname>Layout Modules</y:displayname>
    <y:summary>Demonstrates how to configure and launch layout and edge routing algorithms interactively using layout modules.</y:summary>
    <y:description>
      Demonstrates how layout modules can be added to the GUI of an application.
      A layout module is a layout algorithm combined
      with an option dialog that allows to change the
      settings of a layout algorithm interactively
      (only available if layout is part of distribution).
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>router</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.DiagonalLayoutModule" source="DiagonalLayoutModule.java" executable="false">
    <y:displayname>DiagonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for the demo
      Layouter
      <a href="../withoutview/DiagonalLayouter.java">DiagonalLayouter</a>
      .
      Additionally, this class can be executed separately. In this case it shows off
      the internationalization and serialization features of the OptionHandler class.
      By launching the module class using a two letter language constant as an
      argument, the dialog will be internationalized in that language if the
      corresponding localized properties file is available. Try either 'en' for
      English or 'de' for German.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>internationalization</y:keyword>
<y:keyword>serialization</y:keyword>
<y:keyword>OptionHandler</y:keyword>
<y:keyword>language</y:keyword>
<y:keyword>DiagonalLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.ComponentLayoutModule" source="ComponentLayoutModule.java" executable="false">
    <y:displayname>ComponentLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for ComponentLayouter. 
      It is similar to ComponentLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>component</y:keyword>
<y:keyword>ComponentLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.FamilyTreeLayoutModule" source="FamilyTreeLayoutModule.java" executable="false">
    <y:displayname>FamilyTreeLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for
      FamilyTreeLayouter.
      It is similar to FamilyTreeLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>FamilyTreeLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.CircularLayoutModule" source="CircularLayoutModule.java" executable="false">
    <y:displayname>CircularLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for CircularLayouter.
      It is similar to CircularLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>CircularLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.HierarchicLayoutModule" source="HierarchicLayoutModule.java" executable="false">
    <y:displayname>HierarchicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for HierarchicLayouter
      and HierarchicGroupLayouter.
      It is similar to HierarchicLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>HierarchicLayouter</y:keyword>
<y:keyword>HierarchicGroupLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.IncrementalHierarchicLayoutModule" source="IncrementalHierarchicLayoutModule.java" executable="false">
    <y:displayname>IncrementalHierarchicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for IncrementalHierarchicLayouter.
      It is similar to IncrementalHierarchicLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.OrganicLayoutModule" source="OrganicLayoutModule.java" executable="false">
    <y:displayname>OrganicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for OrganicLayouter.
      It is similar to OrganicLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrganicLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.SmartOrganicLayoutModule" source="SmartOrganicLayoutModule.java" executable="false">
    <y:displayname>SmartOrganicLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for SmartOrganicLayout.
      It is similar to SmartOrganicLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>SmartOrganicLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.OrthogonalLayoutModule" source="OrthogonalLayoutModule.java" executable="false">
    <y:displayname>OrthogonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for OrthogonalLayouter
      and OrthogonalGroupLayouter respectively.
      It is similar to OrthogonalLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrthogonalLayouter</y:keyword>
<y:keyword>OrthogonalGroupLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.DirectedOrthogonalLayoutModule" source="DirectedOrthogonalLayoutModule.java" executable="false">
    <y:displayname>DirectedOrthogonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for DirectedOrthogonalLayout. 
      It is similar to DirectedOrthogonalLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>DirectedOrthogonalLayouter</y:keyword>
<y:keyword>UML</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.CompactOrthogonalLayoutModule" source="CompactOrthogonalLayoutModule.java" executable="false">
    <y:displayname>CompactOrthogonalLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for CompactOrthogonalLayout. 
      It is similar to CompactOrthogonalLayoutModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>CompactOrthogonalLayouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.TreeLayoutModule" source="TreeLayoutModule.java" executable="false">
    <y:displayname>TreeLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for
      different tree layouts in yFiles.
      It is similar to TreeLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>tree</y:keyword>
<y:keyword>ARTreeLayouter</y:keyword>
<y:keyword>HVTreeLayouter</y:keyword>
<y:keyword>TreeLayouter</y:keyword>
<y:keyword>TreeReductionStage</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.BalloonLayoutModule" source="BalloonLayoutModule.java" executable="false">
    <y:displayname>BalloonLayoutModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for BalloonLayouter.
      It is similar to BalloonLayoutModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>tree</y:keyword>
<y:keyword>BalloonLayouter</y:keyword>
<y:keyword>TreeReductionStage</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.OrthogonalEdgeRouterModule" source="OrthogonalEdgeRouterModule.java" executable="false">

    <y:displayname>OrthogonalEdgeRouterModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for
      OrthogonalEdgeRouter. It is similar to
      OrthogonalEdgeRouterModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>routing</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrthogonalEdgeRouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.module.ChannelEdgeRouterModule" source="ChannelEdgeRouterModule.java" executable="false">
    <y:displayname>ChannelEdgeRouterModule</y:displayname>
    <y:description>
This module represents an interactive configurator and launcher for ChannelEdgeRouter. 
It is similar to ChannelEdgeRouterModule found in the yFiles package y.module.
    </y:description>
    <y:keywords>
<y:keyword>routing</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>ChannelEdgeRouter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.OrganicEdgeRouterModule" source="OrganicEdgeRouterModule.java" executable="false">
    <y:displayname>OrganicEdgeRouterModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for OrganicEdgeRouter. 
      It is similar to OrganicEdgeRouterModule found in the yFiles package y.module.
    </y:description>
  <y:keywords>
<y:keyword>routing</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>OrganicEdgeRouter</y:keyword>
</y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.module.LabelingModule" source="LabelingModule.java" executable="false">
    <y:displayname>LabelingModule</y:displayname>
    <y:description>
      This module represents an interactive configurator and launcher for the yFiles
      labeling algorithms.
      It is similar to LabelingModule found in the yFiles package y.module.
</y:description>
  <y:keywords>
<y:keyword>labeling</y:keyword>
<y:keyword>module</y:keyword>
<y:keyword>configuration</y:keyword>
<y:keyword>options</y:keyword>
<y:keyword>settings</y:keyword>
<y:keyword>GreedyMISLabeling</y:keyword>
<y:keyword>SALabeling</y:keyword>
</y:keywords>
</y:demo>

</y:package>
      <y:package javaname="demo.layout.multipage">
  <y:displayname>Multi-Page Layout</y:displayname>
  <y:summary>Demonstrates how to divide a large model graph into several smaller page graphs.
  </y:summary>
  <y:displaypriority>40</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial for Multi-Page Layout</h1>
    <p>
      Demonstrates how to divide a large model graph into several smaller page graphs.
    </p>
          <p>
    The demo shows how to prepare the model graph for multi-page layout,
    how to configure and how to run the multi-page layout algorithm.
    <br/>
    Additionally, the demo shows how to create displayable
    <code>y.view.Graph2D</code> instances from a
    <code>y.layout.multipage.MultiPageLayout</code> using class
    <code>demo.layout.multipage.MultiPageGraph2DBuilder</code>.
    </p>
          <p>
    Moreover, the demo shows different methods to navigate through the page
    graphs:
    </p>
    <ul>
    <li>
    Clicking on a connector, proxy, or proxy reference node will switch to
    the page graph holding the referenced node.
    </li>
    <li>
    Clicking on a page in the demo's overview component will switch to the
    corresponding page graph.
    </li>
    <li>
    Using the toolbar arrow controls it is possible to navigate sequentially
    through the page graphs.
    </li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Multi-Page Layout</y:keyword>
    <y:keyword>Multi-Page Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.multipage.MultiPageLayoutDemo" source="MultiPageLayoutDemo.java">
    <y:displayname>Multi-Page Layout</y:displayname>
    <y:summary>Demonstrates how to divide a large model graph into several smaller page graphs.
    </y:summary>
    <y:description>
      <h2>How Multi-Page Layout Works</h2>
      <p>
      MultiPageLayouter subdivides a large graph (called model graph) into a set of
      smaller graphs (called page graphs) such that the layout of each page graph
      fits a specified maximum page size.
      To guarantee that no information is lost when distributing the elements
      of the model over several pages, the algorithm introduces three kinds of
      auxiliary nodes.
      </p>
      <h3>Auxiliary Nodes</h3>
      <dl>
      <dt>Connectors</dt>
      <dd>
      <img src="../../view/resource/type_connector.png" alt="Sample Connector Node"/>
      <br/>
      The layout algorithm replaces edges between nodes on different pages by
      so-called connector nodes.
      More precisely, for each edge between two nodes <code>v</code> and
      <code>w</code> that belong to different page graphs, there is a connector node
      attached to <code>v</code> that has the same label as node <code>w</code>.
      Similarly, there is a connector node attached to <code>w</code> that has the
      same label as node <code>v</code>.
      Clicking on a connector node will switch to the page graph that holds the
      related element.
      </dd>
      <dt>Proxies</dt>
      <dd>
      <img src="../../view/resource/type_proxy.png" alt="Sample Proxy Node"/>
      <br/>
      The layout algorithm may also replicate a node as one or more proxy nodes, if
      the original node and its direct neighbors do not fit onto a single page.
      Proxy nodes have the same label as the node they replicate.
      Clicking on a proxy node will switch to the page graph that holds the replicated
      node.
      </dd>
      <dt>Proxy References</dt>
      <dd>
      <img src="../../view/resource/type_proxy_reference.png" alt="Sample Proxy Reference Node"/>
      <br/>
      For each proxy node the layout algorithm creates a so-called proxy reference
      node in the page graph that holds the node which is replicated by the proxy. 
      Proxy reference nodes are labeled with the number of the page graph that
      holds the referenced proxy node.
      Clicking on a proxy reference node will switch to the page graph that holds the
      referenced proxy node.
      </dd>
      </dl>
      <h2>Demo Features</h2>
      <p>
      After calculating a new layout for the given model graph (either a multi-page
      layout or a single-page layout, see <code>Single Page Layout</code> below),
      the first page graph is displayed in the central graph view.
      Using the arrow controls in the toolbar, it is possible to navigate
      through all created page graphs.
      </p>
      <p>
      The overview in the upper left corner displays all pages which are referenced
      from the current page graph.
      Clicking on a page in the overview will switch to the corresponding page graph.
      </p>
      <p>
      Below the overview is a searchable tree that displays (the labels of) the nodes
      in the model graph.
      Double-clicking on an item in the tree will switch to the page graph that holds
      the corresponding node.
      </p>
      <h3>Layout Settings</h3>
      <h3>General</h3>
      <dl>
        <dt>Page Layout</dt>
        <dd>
          Specifies the core layout algorithm that is used to lay out the single
          pages.
        </dd>
        <dt>Single Page Layout</dt>
        <dd>
          If this option is enableds the graph is drawn onto a single page (the
          maximum page size is ignored).
        </dd>
        <dt>Grouping</dt>
        <dd>
          Specifies whether node grouping should
          <br/>
          (a) be ignored,
          <br/>
          (b) include only common nodes, or
          <br/>
          (c) also assign connector nodes to groups.
        </dd>
        <dt>Maximum Width</dt>
        <dd>Specifies the maximum width of a page.</dd>
        <dt>Maximum Height</dt>
        <dd>Specifies the maximum height of a page.</dd>
        <dt>Maximum Duration</dt>
        <dd>
          Specifies the preferred time limit (in seconds) for the layout algorithm.
          Note that restricting the maximum duration may result in a worse layout
          quality. Furthermore, the actual runtime may exceed the maximum duration
          since the layout algorithm still has to find a valid solution.
        </dd>
        <dt>Draw Page</dt>
        <dd>
          If this option is enabled, the specified maximum page size is visualized
          in the background of the current page graph.
        </dd>
      </dl>
      <h3>Connector Representation</h3>
      <p>
      Basically, if there are multiple edges between two nodes lying on different
      pages, a single pair of connector nodes is sufficient, i.e., multiple edges
      are attached to a single connector node. This behavior can be adjusted using
      the following properties:
      </p>
      <dl>
        <dt>Separate Types</dt>
        <dd>
          If this option is enabled, edges of different type are attached to
          different connector nodes. Two edges are of different type if they have
          either different line types, different line colors, or different
          source/target arrows.
        </dd>
        <dt>Separate Direction</dt>
        <dd>
          If this option is enabled, edge with different direction are attached to
          different connector nodes.
        </dd>
        <dt>Separate Multi-edges</dt>
        <dd>
          If this option is enabled, each edge is attached to a separate connector
          node.
        </dd>
      </dl>
      <h3>The File Menu</h3>
      <dl>
        <dt>Load Model Graph</dt>
        <dd>
          Loads a graph and calculates a new multi-page layout for loaded graph.
          The model graph's nodes are displayed in the searchable tree view on the
          left hand side.
        </dd>
        <dt>Save Model Graph</dt>
        <dd>
          Saves the current model graph.
        </dd>
        <dt>Save Page Graph</dt>
        <dd>
          Saves the page graph that is displayed in the central graph view.
        </dd>
      </dl>
      <h3>The Sample Graphs Menu</h3>
      <p>
        Each entry loads an example model graph and calculates a new
        multi-page layout.
      </p>
      <h3>The Sample Settings Menu</h3>
      <p>
        Each entry loads predefined layout settings to be used for the next
        multi-page layout calculation.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>multi-page</y:keyword>
      <y:keyword>Drawable</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.multipage.MultiPageGraph2DBuilder" source="MultiPageGraph2DBuilder.java" executable="false">
    <y:displayname>MultiPageGraph2DBuilder</y:displayname>
    <y:description>
      Builds <code>y.view.Graph2D</code> page graphs from a
      <code>y.layout.multipage.MultiPageLayout</code> instance.
   </y:description>
    <y:keywords>
      <y:keyword>multi-page</y:keyword>
      <y:keyword>builder</y:keyword>
      <y:keyword>GraphCopier</y:keyword>
      <y:keyword>CopyFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.multipage.MultiPageOverview" source="MultiPageOverview.java" executable="false">
    <y:displayname>MultiPageOverview</y:displayname>
    <y:description>
      Overview component that displays all referenced pages for a given page
      graph.
   </y:description>
    <y:keywords>
      <y:keyword>multi-page</y:keyword>
      <y:keyword>overview</y:keyword>
      <y:keyword>LocalViewCreator</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.organic">
  <y:displayname>Organic</y:displayname>
  <y:displaypriority>90</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase various aspects of the yFiles organic layout facilities.
  </y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Organic Layout</h1>
    <p>
    Contains tutorial source code demos that showcase
    various aspects of the yFiles organic layout facilities.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Organic Layout</y:keyword>
    <y:keyword>Organic Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.organic.OrganicLayouterDemo" source="OrganicLayouterDemo.java">
    <y:displayname>Organic Layouts</y:displayname>
    <y:summary>Demonstrates different organic layout algorithms and how to specify individual preferred edge lengths for OrganicLayouter.
    </y:summary>
    <y:description>
      Demonstrates different organic layout algorithms and
      how to specify individual preferred edge lengths
      for OrganicLayouter.
      <br/>
      In this demo the edge lengths can be specified by right clicking
      on an edge or applying the current node distances using the button from the
      toolbar.
      <br/>
      Choose the item "Edit Preferred Edge Length" from the context menu to open up
      a label editor that allows for entering a value for the edge length in pixels.
      Note that the entered value must be numeric. Otherwise
      a default length will be chosen.
    </y:description>
    <y:keywords>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>OrganicLayouter</y:keyword>
      <y:keyword>preferred</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>length</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.organic.NavigationDemo" source="NavigationDemo.java">
    <y:displayname>Graph Navigation</y:displayname>
    <y:summary>Demonstrates how to interactively navigate through a large graph by showing only the surroundings of a focused node.
    </y:summary>
    <y:description>
      Demonstrates how to interactively navigate through a large
      graph by showing only the surroundings of a focused node.
      In this demo the layout of the displayed subgraph is
      controlled by <code>InteractiveOrganicLayouter</code>
    </y:description>
    <y:keywords>
      <y:keyword>InteractiveOrganicLayouter</y:keyword>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.organic.AnimatedNavigationDemo" source="AnimatedNavigationDemo.java">
    <y:displayname>Animated Graph Navigation</y:displayname>
    <y:summary>An animated version of the previous demo.
    </y:summary>
    <y:shortdescription>
      To retrieve detailed information from a large graph one has to focus on smaller parts of the graph.
      <br/>
      Here, users can navigate through the graph of a social network by changing the person of interest. Subsequently,
      only this person and its surroundings become visible while the rest of the network disappears.
      <br/>
      Changes to the visible subgraph are accompanied by animated fade in and fade out effects for appearing and
      disappearing nodes and edges. <code>InteractiveOrganicLayouter</code> dynamically adjusts the layout to every
      change of the displayed subgraph.
    </y:shortdescription>
    <y:description>
      Demonstrates how to interactively navigate through a large
      graph by showing only the surroundings of a focused node.
      In this demo the layout of the displayed subgraph is
      controlled by <code>InteractiveOrganicLayouter</code>

      <h2>Interaction</h2>
      <dl>
        <dt>Left Click on Person</dt>
        <dd>Changes focus to the newly selected person and changes the visible subgraph</dd>
        <dt>Drag on Person</dt>
        <dd>Changes the relative position between nodes and adapts the layout</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>fade</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.organic.InteractiveOrganicDemo" source="InteractiveOrganicDemo.java">
    <y:displayname>Interactive Organic Layout</y:displayname>
    <y:summary>Shows the very basic usage of the InteractiveOrganicLayouter.
    </y:summary>
    <y:description>
      This demo shows the very basic usage of the InteractiveOrganicLayouter.
      The layouter is started within a thread and a swing timer is used to
      update the positions of the nodes.
    </y:description>
    <y:keywords>
      <y:keyword>InteractiveOrganicLayouter</y:keyword>
      <y:keyword>organic</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>thread</y:keyword>
      <y:keyword>timer</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.orthogonal">
  <y:displayname>Orthogonal</y:displayname>
  <y:displaypriority>70</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase various aspects of the yFiles orthogonal layout facilities.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Orthogonal Layout</h1>
    <p>
    This package contains tutorial source code demos that showcase
    various aspects of the yFiles orthogonal layout facilities.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Orthogonal Layout</y:keyword>
    <y:keyword>Orthogonal Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.orthogonal.UMLClassDiagramLayouterDemo" source="UMLClassDiagramLayouterDemo.java">
    <y:displayname>UML Diagram Layout</y:displayname>
    <y:summary>Shows how DirectedOrthogonalLayouter and OrthogonalEdgeRouter can be used to nicely layout UML Class Diagrams in an orthogonal layout style.</y:summary>
    <y:description>
      <p>
        This demo shows how <code>DirectedOrthogonalLayouter</code> and
        <code>OrthogonalEdgeRouter</code> can be used to nicely layout UML
        Class Diagrams in an orthogonal layout style.
      </p>
      <p>
        Usually, there are different kind of relationships between the classes of an UML diagram.
        Some of the relationships are undirected (e.g. associations) while others are directed
        (e.g. generalizations and realizations). This demo arranges a diagram in a way that
        directed relationships point in a main layout direction(here bottom-to-top), while the
        undirected relationships will be arranged without such a direction constraint.
        Furthermore, all directed relationships of the same type sharing a common target node
        will be routed in a bus-like style. For this special task
        OrthogonalEdgeRouter will be used in combination with <code>EdgeGroupRouterStage</code>.
      </p>
      <p>
        The toolbar of this demo offers four additional items:
      </p>
      <ol>
        <li>
          A combobox that selects the type of relationship to be used: association (no arrow),
          generalization (arrow and solid line), and realization (arrow and dashed line).
        </li>
        <li>Layout button - to layout the diagram</li>
        <li>Layout From Sketch button - to layout the diagram, while obeying the layout of the given diagram</li>
        <li>Route Edges button - to route all edges of the diagram, while preserving the coordinates of the nodes</li>
      </ol>
    </y:description>
    <y:keywords>
      <y:keyword>UML</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>class</y:keyword>
      <y:keyword>diagram</y:keyword>
      <y:keyword>sketch</y:keyword>
      <y:keyword>directed</y:keyword>
      <y:keyword>orthogonal</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>router</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.partial">
  <y:displayname>Partial Layout Demos</y:displayname>
  <y:displaypriority>15</y:displaypriority>
  <y:summary>PartialLayouter for various use case scenarios</y:summary>
  <y:description>

  <h1>yFiles Tutorial Demos for Partial Layout</h1>
  <p>
    This package contains tutorial source code demos that shows the usage of <code>PartialLayouter</code> in various
    use case scenarios. This layout algorithm changes the coordinates of a given set of graph elements (called
    <i>partial</i> elements) and leaves the location and size of all other elements (called <i>fixed</i> elements)
    unchanged. The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
    elements) has a good quality with respect to common graph drawing aesthetics.
  </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Partial Layout</y:keyword>
    <y:keyword>Partial Layout Demos</y:keyword>
  </y:keywords>

    <y:demo javaname="demo.layout.partial.HierarchicPartialLayoutDemo" source="HierarchicPartialLayoutDemo.java">
        <y:displayname>Hierarchic Partial Layout</y:displayname>
        <y:summary>Partial Layouter for hierarchic layout</y:summary>
        <y:description>
          <p>
            Shows how to apply <code>PartialLayouter</code> to hierarchic layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>
            
            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Components" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.
            </dd>
            
            <dt>Edge Routing Style</dt>
            <dd>
              Specifies the edge routing strategy that is used for routing partial edges and edges between
              different subgraph components (so-called inter-edges).<br/>
              "Automatic" specifies that the algorithm should automatically choose a suitable routing strategy.
            </dd>
            
            <dt>Consider Hierarchy</dt>
            <dd>
              Specifies that the algorithm should place partial nodes (subgraph components) in a hierarchic
              manner, i.e., such that each predecessor of a node v is placed above v and each successor below v.
            </dd>
            
            <dt>Hierarchy Reorganization</dt>
            <dd>
              Specifies whether or not a postprocessing step should be applied to reduce the number of edges that
              do not comply with the hierarchy, i.e., edges whose target is placed in the same layer or above the 
              layer of the source.
            </dd>
            
            <dt>Allow Mirroring</dt>
            <dd>
              Allows mirroring of subgraph components to improve the layout quality.
            </dd>
            
            <dt>Minimal Layer Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent layers.
            </dd>
            
            <dt>Minimal Node Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes.
            </dd>

            <dt>Layout Orientation</dt>
            <dd>
              Specifies the layout orientation. "Auto" specifies that the orientation should be determined
              automatically.
            </dd>
          </dl>
          
          <h3>Additional Features</h3>
          
          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates 
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>hierarchic</y:keyword>
          <y:keyword>hierarchical</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.OrganicPartialLayoutDemo" source="OrganicPartialLayoutDemo.java">
        <y:displayname>Organic Partial Layout</y:displayname>
        <y:summary>Partial Layouter for organic layout</y:summary>
        <y:description>
          <p>
            Shows how to apply <code>PartialLayouter</code> to organic layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>

            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Components" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.
            </dd>

            <dt>Placement Strategy</dt>
            <dd>
              Specifies the placement strategy.<br/>
              "Barycenter" specifies that each component should be placed close to the barycenter of its graph
              neighbors. <br/>
              "From Sketch" specifies that each component should be placed close to its original position.
            </dd>

            <dt>Edge Routing Style</dt>
            <dd>
              Specifies the edge routing strategy that is used for routing partial edges and edges between
              different subgraph components (so-called inter-edges).<br/>
              "Automatic" specifies that the algorithm should automatically choose a suitable routing strategy.
            </dd>

            <dt>Snapping</dt>
            <dd>
              If enabled, the algorithm tries to align nodes with each other.
            </dd>

            <dt>Allow Mirroring</dt>
            <dd>
              Allows mirroring of subgraph components to improve the layout quality.
            </dd>

            <dt>Minimal Node Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes.
            </dd>
          </dl>

          <h3>Additional Features</h3>

          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>hierarchic</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.OrthogonalPartialLayoutDemo" source="OrthogonalPartialLayoutDemo.java">
        <y:displayname>Orthogonal Partial Layout</y:displayname>
        <y:summary>Partial Layouter for orthogonal layout</y:summary>
        <y:description>
          <p>
            Shows how to apply <code>PartialLayouter</code> to orthogonal layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>

            <dt>Grid Size</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes as well as the grid size.
            </dd>

            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Components" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.<br/>
              "Same Component" specifies that all partial nodes are assigned to the same component.
            </dd>

            <dt>Snapping</dt>
            <dd>
              If enabled, the algorithm tries to align nodes with each other.
            </dd>

            <dt>Use Sketch</dt>
            <dd>
              Specifies that each component should be placed close to its original position.
            </dd>

            <dt>Resize Fixed Groups</dt>
            <dd>
              Specifies that fixed groups may be resized.
            </dd>
          </dl>

          <h3>Additional Features</h3>

          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>orthogonal</y:keyword>
          <y:keyword>partial layout orthogonal</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.CircularPartialLayoutDemo" source="CircularPartialLayoutDemo.java">
        <y:displayname>Circular Partial Layout</y:displayname>
        <y:summary>Partial Layouter for circular layout</y:summary>
        <y:description>
          <p>
            Shows how to apply <code>PartialLayouter</code> to circular layouts.
            This layout algorithm changes the coordinates of a given set of graph elements (called <i>partial</i>
            elements) and leaves the location and size of all other elements (called <i>fixed</i> elements) unchanged.
            The algorithm aims to place the partial elements such that the resulting drawing (including the fixed
            elements) has a good quality with respect to common graph drawing aesthetics.
          </p>
          <p>
            Partial node elements can be assigned to so called subgraph components. During the layout process each
            subgraph induced by the nodes of a component is first laid out
            using the specified subgraph layouter. Then, the different components are placed one-by-one onto the drawing
            area
            such that the number of overlaps among graph elements is small. The user can specify different objectives
            (placement strategies) for finding 'good' positions for subgraph components.
          </p>
          <p>
            The demo allows to specify fixed and partial elements. Fixed elements are drawn grey and partial elements
            orange. To change the
            fixed/partial state of elements, select the corresponding elements and click on the "Lock Selected Elements"
            or "Unlock Selected
            Elements" button. The current state of selected elements can be toggled with a mouse-double-click.
            To start the partial layouter click on the "Apply Partial Layout" button.
          </p>
          <p>
            The demo allows to specify the following properties:
          </p>

          <h3>Available Properties</h3>

          <dl>
            <dt>Subgraph Layout</dt>
            <dd>
              Specifies the layout algorithm that is applied to the subgraph components. "Unchanged" specifies
              that the layout of the components is not changed.
            </dd>

            <dt>Component Assignment</dt>
            <dd>
              Specifies the subgraph components.<br/>
              "Single Nodes" specifies that each partial node is assigned to a separate component.<br/>
              "Connected Graphs" specifies that all partial nodes of a connected component are assigned to the
              same subgraph component.
            </dd>

            <dt>Placement Strategy</dt>
            <dd>
              Specifies the placement strategy.<br/>
              "Barycenter" specifies that each component should be placed close to the barycenter of its graph
              neighbors. <br/>
              "From Sketch" specifies that each component should be placed close to its original position.
            </dd>

            <dt>Edge Routing Style</dt>
            <dd>
              Specifies the edge routing strategy that is used for routing partial edges and edges between
              different subgraph components (so-called inter-edges).<br/>
              "Auto" specifies that the algorithm should automatically choose a suitable routing strategy.
            </dd>

            <dt>Allow Mirroring</dt>
            <dd>
              Allows mirroring of subgraph components to improve the layout quality.
            </dd>

            <dt>Minimal Node Distance</dt>
            <dd>
              Specifies the minimum distance between two adjacent nodes.
            </dd>
          </dl>

          <h3>Additional Features</h3>

          <dl>
            <dt>Duplicate Action</dt>
            <dd>
              Select some nodes and press <code>CTRL + D</code>. This duplicates the selected nodes and integrates
              the new nodes into the graph. The options defined above will be applied to the "new" nodes.
            </dd>

            <dt>Grouping</dt>
            <dd>
              Select some nodes and press <code>CTRL + ALT + G</code>. This inserts a new group node that contains the
              selected elements.
            </dd>
          </dl>
        </y:description>
        <y:keywords>
          <y:keyword>PartialLayouter</y:keyword>
          <y:keyword>layout</y:keyword>
          <y:keyword>algorithm</y:keyword>
          <y:keyword>circular</y:keyword>
          <y:keyword>partial layout</y:keyword>
          <y:keyword>partial layout hierarchic</y:keyword>
        </y:keywords>
    </y:demo>

    <y:demo javaname="demo.layout.partial.PartialLayoutBase" source="PartialLayoutBase.java" executable="false">
      <y:displayname>PartialLayoutBase</y:displayname>
      <y:description>Abstract base class for all <code>PartialLayouter</code> demos.</y:description>
      <y:keywords>
        <y:keyword>PartialLayouter</y:keyword>
        <y:keyword>partial</y:keyword>
        <y:keyword>layout</y:keyword>
      </y:keywords>
    </y:demo>

</y:package>
      <y:package javaname="demo.layout.radial">
  <y:displayname>Radial</y:displayname>
  <y:displaypriority>50</y:displaypriority>
  <y:summary>Contains tutorial source code demos that showcase various aspects of the yFiles layout facilities for radial placements.</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Radial Layout</h1>
    <p>
      This package contains tutorial source code demos that showcase
      various aspects of the yFiles layout facilities for radial placements.
      Radial layouts are best suited for trees and tree-like graph structures
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Radial Layout</y:keyword>
    <y:keyword>Radial Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.radial.RadialLayouterDemo" source="RadialLayouterDemo.java">
    <y:displayname>RadialLayouterDemo</y:displayname>
    <y:summary>
      This Demo shows how to use the RadialLayouter.
    </y:summary>
    <y:description>
      This Demo shows how to use the RadialLayouter.
      <br/>
      <b>Usage:</b>
      <br/>
      On startup a demo graph is loaded and laid out using RadialLayouter with default settings. The circles
      the nodes are placed on are visualized and can be hidden using the "Show Circles" toggle button. "Show Sectors"
      toggles the visibility of the sectors assigned to the nodes.
      <br/>
      Pressing the "Settings..." button opens a layout module for the RadialLayouter that allows to compare the results
      of different layouter settings.
      <br/>
      The graph can be edited and re-laid out by pressing the "Layout" button. Loading a custom graph via the "File"
      menu is possible as well.
      <br/>
      A ComboBox with different EdgeRealizer implementations allows to choose the realizer used to render the edges.
      These realizers mainly differ in how they use the bends as control points or interpolation points. Choosing a
      bigger "Spacing Between Bends" in the "General" section of the settings increases the differences between the
      realizers.
    </y:description>
    <y:keywords>
      <y:keyword>radial</y:keyword>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>circle</y:keyword>
      <y:keyword>sector</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>RadialLayouter</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.router">
  <y:displayname>Edge Routing</y:displayname>
  <y:displaypriority>80</y:displaypriority>
  <y:summary>Shows various aspects of the yFiles edge routing facilities</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Edge Routing</h1>
    <p>
    This package contains tutorial source code demos that showcase
    various aspects of the yFiles edge routing facilities.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Edge Routing</y:keyword>
    <y:keyword>Edge Routing Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.router.EdgeRouterDemo" source="EdgeRouterDemo.java">
    <y:displayname>Orthogonal Edge Routing</y:displayname>
    <y:summary>Demonstrates yFiles' orthogonal edge routing capabilities</y:summary>
    <y:description>
      A demo that shows some of the capabilities of the yFiles Orthogonal Edge Router implementations.
      <br/>
      Usage: Create nodes. Create edges crossing other nodes. The edges will be routed immediately.
      To reroute all edges use the toolbar button "Route Edges".
      <br/>
      The following aspects of using the edge routers are demonstrated.
      <ol>
        <li>How to use OrthogonalEdgeRouterModule, ChannelEdgeRouterModule or PolylineEdgeRouterModule as a convenient
          means to launch and configure the edge routers.
        </li>
        <li>How to modify the yFiles EditMode in order to trigger the orthogonal edge router whenever
          <ul>
            <li>new edges get created</li>
            <li>nodes get resized</li>
            <li>selected nodes will be moved</li>
          </ul>
        </li>
        <li>
          How to specify port constraints for the edge router. With the help of port constraints
          it is possible to tell the orthogonal edge router on which side of a node or on which
          exact coordinate a start or endpoint of an edge should connect to a node.
        </li>
      </ol>
    </y:description>
    <y:keywords>
      <y:keyword>OrthogonalEdgeRouter</y:keyword>
      <y:keyword>ChannelEdgeRouter</y:keyword>
      <y:keyword>PolylineEdgeRouter</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>routing</y:keyword>
      <y:keyword>route</y:keyword>
      <y:keyword>orthogonal</y:keyword>
      <y:keyword>polyline</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>PortAssignmentMoveSelectionMode</y:keyword>
      <y:keyword>MovePortMode</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.layout.router.MazeRouterDemo" source="MazeRouterDemo.java">
    <y:displayname>Maze Routing</y:displayname>
    <y:summary>Demonstrates yFiles' orthogonal edge routing capabilities through a maze</y:summary>
    <y:description>
      Advanced edge routing demo. Demonstrates yFiles' orthogonal edge
      routing capabilities through a maze.
      <br/>
      Usage: Create nodes and edges. The edges will be routed immediately. To reroute
      all edges use the toolbar button "Route Edges".
      <br/>
      The following aspects of using the edge routers are demonstrated.
      <ol>
        <li>How to use OrthogonalEdgeRouterModule, ChannelEdgeRouterModule or PolylineEdgeRouterModule respectively as
          a convenient means to launch and configure the edge routers.
        </li>
        <li>How to modify the yFiles EditMode in order to trigger the
          orthogonal edge router whenever
          <ul>
            <li>new edges get created</li>
            <li>nodes get resized</li>
            <li>selected nodes will be moved</li>
          </ul>
        </li>
      </ol>
      Additionally this demo shows how uneditable background-layer graphs can be displayed
      inside the graph view.
      <br/>
    </y:description>
  <y:keywords>
    <y:keyword>OrthogonalEdgeRouter</y:keyword>
    <y:keyword>ChannelEdgeRouter</y:keyword>
    <y:keyword>PolylineEdgeRouter</y:keyword>
    <y:keyword>edge</y:keyword>
    <y:keyword>routing</y:keyword>
    <y:keyword>route</y:keyword>
    <y:keyword>EditMode</y:keyword>
    <y:keyword>maze</y:keyword>
    <y:keyword>CreateEdgeMode</y:keyword>
    <y:keyword>HotSpotMode</y:keyword>
    <y:keyword>MoveSelectionMode</y:keyword>
    <y:keyword>MovePortMode</y:keyword>
    <y:keyword>Drawable</y:keyword>
  </y:keywords>
</y:demo>
<y:demo javaname="demo.layout.router.BusRouterDemo" source="BusRouterDemo.java">
  <y:displayname>Bus Routing</y:displayname>
  <y:summary>Demonstrates the orthogonal bus-style edge routing capabilities of yFiles</y:summary>
  <y:description>
    <p>
      Shows the capabilities of the yFiles Bus Router and demonstrates specific <em>hub</em>
      nodes to ease the usage in an interactive environment.
    </p>
    <p>
      A bus can be used to display the connections in a complete subgraph, that is a group in which each node has an
      edge to every other node. To disburden users from entering all these edges manually, this application introduces
      a specific type of nodes, so-called<em>hubs</em>, which act as interconnection points of the bus. Each bus is
      composed of its interconnected hubs and all their adjacent edges. For clarity, the hubs and edges of the same bus
      are displayed in a common color.
    </p>

    <h3>Main aspects of this demo</h3>

    <ul>
      <li>
                <code>BusRouterModule</code> which is a convenient means to launch and configure the bus router. Available
        settings include minimum distances from obstacles and whether a grid is enabled or disabled.
      </li>
      <li>Routing of all buses and routing of selected buses only</li>
      <li>Multiple connections of a node to the same bus</li>
      <li>Fixed edges which calculates routes only for <i>free</i> connections.</li>
      <li>The Usage of hub nodes to ease the editing of buses.</li>
      <li>Provided methods to convert hubs into the representation expected by <code>BusRouter</code> and vice versa.
      </li>
    </ul>

    <h3>Usage</h3>

    <dl>
      <dt>Adding new nodes</dt>
      <dd>
        Clicking at the desired location in the view creates a new regular node. Hubs are not created manually, this
        demo creates them automatically where edges meet.
      </dd>

      <dt>Adding new edges</dt>
      <dd>
        An edge is created by dragging the mouse from the (unselected) start node to the target node. By holding the
        Shift key during button press or release, it is possible the start or end an edge at another edge, respectively.
        Subsequently, colors are updated to reflect the changed bus structure and an automatic routing of the new edge
        is done. There is no restriction on the structure of a bus, however, the routing algorithm removes cycles and
        stub paths.
      </dd>

      <dt>Removing nodes and edges</dt>
      <dd>
        Selected nodes and edges can be removed using the <code>DELETE</code> key or the corresponding icon in the tool
        bar. Note that stub paths created by a deletion are removed automatically.
      </dd>

      <dt>Routing buses</dt>
      <dd>
        The routing algorithm and its properties are available in the tool bar. Use <code>Route All</code> to calculate
        a new routing for all buses and <code>Route Selected</code> to route each bus in which at least one edge, one
        hub or one adjacent regular node is selected. Other buses are taken into account by the algorithm for
        calculating the best routes. Note that the algorithm will remove cycles and stub paths.
      </dd>

      <dt>Automatic routing</dt>
      <dd>
        Moving and resizing of nodes triggers an automatic routing of their connections in which the remainders of the
        affected buses are kept fixed. New connections and single-edge buses are routed automatically, too.
      </dd>
    </dl>

    <h3>Settings</h3>

    <dl>
      <dt>Grid</dt>
      <dd>
        Affects both the editor and the routing algorithm. If enabled, a grid of the given spacing is shown in the
        view and the algorithm assigns positions on grid coordinates if possible.
      </dd>

      <dt>Snapping</dt>
      <dd>
        Specifies whether snap lines are activated.
      </dd>
    </dl>
  </y:description>
  <y:keywords>
    <y:keyword>BusRouter</y:keyword>
    <y:keyword>bus</y:keyword>
    <y:keyword>edge</y:keyword>
    <y:keyword>layout</y:keyword>
    <y:keyword>routing</y:keyword>
    <y:keyword>orthogonal</y:keyword>
    <y:keyword>undo</y:keyword>
    <y:keyword>redo</y:keyword>
  </y:keywords>
</y:demo>
  <y:demo javaname="demo.layout.router.OctilinearEdgeRouterDemo" source="OctilinearEdgeRouterDemo.java">
    <y:displayname>Octilinear Edge Routing</y:displayname>
    <y:summary>Demonstrates yFiles' octilinear edge routing capabilities</y:summary>
    <y:description>
      Shows yFiles' octilinear edge routing capabilities. An edge routing algorithm routes edges without
      changing the current node positions. While an orthogonal edge routing algorithm only produces horizontal and
      vertical edge segments, this router also allows octilinear edge segments, i.e., it produces edge routes where the
      slope of each segment is a multiple of 45 degrees. Besides the basic octilinear edge routing capabilities, this
      class also demonstrates the edge grouping feature.
    </y:description>
    <y:keywords>
      <y:keyword>PolylineEdgeRouter</y:keyword>
      <y:keyword>octilinear</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>routing</y:keyword>
      <y:keyword>route</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>MoveSelectionMode</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>HotSpotMode</y:keyword>
      <y:keyword>PopupMode</y:keyword>
      <y:keyword>MovePortMode</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.layout.tree">
  <y:displayname>Tree</y:displayname>
  <y:displaypriority>60</y:displaypriority>
  <y:summary>Demos regarding tree layouts</y:summary>
  <y:description>
    <h1>yFiles Tutorial Demos for Tree Layout</h1>
    <p>
      This package contains tutorial source code demos that showcase
      various aspects of the yFiles tree layout facilities.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Demos for Tree Layout</y:keyword>
    <y:keyword>Tree Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.tree.CollapsibleTreeDemo" source="CollapsibleTreeDemo.java">
    <y:displayname>Collapsible Trees</y:displayname>
    <y:summary>Shows how to interactively collapse and expand subgraphs</y:summary>
    <y:shortdescription>
      In some cases one would like to show and hide parts of a graph to direct attention the attention of the user. <br/>
      Showing and hiding of subgraphs will be demonstrated using the example of a tree graph. It is possible to collapse
      and expand subtrees by clicking on their respective root node.
      <p>
        There are different layouts that can be applied to the example graph. These layouts are able to adjust to local
        changes in the graph structure like they occur when subtrees are expanded or collapsed.
      </p>
    </y:shortdescription>
    <y:description>
      Shows how to interactively collapse and expand subtrees.

      <h2>Mouse Interaction</h2>
      Left click on node collapses/expands the subgraph.

      <h2>Layout</h2>
      Use toolbar buttons to choose one of the following layouts for the example graph:
      <ul>
       <li>
                <code>TreeLayouter</code>
              </li>
       <li>
                <code>BalloonLayouter</code>
              </li>
       <li>
                <code>SmartOrganicLayouter</code>
              </li>
       <li>
                <code>IncrementalHierarchicLayouter</code>
              </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>collapse</y:keyword>
      <y:keyword>expand</y:keyword>
      <y:keyword>subtree</y:keyword>
      <y:keyword>TreeLayouter</y:keyword>
      <y:keyword>BalloonLayouter</y:keyword>
      <y:keyword>OrganicLayouter</y:keyword>
      <y:keyword>HierarchicLayouter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.TreeLayoutConfigurationDemo" source="TreeLayoutConfigurationDemo.java">
    <y:displayname>Tree Layout Styles</y:displayname>
    <y:summary>Serves as a launcher for the tree layout styles offered by TreeLayoutConfiguration</y:summary>
    <y:description>
      Serves as a launcher for the tree layout styles offered by TreeLayoutConfiguration.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>configuration</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.DendrogramLayouterDemo" source="DendrogramLayouterDemo.java">
    <y:displayname>Dendrogram Layouter</y:displayname>
    <y:summary>Shows how to dynamically maintain a tree as a dendrogram</y:summary>
    <y:description>
      <p>
      Shows how to dynamically maintain a tree as a dendrogram, i.e. all subtrees of a single
      local root align at their bottom border. It uses <code>GenericTreeLayouter</code>,
      <code>DendrogramPlacer</code> and <code>CreateChildEdgeMode</code>.
      </p>
      <p>
      <br>Usage:</br> Add new nodes by dragging an edge from the parent node of the new node. In this demo the
      create edge gesture does not need to be completed at a target node. It can end anywhere. The target
      node is created as a child node of the source node for the gesture. The target location of the gesture
      determines the relative position of the new child node among the children of its parent node. Adding
      a node, moving a set of selected nodes or changing their sizes triggers a new layout which restores
      the dendrogram style of the tree.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>dendrogram</y:keyword>
      <y:keyword>DendrogramPlacer</y:keyword>
      <y:keyword>CreateChildEdgeMode</y:keyword>
      <y:keyword>HotSpotMode</y:keyword>
      <y:keyword>PortAssignmentMoveSelectionMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.IncrementalTreeLayouterDemo" source="IncrementalTreeLayouterDemo.java">
    <y:displayname>Incremental Tree Layouter</y:displayname>
    <y:summary>Shows how GenericTreeLayouter can handle port constraints and multiple different NodePlacer instances and implementations</y:summary>
    <y:description>
      <p>
      Shows how GenericTreeLayouter can handle port constraints and multiple
      different NodePlacer instances and implementations at the same time.
      </p>
      <p>
      <b>Usage:</b> Use the panel on the left to change the layout settings such as port constraints
      or node placers for all nodes at a certain level of the tree simultaneously by pressing
      the "Apply" button. The panel in the lower left is a preview for the currently displayed
      settings. You can also change the settings for individual nodes by using their context
      menus.
      <br/>
      On another note, the demo also demonstrates how different ViewModes can be subclassed
      or replaced to achieve a completely different application feel.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>incremental</y:keyword>
      <y:keyword>CreateChildEdgeMode</y:keyword>
      <y:keyword>PopupMode</y:keyword>
      <y:keyword>HotSpotMode</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>PortAssignmentMoveSelectionMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.AssistantPlacerDemo" source="AssistantPlacerDemo.java">
    <y:displayname>Assistant Placer</y:displayname>
    <y:summary>Shows how to use GenericTreeLayouter in conjunction with AssistantPlacer</y:summary>
    <y:description>
      Shows how to use <code>GenericTreeLayouter</code> in conjunction
      with <code>AssistantPlacer</code>.
      <br/>
      Usage: This demo offers its functionality via context menus. The actual selected
      nodes can be marked as assistants or "non-assistants," and the child node
      placer can be set this way, too.
      <br/>
      AssistantPlacer is a special NodePlacer that uses two layout strategies.
      Depending on the boolean provided through the special DataProvider found at
      the key <code>AssistantPlacer#ASSISTANT_DPKEY</code>, the AssistantPlacer
      decides how to layout its children.
      <br/>
      If the boolean is set to true for a specific node, it is interpreted as "assistant."
      All assistants are placed using the <code>LeftRightPlacer.</code>
      <br/>
      The other children are placed below the assistants, using the child node
      placer of the AssistantPlacer. The child node placer can be set using the
      method <code>setChildNodePlacer</code>.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>assistant</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>chart</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>AssistantPlacer</y:keyword>
      <y:keyword>PopupMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.layout.tree.RotatableNodePlacersDemo" source="RotatableNodePlacersDemo.java">
    <y:displayname>Rotatable Node Placers</y:displayname>
    <y:summary>Presents GenericTreeLayouter in conjunction with node placers that support subtree rotation</y:summary>
    <y:description>
      Presents GenericTreeLayouter in conjunction with node placers that support
      subtree rotation. The NodePlacers, rotations and root alignments for the selected nodes may
      be changed using the panel on the left side.
    </y:description>
    <y:keywords>
      <y:keyword>tree</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>algorithm</y:keyword>
      <y:keyword>GenericTreeLayouter</y:keyword>
      <y:keyword>subtree</y:keyword>
      <y:keyword>rotate</y:keyword>
      <y:keyword>rotation</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.layout.withoutview">
  <y:displayname>Layout without yFiles View</y:displayname>
  <y:summary>Demonstration on how to layout without using the view classes</y:summary>
  <y:description>
    <h1>yFiles Tutorial Layout Demos</h1>
    <p>
    The following source code samples demonstrate how to use the yFiles layout 
    algorithms when the yFiles Viewer distribution is not present.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>without view</y:keyword>
    <y:keyword>Graph Layout Demos</y:keyword>
    <y:keyword>Demos for Automatic Layout</y:keyword>
    <y:keyword>Automatic Layout Demos</y:keyword>
    <y:keyword>Layout Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.layout.withoutview.DiagonalLayouter" source="DiagonalLayouter.java" executable="false">
    <y:displayname>Diagonal Layouter</y:displayname>
    <y:summary>Implementation of a custom layouter that arranges the nodes on a diagonal line</y:summary>
    <y:description>Implementation of a custom layouter that arranges the nodes
on a diagonal line. Edges will be routed with exactly one bend.
</y:description>
  <y:keywords>
<y:keyword>diagonal</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>CanonicMultiStageLayouter</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.LayoutWithoutAView" source="LayoutWithoutAView.java">
    <y:displayname>Layout Without A View</y:displayname>
    <y:summary>Shows how to use layout and labeling algorithms without using classes that are only present in the yFiles Viewer distribution</y:summary>
    <y:description>Shows how to use layout and labeling algorithms without using classes 
that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>PortConstraint</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.GroupingLayoutWithoutAView" source="GroupingLayoutWithoutAView.java">
    <y:displayname>Grouping Layout Without A View</y:displayname>
    <y:summary>Shows how to use layout and labeling algorithms using node and edge grouping without yFiles Viewer classes</y:summary>
    <y:description>Similar to <i>LayoutWithoutAView</i>, but demonstrates the use of node
 and edge grouping in combination with the layout algorithms that are capable of
interpreting these sophisticated features. This too can be achieved without the
classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>edge grouping</y:keyword>
<y:keyword>node grouping</y:keyword>
<y:keyword>bus-style</y:keyword>
<y:keyword>routing</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.IncrementalLayoutWithoutAView" source="IncrementalLayoutWithoutAView.java">
    <y:displayname>Incremental Layout Without A View</y:displayname>
    <y:summary>Shows how to use layout and labeling algorithms using incremental layout capabilities without yFiles Viewer classes</y:summary>
    <y:description>Similar to <i>LayoutWithoutAView</i>, but demonstrates the use of the incremental
layout capabilities provided by IncrementalHierarchicLayouter. This too can be achieved without the
classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>PortConstraint</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.SwimlaneLayoutWithoutAView" source="SwimlaneLayoutWithoutAView.java">
    <y:displayname>Swimlane Layout Without A View</y:displayname>
    <y:summary>Shows how to use layout and labeling algorithms using swim lane capabilities without yFiles Viewer classes</y:summary>
    <y:description>Similar to <i>LayoutWithoutAView</i>, but demonstrates the use of the swim lane
layout capabilities of IncrementalHierarchicLayouter. This too can be achieved without the
classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>labeling</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>swimlane</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.PartitionGridLayoutWithoutAView" source="PartitionGridLayoutWithoutAView.java">
    <y:displayname>Partition Grid Layout Without A View</y:displayname>
    <y:summary>Shows how to use layout and labeling algorithms using the partition grid feature without yFiles Viewer classes</y:summary>
    <y:description>   
  This demo shows how to use the partition grid feature of IncrementalHierarchicLayouter
  without using classes that are only present in the yFiles Viewer Distribution.
  In this demo, nodes will be assigned to certain regions of the diagram,
  the so-called cells. The diagram will be arranged using hierarchical layout
  style, while nodes remain within the bounds of their cells.
  <br/>
  This demo displays the calculated coordinates in a simple graph viewer.
  Additionally it outputs the calculated coordinates of the graph layout to
  the console. This too can be achieved without the
  classes that are only present in the yFiles Viewer distribution. 
</y:description>
  <y:keywords>  
<y:keyword>IncrementalHierarchicLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>swimlane</y:keyword>
<y:keyword>partition grid</y:keyword>
<y:keyword>partitioned layout</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.RecursiveGroupLayouterDemo" source="RecursiveGroupLayouterDemo.java">
    <y:displayname>Recursive Group Layouter</y:displayname>
    <y:summary>Shows how to layout the contents of group nodes each with a different layout style</y:summary>
    <y:description>Shows how to layout the contents of group nodes each with a different layout style.
</y:description>
  <y:keywords>
<y:keyword>RecursiveGroupLayouter</y:keyword>
<y:keyword>layout</y:keyword>
<y:keyword>Layout distribution</y:keyword>
<y:keyword>grouping</y:keyword>
<y:keyword>nested</y:keyword>
<y:keyword>group nodes</y:keyword>
<y:keyword>PortConstraint</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.layout.withoutview.IntersectionCalculatorDemo" source="IntersectionCalculatorDemo.java">
    <y:displayname>Intersection Calculator</y:displayname>
    <y:summary>Place edge connection points on visual outline of nodes</y:summary>
    <y:description>
      Demonstrates how to use y.layout.PortCalculator and
      y.layout.IntersectionCalculator to make sure that edge connection
      points lie on the visual outline of nodes.
    </y:description>
    <y:keywords>
      <y:keyword>IntersectionCalculator</y:keyword>
      <y:keyword>ellipse</y:keyword>
      <y:keyword>diamond</y:keyword>
      <y:keyword>shape</y:keyword>
      <y:keyword>intersection</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>border</y:keyword>
    </y:keywords>
  </y:demo>
  <y:demo javaname="demo.layout.withoutview.IntersectionCalculators" source="IntersectionCalculators.java" executable="false">
      <y:displayname>IntersectionCalculators</y:displayname>
    <y:description>
      Provides utilities for calculating intersection points of edges at nodes.
    </y:description>
    <y:keywords>
      <y:keyword>IntersectionCalculator</y:keyword>
      <y:keyword>ellipse</y:keyword>
      <y:keyword>diamond</y:keyword>
      <y:keyword>shape</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
    </y:package>
    <y:package javaname="demo.obfuscation">
  <y:displayname>Deploying yFiles</y:displayname>
  <y:displaypriority>-100</y:displaypriority>
  <y:summary>How to obfuscate yFiles classes</y:summary>
  <y:description>
    <h1>yFiles Obfuscation Demo</h1>

    <p>
      This demo shows how to obfuscate the yFiles classes before they can be
      deployed as a part of an applet or application. Obfuscation changes 
      class, field, and method names in a consistent but nonsensical way that does
      not change the functionality of the software but makes decompiled Java code
      harder to read and publicly available API description of the original code 
      inapplicable to the obfuscated code.
    </p>

    <p>
      In this demo the obfuscation process will be performed by the Ant-based obfuscator yGuard. 
      In order to run yGuard it is required to have the freely available
      deployment tool <a href="http://ant.apache.org">Ant</a> installed on your system.
    </p>

    <p>
      The sample application used in this obfuscation demo is <a href="../view/hierarchy/README.html">
      demo.view.hierarchy.HierarchyDemo</a>.
    </p>

    <p>
      This demo contains the following files:
    </p>
    <table>
      <tr>
        <td>
              <a href="build.xml">build.xml</a>
            </td>
        <td>The Ant build script used to obfuscate the application.</td>
      </tr>
      <tr>
        <td>
              <a href="yguard/README.html">yGuard</a>
            </td>
        <td>The yGuard obfuscation task. The newest yGuard version can be freely obtained from
          the <a href="http://www.yworks.com/products/yguard">yGuard home page</a>.</td>
      </tr>
    </table>

    <h2>Running the Demo</h2>
    <p>
      Open a console window and change to this directory.
      Then enter "<tt>ant run</tt>". This will launch the obfuscated application.
      Before the application will be run it first will be compiled, jarred, 
      and obfuscated.
    </p>
    <p>
      Enter "<tt>ant show</tt>" to open up a small browser that shows the name mapping
      performed by the obfuscator.
    </p>
  </y:description>
</y:package>
    <y:package javaname="demo.option">
  <y:displayname>UI Property Grid</y:displayname>
  <y:summary>Create quickly property editors for items</y:summary>
  <y:description>
    <h1>yFiles Tutorial OptionHandler Demos</h1>
    <p>
    The following source code samples show how to use the features
    of the yFiles y.option package. Package y.option provides means to 
    quickly create property editors for items of diverse types.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>GUI Utility Demos</y:keyword>
    <y:keyword>Demos for OptionHandler</y:keyword>
    <y:keyword>OptionHandler Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.option.NodePropertyEditorDemo" source="NodePropertyEditorDemo.java">
    <y:displayname>Node Property Editor</y:displayname>
    <y:summary>Demonstrates how to create a node property editor for nodes</y:summary>
    <y:description>
      <p>
        Demonstrates how to create a node property editor for nodes.
        This demo makes use of the "value-undefined" state of option items.
      </p>
      <p>
        A node property editor can either be displayed for a single node
        by double-clicking on the node or for multiple nodes by first
        selecting the nodes and then clicking on the "Edit Node Properties"
        toolbar button.
      </p>
      <p>
        The property editor will be initialized by the current settings
        of the selected nodes. If the value of a specific property differs for two
        selected nodes the editor will display the value as undefined.
        Upon closing the editor dialog, only well-defined values will be
        committed to the selected nodes.
      </p>
    </y:description>
  <y:keywords>
<y:keyword>OptionHandler</y:keyword>
<y:keyword>valueUndefined</y:keyword>
<y:keyword>value</y:keyword>
<y:keyword>undefined</y:keyword>
<y:keyword>Selections</y:keyword>
<y:keyword>SelectionStateObserver</y:keyword>
<y:keyword>property</y:keyword>
</y:keywords>
</y:demo>

  <y:demo javaname="demo.option.OptionHandlerDemo" source="OptionHandlerDemo.java">
    <y:displayname>Option Handler</y:displayname>
    <y:summary>Demonstrates how to create an OptionHandler whose values are editable by multiple editor components</y:summary>
    <y:description>
      Demonstrates how to create an OptionHandler whose values are
      editable by multiple editor components. The demo also shows
      how to localize and customize these editors, and how to register listeners
      for <code>PropertyChange</code> events.
      <br/>
      <br/>
      Usage Note:
      <br/>
      Each editor is controlled by a set of buttons and check boxes:
      <ul>
        <li>
          <code>Commit</code>
          <br/>
          As the name implies, clicking this buttons commits the
          displayed values to the corresponding option items.
        </li>
        <li>
          <code>Auto Commit</code>
          <br/>
          If this option is checked, changes to displayed values are
          automatically committed to the corresponding option items, without
          having to click
          <code>Commit</code>
          first.
        </li>
        <li>
          <code>Reset</code>
          <br/>
          The standard option item implementations provided by the
          <code>y.option</code> package all support the notion of a backup value.
          The backup value is (usually) the value with which an option item was
          initialized. The only exception is the <code>y.option.EnumOptionItem</code>,
          which allows users to explicitly set its backup value.
          Clicking this button (re-) sets the displayed values to the
          backup values of the corresponding option items.
        </li>
        <li>
          <code>Adopt</code>
          <br/>
          Clicking this button sets the displayed values to the values currently
          stored in the corresponding option items.
        </li>
        <li>
          <code>Auto Adopt</code>
          <br/>
          If this option is checked, the displayed values will be automatically
          updated on changes to the values of the corresponding option items,
          without having to click
          <code>Adopt</code>
          first.
        </li>
      </ul>
    </y:description>
  <y:keywords>
<y:keyword>OptionHandler</y:keyword>
<y:keyword>l10n</y:keyword>
<y:keyword>i18n</y:keyword>
<y:keyword>localization</y:keyword>
<y:keyword>internationalization</y:keyword>
<y:keyword>locale</y:keyword>
<y:keyword>commit</y:keyword>
<y:keyword>adopt</y:keyword>
<y:keyword>auto</y:keyword>
<y:keyword>OptionItem</y:keyword>
<y:keyword>ItemEditor</y:keyword>
<y:keyword>editor</y:keyword>
<y:keyword>GuiFactory</y:keyword>
<y:keyword>OptionGroup</y:keyword>
<y:keyword>useSection</y:keyword>
</y:keywords>
</y:demo>

</y:package>
    <y:package javaname="demo.view">
  <y:displayname>Graph Visualization</y:displayname>
  <y:displaypriority>100</y:displaypriority>
  <y:summary>Demos regarding yFiles View part </y:summary>
  <y:description>
    <h1>yFiles Tutorial View Demos</h1>

    <p>
      The following tutorial view demos are in this package:
    </p>
    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="realizer/README.html">demo.view.realizer</a>
        </td>
        <td>
          The contained tutorial demos describe how to use, customize, and extend
          diverse NodeRealizer and EdgeRealizer classes.
        </td>
      </tr>

      <tr>
        <td>
          <a href="viewmode/README.html">demo.view.viewmode</a>
        </td>
        <td>
          Shows how to use, customize, and extend diverse ViewMode classes.
          View modes provide the base functionality to handle
          mouse-based interaction that happens in a view.
        </td>
      </tr>

      <tr>
        <td>
          <a href="application/README.html">demo.view.application</a>
        </td>
        <td>
          Shows how to use application features like drag and drop, print previewing,
          clipboard functionality, and undoability.
          Also, local views are presented, swimlane support, and searching in a
          graph.
        </td>
      </tr>

      <tr>
        <td>
          <a href="hierarchy/README.html">demo.view.hierarchy</a>
        </td>
        <td>
          These demos show how to write applications that can manage a hierarchy of
          nested and grouped graphs.
          Predefined actions are used that perform navigational and structural tasks
          on the graph hierarchy.
          Furthermore, creating customized actions is presented as well.
        </td>
      </tr>

      <tr>
        <td>
          <a href="anim/README.html">demo.view.anim</a>
        </td>
        <td>
          Contains demos that center around the diverse animation effects that
          can be applied to graph elements and to graph views.
        </td>
      </tr>

      <tr>
        <td>
          <a href="rendering/README.html">demo.view.rendering</a>
        </td>
        <td>
          Centers around advanced rendering aspects of the graph view.
          It is shown how to use auxiliary rendering classes <code>Drawable</code>,
          <code>BackgroundRenderer</code>, and <code>BridgeCalculator</code>.
        </td>
      </tr>

      <tr>
        <td>
          <a href="advanced/README.html">demo.view.advanced</a>
        </td>
        <td>
          Shows advanced features like using a model graph and having multiple different 
          views on it, or temporarily preventing parts of a graph from being editable.
          <br/>
          Also, contains a demo that employs special nodes with a fixed set of allowed 
          connection points (known as ports).
        </td>
      </tr>

      <tr>
        <td>
              <a href="orgchart/README.html">demo.view.orgchart</a>
            </td>
        <td>
          Extensive demo application that presents an organization chart in a
          visually rich manner.
          <br/>
          Many aspects of yFiles are demonstrated, for example, realizer and view 
          mode customization, or animations. 
          Implementation of the demo's features, like level of detail (LoD) rendering, 
          or synchronization between a business model and the graph structure using 
          yFiles is shown in detail.
        </td>
      </tr>

      <tr>
        <td>
              <a href="networkmonitoring/README.html">demo.view.networkmonitoring</a>
            </td>
        <td>
          Extensive demo application that presents a simple network monitoring
          tool.
          <br/>
          Demonstrates how to visualize state changes in the monitored network
          in an animated fashion.
        </td>
      </tr>

      <tr>
        <td>
              <a href="uml/README.html">demo.view.uml</a>
            </td>
        <td>
          Extensive demo application for creating and editing UML class
          diagrams.
          <br/>
          Demonstrates advanced methods for user interaction through controls
          embedded in node realizers as well as overlay controls that are shown
          when the mouse is moved over an UML node.
        </td>
      </tr>

      <tr>
        <td>
              <a href="isometry/README.html">demo.view.isometry</a>
            </td>
        <td>
          Extensive demo application that displays graphs in an isometric
          fashion to create the impression of a 3-dimensional view.
        </td>
      </tr>

      <tr>
        <td>
              <a href="mindmap/README.html">demo.view.mindmap</a>
            </td>
        <td>
          Extensive demo application that presents a basic, yet powerful mind
          map editor.
          Aside from mind map typical editing features, import from and export
          to FreeMind's native XML format is supported.
          <br/>
          The design follows the suggestions of Tony Buzan, the inventor of
          mind maps.
        </td>
      </tr>

      <tr>
        <td>
              <a href="flowchart/README.html">demo.view.flowchart</a>
            </td>
        <td>
          Simple flowchart editor application that comes with a large set
          of flowchart symbols and a reusable palette component.
        </td>
      </tr>

      <tr>
        <td>
              <a href="entityrelationship/README.html">demo.view.entityrelationship</a>
            </td>
        <td>
          Simple entity relationship editor application that comes with entity
          relationship symbols for both Chen and Crow's Foot notation as well as
          a reusable palette component.
        </td>
      </tr>

      <tr>
        <td>
              <a href="graphexplorer/README.html">demo.view.graphexplorer</a>
            </td>
        <td>
          Demo application that demonstrates a model-view based approach for
          interactive exploration of graphs that are too large to have all
          their elements displayed at once.
        </td>
      </tr>

      <tr>
        <td>
              <a href="applet/README.html">demo.view.applet</a>
            </td>
        <td>
          Features a self-contained demo setup that shows how to deploy yFiles-based applications
          as Java applets inside a web browser.
        </td>
      </tr>
    </table>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.SimpleDemo" source="SimpleDemo.java">
    <y:displayname>Hello World</y:displayname>
    <y:summary>Simple "Hello World" Demo</y:summary>
    <y:description>
      The yFiles view says "Hello World." Shows how to display a graph
      viewer/editor component inside a frame. Try clicking into
      the view to create new nodes, pressing the left mouse button
      over a node and dragging the mouse to another node to create an edge,
      clicking a node to select it.</y:description>
    <y:keywords>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>JFrame</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.BuildGraphDemo" source="BuildGraphDemo.java">
    <y:displayname>Build Styled Graph</y:displayname>
    <y:summary>Shows how to build a Graph2D with different node types and styles</y:summary>
    <y:description>
      Shows how to build a Graph2D with different node types
      and styles applied to its elements. Try adding new nodes and edges with
      the mouse.
    </y:description>
    <y:keywords>
      <y:keyword>Graph2D</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>label</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.ViewActionDemo" source="ViewActionDemo.java">
    <y:displayname>View Actions</y:displayname>
    <y:summary>Demonstrates some actions that can be performed on the view or the contents of the view</y:summary>
    <y:description>
      Demonstrates some actions that can be performed on the view or
	    the contents of the view:
      <ul>
        <li>remove selected parts of the view</li>
        <li>zoom out of the view</li>
        <li>zoom in on the view</li>
        <li>fit view content to the size of the view</li>
        <li>print contents of the view</li>
        <li>load a graph in GraphML format</li>
        <li>save a graph in GraphML format</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>interaction</y:keyword>
      <y:keyword>editing</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>print</y:keyword>
      <y:keyword>actions</y:keyword>
      <y:keyword>load</y:keyword>
      <y:keyword>save</y:keyword>
      <y:keyword>fit content</y:keyword>
    </y:keywords>
  </y:demo>

<y:package javaname="demo.view.advanced">
  <y:displayname>Advanced</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:summary>Using advanced application features</y:summary>
  <y:description>
    <h1>Advanced yFiles Tutorial View Demos</h1>
    <p>
    The following tutorial view demos show how to use advanced application
    features like inactive graph layers, graph models with many views, nodes with fixed ports,
    and edges connecting at other edges.
    </p>

    <table>
      <tr>
        <th>Package</th>
        <th>Description</th>
      </tr>

      <tr>
        <td>
          <a href="ports/README.html">demo.view.advanced.ports</a>
        </td>
        <td>
          Contains demos that focus on yFiles' node ports. These demos
          demonstrate how to use and interact with node ports as well as how to
          customize their visual appearance and how to associate labels to node
          ports.
        </td>
      </tr>
    </table>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>advanced</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.advanced.EdgeConnectorDemo" source="EdgeConnectorDemo.java">
    <y:displayname>Edge Connector</y:displayname>
    <y:summary>Shows how to mimic node-to-edge and edge-to-edge connection</y:summary>
    <y:description>
      <p>
      Shows how to mimic node-to-edge and edge-to-edge connection.
      In this demo an edge that connects to a node or to another edge is
      modeled as a normal edge that has a special node as its end point.
      That special node is located on the path of the edge. When moving
      the edge path the special node will also be moved. Thus, it looks
      and feels like a proper edge connection to an edge.
      </p>
      <p>
      <b>Usage:</b> to create an edge that starts at another edge, shift-press
      on the edge to initiate the edge creation gesture, then drag the mouse.
      To create an edge that ends at another edge, shift-release the mouse on
      the edge.
 	  </p>
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>connection</y:keyword>
      <y:keyword>DefaultGraph2DRenderer</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>MoveSelectionMode</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>MovePortMode</y:keyword>
      <y:keyword>cut</y:keyword>
      <y:keyword>copy</y:keyword>
      <y:keyword>paste</y:keyword>
      <y:keyword>undo</y:keyword>
      <y:keyword>redo</y:keyword>
      <y:keyword>CopyFactory</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.advanced.InactiveLayerDemo" source="InactiveLayerDemo.java">
    <y:displayname>Inactive Layer</y:displayname>
    <y:summary>Demonstrates how to put a part of a graph in an inactive background layer of the view</y:summary>
    <y:description>
      <p>
      Demonstrates how to put a part of a graph in an inactive background
      layer of the view.
      </p>
      <p>
      <b>Usage:</b> when parts of the graph are selected, then a right mouse
      click brings up a menu that offers to put the selected part of the graph
      to the inactive background. If none is selected then a right mouse click
      brings up a popup menu that allows to bring the inactive graph part back
      to life.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>background</y:keyword>
      <y:keyword>layer</y:keyword>
      <y:keyword>inactive</y:keyword>
      <y:keyword>Drawable</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.advanced.ModelViewManagerDemo" source="ModelViewManagerDemo.java">
    <y:displayname>Model View Manager</y:displayname>
    <y:summary>Demonstrates automatic structural synchronization between several graphs using ModelViewManager</y:summary>
    <y:description>
      <p>
      Demonstrates automatic structural synchronization between several graphs
      using y.view.ModelViewManager.
      </p>
      <p>
      The demo shows four different Graph2DViews in a 2-by-2 matrix. The top-left one
      presents the model graph, the latter three ones show derived views of this model
      graph.
      <br/>
      Each of the derived views has special characteristics: for example, the bottom-left
      one does not show any of the edges from the model graph, the bottom-right one
      is empty at first and only shows nodes created interactively by a user.
      Also, in some views the visual representation of the nodes differs from the model
      graph.
      </p>
      <p>
      In all views there can be applied an automatic layout to the contained graph.
      Additionally, the two views at the bottom, which prevent editing of their contained
      graphs, provide a button to synchronize their contents back to the model graph's
      view, which in turn updates the other derived views.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>model</y:keyword>
      <y:keyword>view</y:keyword>
      <y:keyword>satellite</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>relation</y:keyword>
      <y:keyword>synchronization</y:keyword>
      <y:keyword>BackgroundRenderer</y:keyword>
      <y:keyword>GraphListener</y:keyword>
    </y:keywords>
  </y:demo>
<y:package javaname="demo.view.advanced.ports">
  <y:displayname>Ports</y:displayname>
  <y:displaypriority>40</y:displaypriority>
  <y:description>
    <h1>yFiles Tutorial Node Ports Demos</h1>
    <p>
      The following demos demonstrate how to use and interact with node ports
      as well as how to customize their visual appearance and how to associate
      labels to node ports. In addition, it shows how to use node halos to
      avoid node port overlaps.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>advanced</y:keyword>
    <y:keyword>Node Port Demos</y:keyword>
    <y:keyword>Node Ports Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.advanced.ports.NodePortsDemo" source="NodePortsDemo.java">
    <y:displayname>NodePortsDemo</y:displayname>
    <y:summary>
        Demonstrates how to use node ports.
    </y:summary>
    <y:description>
      Demonstrates how to use node ports.
      <h3>Working with node ports</h3>
      <dl>
        <dt>Adding ports to a node</dt>
        <dd>
          Right-click on a node to open the context menu. A port can be added to the
          node by choosing one of the displayed prototypes.
        </dd>

        <dt>Selecting ports</dt>
        <dd>
          A port can be selected by left-clicking on the port.
          If one or more ports are already selected, the selection box can be used
          to select additional ports and pressing <code>CONTROL+A</code> will
          select all ports.
        </dd>

        <dt>Moving ports</dt>
        <dd>
          A port can be moved by first selecting it and then dragging it with the
          mouse.
        </dd>

        <dt>Displaying context menus</dt>
        <dd>
          Context menus for nodes and ports are displayed by right-clicking on the
          corresponding element.
        </dd>

        <dt>Removing ports from a node</dt>
        <dd>
          Selected ports can be removed using the <code>DELETE</code> key, the
          corresponding icon in the tool bar, or the corresponding entry in the
          port context menu.
        </dd>

        <dt>Connecting edges to ports</dt>
        <dd>
          An edge can be connected to a port by dragging the mouse from a port or
          node that is not selected to another port or node that has ports.
        </dd>

        <dt>Adding labels to ports</dt>
        <dd>
          A label can be add to a port by choosing <code>Add Label</code> from the
          port context menu.
        </dd>
      </dl>

      <h3>Miscellaneous</h3>
      <dl>
        <dt>Laying out nodes and edges</dt>
        <dd>
          A new layout for the graph is calculated by pressing the
          <code>Layout Graph</code> button in the tool bar.
          <br/>
          If <code>Group Edges</code> is selected, edges that connect to the same
          port may overlap each other.
          <br/>
          (This feature is not available in the yFiles View distribution.)
        </dd>

        <dt>Routing edges</dt>
        <dd>
          A new layout for the edges of the graph is calculated by pressing the
          <code>Route Edges</code> button in the tool bar. Nodes will not be moved.
          <br/>
          If <code>Group Edges</code> is selected, edges that connect to the same
          port may overlap each other.
          <br/>
          (This feature is not available in the yFiles View distribution.)
        </dd>

        <dt>Grouping nodes</dt>
        <dd>
          Use <code>CONTROL+ALT+G</code> to create a common parent group node for
          selected nodes.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>port</y:keyword>
      <y:keyword>NodeStateChangeEdgeRouter</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>palette</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>PortLocationModel</y:keyword>
      <y:keyword>node halo</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.advanced.ports.LogicGatesDemo" source="LogicGatesDemo.java">
    <y:displayname>LogicGatesDemo</y:displayname>
    <y:description>
    Demonstrates how to create an application that makes use of nodes that have a fixed set of ports.
    The nodes represent logic gates. Edges can only start at the ports located at the right side of nodes.
    These are the outputs of the represented gates. Edges can only end at ports located at the left side
    of the nodes. These are the inputs of the represented gates. Valid ports will be highlighted when
    hovering over a node or when creating an edge. The nodes are realized using GenericNodeRealizers and the
    ports are realized using NodePorts.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>port</y:keyword>
      <y:keyword>fixed</y:keyword>
      <y:keyword>Drawable</y:keyword>
    </y:keywords>
  </y:demo>  
</y:package>
      </y:package>
      <y:package javaname="demo.view.anim">
  <y:displayname>Animations</y:displayname>
  <y:displaypriority>60</y:displaypriority>
  <y:summary>How to animate in yFiles</y:summary>
  <y:description>
    <h1>yFiles Tutorial Animation Demos</h1>
    <p>
      This package contains demos that center around the diverse animation effects that
      can be applied to graph elements and to graph views.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Graph Animation Demos</y:keyword>
    <y:keyword>Animation Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.anim.AnimatedStructuralChangesDemo" source="AnimatedStructuralChangesDemo.java">
    <y:displayname>Animated Structural Changes</y:displayname>
    <y:summary>Demonstrates how to combine animation effects for structural graph changes with animated graph layout changes</y:summary>
    <y:description>
      Demonstrates how to combine animation effects for structural graph changes
      with animated graph layout changes.
    </y:description>
    <y:keywords>
      <y:keyword>animation</y:keyword>
      <y:keyword>structure</y:keyword>
      <y:keyword>change</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>player</y:keyword>
      <y:keyword>morphing</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>fade</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.AnimationEffectsDemo" source="AnimationEffectsDemo.java">
    <y:displayname>Animation Effects</y:displayname>
    <y:summary>Shows various animation effects for graph elements and graph views</y:summary>
    <y:description>
      Shows various animation effects for graph elements and graph views:
      <ul>
        <li>fade in and fade out for nodes and/or edges</li>
        <li>resizing of nodes</li>
        <li>edge traversals</li>
        <li>animated loading and clearing of graph structures</li>
        <li>animated zooming</li>
        <li>animated camera movement</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>fade</y:keyword>
      <y:keyword>fading</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>zooming</y:keyword>
      <y:keyword>camera</y:keyword>
      <y:keyword>movement</y:keyword>
      <y:keyword>resize</y:keyword>
      <y:keyword>morphing</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.LabelAnimationDemo" source="LabelAnimationDemo.java">
    <y:displayname>Label Animations</y:displayname>
    <y:summary>Demonstrates how to animate label movement along an edge</y:summary>
    <y:description>
      Demonstrates how to animate label movement along an edge.
    </y:description>
    <y:keywords>
      <y:keyword>label</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>move</y:keyword>
      <y:keyword>moving</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>path</y:keyword>
      <y:keyword>timer</y:keyword>
      <y:keyword>Drawable</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.EaseInEaseOutDemo" source="EaseInEaseOutDemo.java">
    <y:displayname>Ease In - Ease Out</y:displayname>
    <y:summary>Demonstrates how to apply ease in and ease out effects to animations on
          the basis of animated node movements</y:summary>
    <y:description>
      Demonstrates how to apply ease in and ease out effects to animations on
      the basis of animated node movements.
    </y:description>
    <y:keywords>
      <y:keyword>animation</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>move</y:keyword>
      <y:keyword>moving</y:keyword>
      <y:keyword>ease</y:keyword>
      <y:keyword>timer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.anim.FadeInFadeOutDemo" source="FadeInFadeOutDemo.java">
    <y:displayname>Fade In - Fade Out</y:displayname>
    <y:summary>Demonstrates how to animate node creation and deletion with a
          specialized <code>GraphListener</code>
          </y:summary>
    <y:description>
      Demonstrates how to animate node creation and deletion with a
      specialized <code>GraphListener</code>.
    </y:description>
    <y:keywords>
      <y:keyword>listener</y:keyword>
      <y:keyword>event</y:keyword>
      <y:keyword>fade</y:keyword>
      <y:keyword>fading</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>GraphListener</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.applet">
  <y:displayname>Sample: Applet</y:displayname>
  <y:displaypriority>10</y:displaypriority>
  <y:summary>Shows how to deploy a yFiles-based application as an applet inside a web browser</y:summary>
  <y:description>
    <h1>yFiles Applet Demos</h1>
    <p>
    The following tutorial view demos show how to deploy yFiles-based applications 
    as applets inside a web browser.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Applet Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.applet.AppletDemo" source="AppletDemo.java" executable="false">
    <y:displayname>Applet</y:displayname>
    <y:summary>Shows how to deploy a yFiles-based application as an applet inside a web browser</y:summary>
    <y:description>
    Shows how to deploy a yFiles-based application as an applet inside a web browser. 
    <br/>
    An <a href="build.xml">Ant build script</a> is used to compile and deploy the 
    applet's application classes (<a href="DemoEditor.java">demo.view.applet.DemoEditor</a>) 
    into a Jar file in this directory. 
    The HTML file <code>applet.html</code> can then be opened in the web browser.
    </y:description>
    <y:keywords>
      <y:keyword>applet</y:keyword>
      <y:keyword>deploy</y:keyword>
      <y:keyword>deployment</y:keyword>
      <y:keyword>web</y:keyword>
      <y:keyword>browser</y:keyword>
      <y:keyword>internet</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.application">
  <y:displayname>Application</y:displayname>
  <y:displaypriority>80</y:displaypriority>
  <y:summary>How to use basic application features</y:summary>
  <y:description>
    <h1>Application-specific yFiles Tutorial View Demos</h1>
    <p>
    The following tutorial view demos show how to use basic application
    features like drag and drop, print previewing, clipboard functionality, and
    undoability.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>application</y:keyword>
    <y:keyword>specific</y:keyword>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.application.UndoRedoDemo" source="UndoRedoDemo.java">
    <y:displayname>Undo Redo</y:displayname>
    <y:summary>Shows how to use undo/redo functionality provided by yFiles</y:summary>
    <y:description>
      <p>
        Shows how to use undo/redo functionality provided by yFiles.
      </p>
      <p>
        <b>Usage:</b> click on the view pane to draw a graph. To trigger an
        undo/redo event, press the corresponding button.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>undo</y:keyword>
      <y:keyword>redo</y:keyword>
      <y:keyword>backup</y:keyword>
      <y:keyword>realizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.ClipboardDemo" source="ClipboardDemo.java">
    <y:displayname>Clipboard</y:displayname>
     <y:summary>Demonstrates how to use the yFiles clipboard functionality to cut, copy, and paste parts of a graph</y:summary>
    <y:description>
      <p>
        Demonstrates how to use the yFiles clipboard functionality to cut, copy,
        and paste parts of a graph.
      </p>
      <p>
        <b>Usage:</b> Select graph elements and press the cut or copy button. This triggers the corresponding action.
        Note that edges are cut or copied only if both their source and their target nodes are selected. <br/>
        To paste elements from the clipboard press the paste button. <br/>
        It is also possible to use the corresponding key combinations: ctrl+x (cut), ctrl+c (copy) and ctrl+v (paste).
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>clipboard</y:keyword>
      <y:keyword>cut</y:keyword>
      <y:keyword>copy</y:keyword>
      <y:keyword>paste</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.DragAndDropDemo" source="DragAndDropDemo.java">
    <y:displayname>Drag and Drop</y:displayname>
    <y:summary>Shows how to drag different node and edge types from a list and how to drop them onto a graph view</y:summary>
    <y:description>
      Shows how to drag different node and edge types from a list and how to drop
      them onto a graph view. Dragging the image of a node type from the list to the
      the main view creates a node of that type at the drop location. To create an edge
      of a specific type drag its image from the list onto an already existing node in
      the view. This starts the creation of an edge starting at the drop target node.
      Snap lines can be activated/deactivated for node drag and drop with the Snapping
      button.
    </y:description>
    <y:keywords>
      <y:keyword>drag</y:keyword>
      <y:keyword>drop</y:keyword>
      <y:keyword>cell renderer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.LocalViewDemo" source="LocalViewDemo.java">
    <y:displayname>Local View</y:displayname>
    <y:summary>Demonstrates local views, a feature that uses a given graph to create a smaller graph which emphasizes a certain aspect of the original graph</y:summary>
    <y:description>
      <p>
      Demonstrates local views, a feature that uses a given (model) graph to create a
      (hopefully smaller) graph which emphasizes a certain aspect of the original
      graph.
      </p>
      <p>
      A local view displays a subset of a graph's elements. The intent is usually to
      improve performance, usability, or view experience in general (or all of the
      before mentioned).
      </p>
      <h2>Main Graph View</h2>
        <p>
        The display and editor area to the right. Several ways to interact with its
        graph are possible and may trigger an update of the local view (the display
        area to the left) depending on the chosen <em>update trigger</em> (see
        below).
        </p>

        <h3>Mouse Interaction</h3>
        <dl>
          <dt>Left Click on Node</dt>
          <dd>Selects the node.</dd>
          <dt>Left Mouse Drag on Canvas</dt>
          <dd>Selects multiple graph elements.</dd>
          <dt>Right Mouse Drag</dt>
          <dd>Moves the diagram within the view.</dd>
          <dt>Mouse Wheel</dt>
          <dd>Changes the zoom level of the view.</dd>
        </dl>

        <h3>Key Bindings</h3>
        <dl>
          <dt>Left Arrow Key</dt>
          <dd>Selects a node to the left of the currently selected node</dd>
          <dt>Right Arrow Key</dt>
          <dd>Selects a node to the right of the currently selected node</dd>
          <dt>Up Arrow Key</dt>
          <dd>Selects a node above the currently selected node</dd>
          <dt>Down Arrow Key</dt>
          <dd>Selects a node below the currently selected node</dd>
        </dl>

      <h2>Local Graph View</h2>
        <p>
        The display area to the left.
        </p>

       <h3>Mouse Interaction</h3>
       <dl>
         <dt>Double Click on Node</dt>
         <dd>Selects and centers the node in the main view if possible.</dd>
         <dt>Double Click on Edge</dt>
         <dd>Selects and centers the edge in the main view if possible.</dd>
       </dl>

      <h2>Settings</h2>
        <p>
          The available settings govern when and how to update the local graph view.
        </p>

        <h3>Update Trigger</h3>
        <dl>
          <dt>Mouse Hover</dt>
          <dd>The local view is updated if the mouse hovers (for about 1/10 of a
              second) over a node or edge in the main graph view.
              The node or edge over which the mouse hovers is the single input
              element for the chosen update strategy (see below).</dd>
          <dt>Selection Change</dt>
          <dd>The local view is updated if the selection state of nodes or edges is
              changed in the main graph view changes.
              Either all selected nodes or all selected edges (as appropriate)
              are used as input elements for the chosen update strategy (see
              below).</dd>
        </dl>

        <h3>Node Strategies</h3>
        <p>
          Available strategies to create local views for input nodes.
          Clicking on the corresponding radio button will activate the strategy
          and possibly display additional settings.
        </p>
        <dl>
          <dt>Neighborhood</dt>
          <dd>Displays all nodes that are reachable by directed or undirected paths
              upto a specific length.
            <dl>
              <dt class="inner">Included Nodes</dt>
              <dd>
                Determines which nodes make up the neighborhood of the input
                nodes.
                <br/>
                <span class="keyword">Predecessors</span> means all nodes that are
                reachable by outgoing edges only.
                <br/>
                <span class="keyword">Successors</span> means all nodes that are
                reachable by ingoing edges only.
                <br/>
                <span class="keyword">Predecessors and Successors</span> means the
                union of the two aforementioned node sets.
                <br/>
                <span class="keyword">All Neighbors</span> means all nodes that are
                reachable by undirected edge paths.
              </dd>
              <dt class="inner">Maximum Graph Distance</dt>
              <dd>The maximum number of edges to traverse to reach a neighborhood
                  node.</dd>
              <dt class="inner">Hierarchy Aware</dt>
              <dd>Determines whether the nodes real neighbors and all ancestor nodes
                  are shown. </dd>
              <dt class="inner">Included Edges</dt>
              <dd>
                Determines the edges that are displayed in the local view.
                <br/>
                <span class="keyword">None</span> means no edges at all.
                <br/>
                <span class="keyword">Subgraph Edges</span> means all edges
                that connect any two of the displayed nodes.
                <br/>
                <span class="keyword">Shortest Paths</span> means the edges that lie
                on the shortest path from one of the input nodes to one of the other
                displayed nodes.
              </dd>
            </dl>
          </dd>
          <dt>Common Parent Group</dt>
          <dd>
            Displays all nodes that share the same parent group node as one of the
            input nodes and edges connecting only these nodes.
            <br/>
            <span class="keyword">Include Descendants</span> determines whether
            the contents of displayed group nodes should be displayed as well.
          </dd>
          <dt>Ancestor Groups</dt>
          <dd>
            Displays the input nodes and all of their ancestor group nodes.
            A group node is considered to be the ancestor of another node if it
            either contains the node itself or one of its ancestor nodes.
            <br/>
            <span class="keyword">Include Focus Nodes</span> determines whether
            the input nodes are displayed as well.
          </dd>
          <dt>Folder Contents</dt>
          <dd>
            Displays the contents or inner graphs of all input nodes that are
            folder nodes. The nodes labeled <em>y.util</em> and <em>y.util.pq</em>
            are the only folder nodes in the sample diagram that is displayed in
            the main graph view.
            <br/>
            <span class="keyword">Always Include Folders</span> means that for each
            input folder node a group node representative is created in the local
            view.
            <br/>
            <span class="keyword">Include Folders As Needed</span> means that a
            group node representative for input folder nodes is created if the
            contents of more than one folder are displayed.
            <br/>
            <span class="keyword">Never Include Folders</span> means that input
            folder nodes will not be displayed in the local view.
          </dd>
          <dt>Selected Subgraph</dt>
          <dd>Displays the selected input nodes and all edges connecting only these
              nodes.</dd>
        </dl>

        <h3>Edge Strategies</h3>
        <p>
          Available strategies to create local views for input edges.
          Clicking on the corresponding radio button will activate the strategy
          and possibly display additional settings.
        </p>
        <dl>
          <dt>Source and Target</dt>
          <dd>Displays the input edges and their respective source and target
              nodes.
              <br/>
              <span class="keyword">Hierarchy Aware</span> determines whether the
              edges real ends and all their ancestors are shown.</dd>
          <dt>Edge Group</dt>
          <dd>
            Displays all edges that share source and/or target node (depending on
            the selection states of the <span class="keyword">Source</span> and
            <span class="keyword">Target</span> settings to the right) with one
            of the input edges.</dd>
        </dl>
    </y:description>
    <y:keywords>
      <y:keyword>local</y:keyword>
      <y:keyword>view</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>relation</y:keyword>
      <y:keyword>neighborhood</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.PrintPreviewDemo" source="PrintPreviewDemo.java">
    <y:displayname>Print Preview</y:displayname>
    <y:summary>Demonstrates how to use the yFiles print preview panel</y:summary>
    <y:description>
      <p>
        Demonstrates how to use the yFiles print preview panel and how to
        add a title and a footer to a printed page or poster.
      </p>
      <p>
        <b>Usage:</b> draw a graph by clicking on the view pane. The printer
        preview is opened by pressing the corresponding button.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>print</y:keyword>
      <y:keyword>printing</y:keyword>
      <y:keyword>preview</y:keyword>
      <y:keyword>poster</y:keyword>
      <y:keyword>row</y:keyword>
      <y:keyword>column</y:keyword>
      <y:keyword>title</y:keyword>
      <y:keyword>footer</y:keyword>
      <y:keyword>margin</y:keyword>
      <y:keyword>page</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.SwimlaneDemo" source="SwimlaneDemo.java">
    <y:displayname>Swimlanes</y:displayname>
    <y:summary>Demonstrates how to use and customize TableGroupNodeRealizer to work as a pool having several swim lanes and milestones</y:summary>
    <y:description>
      Demonstrates how to use and customize y.view.tabular.TableGroupNodeRealizer to work as a pool
      having several swim lanes and milestones.
      <h3>Working with the table structure</h3>
      <dl>
         <dt>Adding new rows/columns</dt>
         <dd>A new row or column can be added by dragging the corresponding icon from list and dropping it onto a table group node.</dd>

         <dt>Selecting rows/columns</dt>
         <dd>A row or column can be selected by clicking on it's header.</dd>

         <dt>Removing rows/columns</dt>
         <dd>A selected row or column can be removed using the <code>DELETE</code> key or the corresponding icon in the tool bar.</dd>

         <dt>Reordering rows/columns</dt>
         <dd>A selected row or column can be moved by dragging it on it's header to a different position in the table.</dd>

         <dt>Resizing rows/columns</dt>
         <dd>A row or column can be resized by dragging it' bottom respectively right border.
             If <code>SHIFT</code> is pressed at the beginning of the resize gesture, the sizes of the two attached stripes
         are redistributed.</dd>

          <dt>Editing the label of a row/column</dt>
          <dd>The label of a row or column can be edited by either selecting it and pressing the <code>F2</code> key or by double clicking it's header.</dd>
      </dl>

      <h3>Working with the table content</h3>
      <dl>
          <dt>Adding content nodes to the table</dt>
          <dd>
            New content (group) nodes can be dragged from the list onto a table.<br/>
            To add/remove a node to/from a group hold <code>SHIFT</code> and drag it onto or away from the group node respectively.
          </dd>

          <dt>Associating a node with a row or column</dt>
          <dd>A node is associated to the row and column it's center coordinates lie in. Therefore it can be associated to another row or column by simply dragging in to a new position.</dd>

          <dt>Laying out the table content</dt>
          <dd>A new layout for the tables and their contents can be calculated by pressing the layout button in the tool bar.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>TableGroupNodeRealizer</y:keyword>
      <y:keyword>swim lane</y:keyword>
      <y:keyword>column</y:keyword>
      <y:keyword>row</y:keyword>
      <y:keyword>table</y:keyword>
      <y:keyword>pool</y:keyword>
      <y:keyword>milestone</y:keyword>
      <y:keyword>ShapeNodePainter</y:keyword>
      <y:keyword>Drawable</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.application.SearchDemo" source="SearchDemo.java">
    <y:displayname>Searching</y:displayname>
    <y:summary>Demonstrates how to find nodes in a graph that match a specific criterion and how to visually present them</y:summary>
    <y:description>
      Demonstrates how to find nodes in a graph that match a specific criterion
      and how to visually present all matching nodes in simple way.
      <h2>Usage</h2>
      <p>
        Type the text you want to find into the <em>Find</em> text field in the
        toolbar. As you type, all nodes whose labels contain this text will
        be automatically highlighted. Click <em>Next</em> or <em>Previous</em>
        to select specific matching nodes of click <em>Select All</em> to select
        all matching nodes.
      </p>
      <p>
        Nodes whose labels contain the entered text are highlighted using a thick
        orange border. Those of these nodes that are selected (either using the
        <em>Next</em>, <em>Previous</em>, or <em>Select All</em> controls or by
        clicking on the node) are highlighted using a thick red border.
      </p>
      <h2>Global Key Bindings</h2>
      <dl>
        <dt>F3 Function Key</dt>
        <dd>Selects the next matching node.
            Same as clicking <em>Next</em> in the toolbar.</dd>
        <dt>Escape Key</dt>
        <dd>Clears the <em>Find</em> text field and any result highlighting.</dd>
      </dl>
      <h2>Search Field Key Bindings</h2>
      <dl>
        <dt>Return Key</dt>
        <dd>Selects the next matching node.
            Same as clicking <em>Next</em> in the toolbar.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>find node</y:keyword>
      <y:keyword>search nodes</y:keyword>
      <y:keyword>match</y:keyword>
      <y:keyword>matching</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>Drawable</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.entityrelationship">
  <y:displayname>Sample: Entity-Relationship Diagrams</y:displayname>
  <y:displaypriority>14</y:displaypriority>
  <y:summary>Editor to visualize and edit entity-relationship diagrams (ERD)</y:summary>
  <y:description>
  <h1>Entity-Relationship Demo</h1>
    This demo allows you to visualize and edit entity-relationship diagrams (ERD). It shows how to
    <ul>
      <li>add a palette of ERD symbols, the <code>EntityRelationshipPalette</code>, to ease the creation of diagrams</li>
      <li>implement a <code>y.view.GenericNodeRealizer.Painter</code> tailored for the drawing of ERD symbols with two labels</li>
      <li>convert the notation of the diagram with a custom class, the <code>ErdNotationConverter</code>
            </li>
      <li>apply an orthogonal layout with suitable default values</li>
      <li>add undo/redo and cut/copy/paste</li>
    </ul>
    There are sample diagrams in Chen and Crow's Foot notation.
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Entity-Relationship Demo</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.entityrelationship.EntityRelationshipDemo" source="EntityRelationshipDemo.java">
    <y:displayname>Entity Relationship Editor</y:displayname>
    <y:summary>Editor to visualize and edit entity-relationship diagrams (ERD)</y:summary>
    <y:description>
      This demo allows you to visualize and edit entity-relationship diagrams (ERD). It shows how to
      <ul>
        <li>add a palette of ERD symbols, the <code>EntityRelationshipPalette</code>, to ease the creation of diagrams</li>
        <li>implement a <code>y.view.GenericNodeRealizer.Painter</code> tailored for the drawing of ERD symbols with two labels</li>
        <li>convert the notation of the diagram with a custom class, the <code>ErdNotationConverter</code>
              </li>
        <li>apply an orthogonal layout with suitable default values</li>
        <li>add undo/redo and cut/copy/paste</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>entity relationship</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>custom painter</y:keyword>
      <y:keyword>crow's foot</y:keyword>
      <y:keyword>chen</y:keyword>
      <y:keyword>ERD</y:keyword>
      <y:keyword>label</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.entityrelationship.EntityRelationshipPalette" source="EntityRelationshipPalette.java" executable="false">
    <y:displayname>EntityRelationshipPalette</y:displayname>
    <y:description>This component provides templates for entity-relationship diagram (ERD)
 nodes and edges that can be dragged into a <code>y.view.Graph2DView</code>.</y:description>
    <y:keywords>
      <y:keyword>entity relationship</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>palette</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.entityrelationship.ErdNotationConverter" source="ErdNotationConverter.java" executable="false">
    <y:displayname>ErdNotationConverter</y:displayname>
    <y:description>A converter to transform entity-relationship diagrams from Chen to Crow's Foot notation and vice versa.</y:description>
    <y:keywords>
      <y:keyword>entity relationship</y:keyword>
      <y:keyword>notation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.entityrelationship.EntityRelationshipPopupMode" source="EntityRelationshipPopupMode.java" executable="false">
    <y:displayname>EntityRelationshipPopupMode</y:displayname>
    <y:description>A popup mode that creates a menu for arrow selection for an edge's source and target in entity
      relationship diagrams (ERD). There are two lists of <code>Arrows</code>, one to select the source arrow the other
      to select the target arrow.</y:description>
    <y:keywords>
      <y:keyword>PopupMode</y:keyword>
      <y:keyword>MouseMotionListener</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.entityrelationship.painters.ErdNodePainter" source="painters/ErdNodePainter.java" executable="false">
    <y:displayname>ErdNodePainter</y:displayname>
    <y:description>A painter that draws a node in ERD style that is used in Crow's Foot Notation.</y:description>
    <y:keywords>
      <y:keyword>custom painter</y:keyword>
      <y:keyword>ContainsTest</y:keyword>
      <y:keyword>GenericNodeRealizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.entityrelationship.painters.ErdAttributesNodeLabelModel" source="painters/ErdAttributesNodeLabelModel.java" executable="false">
    <y:displayname>ErdAttributesNodeLabelModel</y:displayname>
    <y:description>A label model that computes the size and placement information for the attributes label of an ERD
      entity node. The area of the attributes label starts at the separator line and fills the whole lower compartment.
    </y:description>
    <y:keywords>
      <y:keyword>custom label model</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>model</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>parameter</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.flowchart">
  <y:displayname>Sample: Flowchart</y:displayname>
  <y:displaypriority>15</y:displaypriority>
  <y:summary>Editor to visualize and edit flowchart diagrams</y:summary>
  <y:description>
    <h1>The Flowchart Demo</h1>
    This demo allows to visualize and edit the flowchart diagrams. An integrated palette provides flowchart symbols
    for creation of diagrams.
    From the viewpoint of programming, this demo shows many aspects. In particular it shows how to
    <ul>
      <li>integrate and configure a customized <code>y.view.Graph2DView</code> into your Swing application</li>
      <li>implement a default flowchart palette</li>
      <li>implement a custom node painter for drawing of flowchart symbols</li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Flowchart Demo</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.flowchart.FlowchartDemo" source="FlowchartDemo.java">
    <y:displayname>Flowchart Editor</y:displayname>
    <y:summary>Editor to visualize and edit flowchart diagrams</y:summary>
    <y:description>
         An integrated palette provides flowchart symbols
        for creation of diagrams.
        From the viewpoint of programming, this demo shows many aspects. In particular it shows how to
        <ul>
            <li>integrate and configure a customized <code>y.view.Graph2DView</code> into your Swing application </li>
            <li>implement a default flowchart palette.</li>
            <li>implement a custom node painter for drawing of flowchart symbols. For details please see the package: <code>demo.view.flowchart.painters</code>
              </li>
        </ul>
    </y:description>
    <y:keywords>
      <y:keyword>flowchart</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.flowchart.FlowchartPalette" source="FlowchartPalette.java" executable="false">
    <y:displayname>FlowchartPalette</y:displayname>
    <y:description>This is a component, which represents a palette of flowchart nodes or edges and allows to drag them into a <code>y.view.Graph2DView</code>.</y:description>
    <y:keywords>
      <y:keyword>flowchart</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>palette</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.flowchart.FlowchartView" source="FlowchartView.java" executable="false">
    <y:displayname>FlowchartView</y:displayname>
    <y:description>For flowchart adjusted <code>y.view.Graph2DView</code> </y:description>
    <y:keywords>
      <y:keyword>flowchart</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>PopupMode</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.graphexplorer">
  <y:displayname>Sample: Graph Explorer</y:displayname>
  <y:displaypriority>13</y:displaypriority>
  <y:summary>Demonstrates how to successively explore large graphs</y:summary>
  <y:description>
    <h1>The Graph Explorer Demo</h1>
    <p>
    Demonstrates how to successively explore large graphs.
    </p>
    <p>
    Things to try:
    </p>
    <ul>
    <li>Double-click a node in the view to show connected nodes/edges.</li>
    <li>Double-click an item in the tree to add the corresponding node to the
    view.</li>
    <li>Move a node around, then double-click the node while holding
    <code>CTRL</code> to reposition its neighbors.</li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Graph Explorer Demo</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.graphexplorer.GraphExplorerDemo" source="GraphExplorerDemo.java">
    <y:displayname>Graph Explorer</y:displayname>
    <y:summary>Demonstrates how to successively explore large graphs</y:summary>
    <y:description>
      <p>
      For large graphs, it is often not feasible to display all elements to a user.
      Therefore, strategies to filter and/or navigate the graph elements have to be
      used. This demo shows how large graphs can be explored interactively.
      </p>
      <h3>Concepts</h3>
      <p>
      This demo works with two graphs: a (large) model graph and a (smaller) view
      graph.
      The model graph constitutes the complete set of available information.
      The demo lists (the labels of) the model graph's  nodes in a searchable tree on
      its left-hand side.
      The view graph is a (small) excerpt of the model graph.
      It is displayed in the central graph view.
      </p>
      <h3>How to Explore Graphs</h3>
      <p>
      Double-clicking on an item in the tree will add a corresponding node to the
      displayed view graph. Nodes in the view are sometimes decorated with a small,
      yellow icon in their upper right corner. The number given in the icon is the
      number of nodes/edges that are connected to the corresponding node in the model
      graph but are currently <b>not</b> displayed in the view. Double-clicking on
      such a node in the view will add some or all of those nodes/edges, too.
      </p>
      <h3>The File Menu</h3>
      <dl>
        <dt>Load Model Graph</dt>
        <dd>
          Loads a graph as model graph. Supports graphs in GraphML (*.graphml) and
          compressed GraphML (*.graphmlz) format.
        </dd>
        <dt>Save Model Graph</dt>
        <dd>
          Saves the current model graph in either GraphML (*.graphml) or compressed
          GraphML (*.graphmlz) format.
        </dd>
        <dt>Save Filtered Graph</dt>
        <dd>
          Saves the view graph that is displayed in the central graph view in either
          GraphML (*.graphml) or compressed GraphML (*.graphmlz) format.
        </dd>
      </dl>
      <h3>The Sample Graphs Menu</h3>
      <p>
      Each entry loads an example model graph. All example graphs are loaded from
      compressed GraphML (*.graphmlz) format.
      </p>
      <h2>Settings</h2>
      <dl>
        <dt>Layout</dt>
        <dd>
        Specifies the layout strategy that is used to position elements.
        The button to the right of the combo box calculates a new layout for the
        visible graph.
        </dd>
        <dt>Explore Nodes</dt>
        <dd>
        Specifies the nodes that are added by exploration. Possible values are:
        <br/>
                <span class="keyword">Predecessors</span>
        means all nodes that are reachable only by outgoing edges of a selected node.
        <br/>
                <span class="keyword">Successors</span>
        means all nodes that are reachable only by ingoing edges of a selected node.
        <br/>
                <span class="keyword">Neighbors</span>
        means all nodes that are reachable by ingoing and outgoing edges of a
        selected node.
        </dd>
        <dt>Max New Nodes on Click</dt>
        <dd>
        Specifies the maximum number of new nodes that are added by exploration.
        If the number of hidden neighbors of a node is larger than this value,
        adding all neighbors requires several double-clicks.
        </dd>
        <dt>Filter Neighbors</dt>
        <dd>
        If this option is enabled, exploration removes nodes if the length of the
        shortest path from a node to any selected node is greater than the value of
        <span class="keyword">Max Neighbor Distance</span>.
        </dd>
        <dt>Max Neighbor Distance</dt>
        <dd>
        If <span class="keyword">Filter Neighbors</span> is enabled, exploration
        removes nodes if the length of the shortest path from a node to any selected
        node is greater than the value of this option.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>neighborhood</y:keyword>
      <y:keyword>filter</y:keyword>
      <y:keyword>large graph</y:keyword>
      <y:keyword>explore</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.graphexplorer.LayoutContext" source="LayoutContext.java" executable="false">
    <y:displayname>LayoutContext</y:displayname>
    <y:description>
      Encapsulates information about old/removed and new elements for
      partial/incremental and complete re-layout.
    </y:description>
  </y:demo>

  <y:demo javaname="demo.view.graphexplorer.LayoutSupport" source="LayoutSupport.java" executable="false">
    <y:displayname>LayoutSupport</y:displayname>
    <y:description>
      Provides several layout algorithms for partial/incremental and complete
      re-layout.
    </y:description>
    <y:keywords>
      <y:keyword>animation</y:keyword>
      <y:keyword>SmartOrganicLayouter</y:keyword>
      <y:keyword>CircularLayouter</y:keyword>
      <y:keyword>BalloonLayouter</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>OrthogonalLayouter</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.hierarchy">
  <y:displayname>Nested Graph Hierarchy</y:displayname>
  <y:displaypriority>70</y:displaypriority>
  <y:summary>How to work with hierarchical graphs</y:summary>
  <y:description>
    <h1>yFiles Tutorial Graph Hierarchy Demos</h1>
    <p>
    The following tutorial view demos show how to work with graphs that are organized as a hierarchical structure
    of expanded or collapsed groups of nodes.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Graph Hierarchy Demos</y:keyword>
    <y:keyword>Hierarchy Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.hierarchy.HierarchyDemo" source="HierarchyDemo.java">
    <y:displayname>Hierarchy</y:displayname>
    <y:summary>Exhibits the Nested Graph Hierarchy and the Node Grouping technologies that are a modular part of the yFiles library</y:summary>
    <y:description>
      <p>
        Demonstrates the <b>Nested Graph Hierarchy</b> and the
        <b>Node Grouping</b> technologies that are a modular part of the yFiles
        library.
      </p>

      <p class="note">
        <b>Note:</b>
        <br/>
        This application demonstrates a legacy approach for interacting with
        nested graph hierarchies and node groups.
        Please refer to <code>GroupingDemo</code> and
        <code>GroupNavigationDemo</code> for the recommended approach as of
        yFiles for Java 2.7.
      </p>

      <h2>Nested Graph Hierarchy</h2>

      <p>
        <b>Nested Graph Hierarchy</b> basically provides the possibility to
        put a graph inside a node which itself is contained in another graph.
        A node that contains another graph is called an <b>anchor node</b>
        or a <b>folder node</b> A tree-like hierarchy of graphs will be induced
        by a nesting of graphs inside of other nodes. The top-level graph of
        this hierarchy of graphs is called the <b>root graph</b>. A graph that
        contains a nested graph is called the <b>parent graph</b> of that nested
        graph.
      </p>

      <h2>Node Grouping/Nesting</h2>
      <p>
        <b>Node Grouping</b> complements the <i>Nested Graph Hierarchy</i>
        technology. It is a feature mainly provided by the viewer component.
        Nodes of all kind can be put together in a group, that will be
        visualized by a group node, which will be painted in the background of
        its child nodes. In contrast to the <i>Nested Graph Hierarchy</i>
        technology, all nodes, <i>group nodes</i> and their <i>child nodes</i>
        reside in the top level graph at the same time. However the view
        suggests that at all times, child nodes lie within their respective
        parent group nodes. This makes it possible to connect nodes of different
        logical hierarchy levels with each other
        visually.
      </p>

      <p>
        This application demonstrates the use of these two technologies. Since
        both of them can be used to describe a hierarchy of nodes, it is
        possible to simply switch between the two different technologies. The
        actions that are made accessible through this application can be used
        to edit the graph/node hierarchy and the visual presentation of the
        hierarchy.
      </p>

      <center>
        <table>
          <caption align="bottom">A hierarchical graph with
            folder nodes, that contain graphs themselves.
          </caption>
          <tr>
            <td>
              <img src="resource/hierarchy1.jpg" alt="Sample Image"/>
            </td>
          </tr>
        </table>
      </center>

      <p>
        A noteworthy feature of the yFiles
        <b>Nested Graph Hierarchy</b>
        is
        that one can move parts of a graph to another level within the
        hierarchy of graphs. The edges connecting the part that has
        been moved with the rest of the graph won't get lost though.
        Original edges will be represented by edges connecting to the
        node the subgraph is nested in. When unpacking the contents of a
        node again, the original edges will be restored. Hence the
        topology of a graph won't be destroyed by a sequence of
        nesting operations.
      </p>

      <h2>Using HierarchyDemo</h2>

      <p>
        HierarchyDemo displays three views of a nested graph hierarchy.
        On the left there is a classic tree view that shows the complete
        graph hierarchy and all of the nodes contained within it.
        The main view of HierarchyDemo displays the graph hierarchy
        from a specific hierarchy level on downward.
        The graphs that are nested within folder-nodes are displayed
        as well. Group nodes look similar to folder-nodes but behave differently.
        While it is possible to resize and move folder-nodes freely, the position
        and size of a group-node is induced by the positions and sizes of the child
        nodes that belong to the respective group. While a folder-node only
        displays the child nodes it contains, the children of a group node still belong
        to the graph structure and can be treated like normal nodes.
        The third view of HierarchyDemo is located above the tree view.
        It acts as an overview display of the graph that is visualized in
        the main view.
      </p>

      <h2>The Main view</h2>

      <p>
        This section describes which hierarchy-related and grouping-related
        operations are available within the main view.
      </p>

      <h3>The Popup Menu</h3>

      <p>
        By right clicking on the main view a popup menu will become
        visible. The following menu items manipulate the graph hierarchy
        or the view on the graph hierarchy:
      </p>

      <table>
        <tr>
          <th>Menu Item</th>
          <th>Description</th>
        </tr>

        <tr>
          <td>Group Selection</td>
          <td>
            Selected nodes will be grouped. This is done by creating a new group
            node and making the selected nodes logically children of the newly
            created group node. If no nodes are selected, an empty group node will
            be created.
          </td>
        </tr>
        <tr>
          <td>Ungroup Selection</td>
          <td>
            Selected nodes will be ungrouped, i.e. they will become child nodes of the
            parent of their current parent node. Empty group nodes will not be
            removed, but stay in the graph structure.
          </td>
        </tr>

        <tr>
          <td>Close Group</td>
          <td>
            This action can be invoked on selected group nodes. This will actually
            switch the node from
            <i>Node Grouping</i>
            technology to
            <i>Nested
              Graph
            </i>
            technology. This can be undone by invoking
            <i>Open
              Folder
            </i>
            on the closed group node.
          </td>
        </tr>

        <tr>
          <td>Create Folder</td>
          <td>
            Creates a new folder node containing an empty graph.
          </td>
        </tr>
        <tr>
          <td>Fold Selection</td>
          <td>
            This method folds the subgraph induced by the selected
            nodes inside a newly created folder node.
          </td>
        </tr>
        <tr>
          <td>Unfold Selection</td>
          <td>
            This method moves the subgraph induced by the selected
            nodes to the parent graph. This operation is only available
            if the graph displayed in the main view is not the root
            graph. Otherwise there would be no parent graph to unfold
            the selection to.
          </td>
        </tr>
        <tr>
          <td>Extract Folder</td>
          <td>
            Extract the contents of the folder-node on which the
            popup menu has been opened upon and remove the then
            empty folder.
          </td>
        </tr>
        <tr>
          <td>Open Folder</td>
          <td>
            Opens the currently selected folder-node, thus transforming it
            into a group-node. This is the reverse operation of
            <i>Close
              Group
            </i>
            .
          </td>
        </tr>
      </table>

      <h3>The Menu Bar</h3>

      <table>
        <tr>
          <th>Menu Item</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>
            <a name="view_parent"/>
            Toolbar - View Parent
          </td>
          <td>
            View the parent graph of the currently display graph in
            the main view. This operation is only available
            if the graph displayed in the main view is not the root
            graph. Otherwise there would be no parent graph to unfold
            the selection to.
          </td>
        </tr>
        <tr>
          <td>Tools - Unfold All</td>
          <td>
            This method recursively unfolds the contents of all
            folder nodes within the displayed graph.
          </td>
        </tr>
        <tr>
          <td>Tools - Fold Selection</td>
          <td>
            Creates for each connected component of the displayed graph
            a new folder-node. Each connected component will be moved
            from the displayed graph to the corresponding folder-node.
          </td>
        </tr>
        <tr>
          <td>Tools - Fold Subtrees</td>
          <td>
            This method finds tree-structures that are part of the
            displayed graph. For each of these trees a new
            folder-node will be created. Each tree will be
            moved from the displayed graph to the corresponding folder node.
            Each nested tree will be automatically layed out using
            ballon layouter. The size-ratio of the folder-nodes will be
            automatically adjusted to the size of the nested trees.
            <br/>
            Please note that the code to automatically layout the subgraphs
            is commented out by default in order to make this demo compile even if
            only the yFiles viewer package is available.
            Uncomment the code lines if the layout package is available to
            activate the layouter.
          </td>
        </tr>
      </table>

      <h3>Hierarchic View Mode</h3>

      <p>
        There are some additional hierarchy-related operations
        available on the main view that are triggered by mouse gestures.
      </p>

      <ul>
        <li>
          Dropping a selection of nodes onto a group-node while pressing the
          "shift" modifier key
          will make the selected nodes part of the group that is visualized by
          the group-node.
          The location of the mouse cursor must be on a group-node
          when the mouse button gets released.
        </li>
        <li>
          Pressing the "shift" modifier key before starting to drag a selection of
          nodes will ungroup the selected nodes.
        </li>
        <li>
          Double-clicking on a folder-node navigates into the folder.
        </li>
      </ul>

      <h2>The Tree View</h2>

      <p>
        Double-clicking on a node that is displayed
        in the tree view transfers the focus of the main view
        to that node.
        Focusing a node in the main view involves two things:
        The nested graph that contains the focused node gets
        displayed in the main view. And the focused node will
        be displayed in the center of the view.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>HierarchyJTree</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.CustomGroupVisualizationDemo" source="CustomGroupVisualizationDemo.java">
    <y:displayname>Custom Group Visualization</y:displayname>
    <y:summary>Demonstrates how to customize the visual representation of group and folder nodes using GenericGroupNodeRealizer</y:summary>
    <y:description>
      Demonstrates how to customize the visual representation of group and folder
      nodes using <code>y.view.hierarchy.GenericGroupNodeRealizer</code>.
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>generic</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.FadingGroupStateIconDemo" source="FadingGroupStateIconDemo.java">
    <y:displayname>Fading Group State Icon</y:displayname>
    <y:summary>Demonstrates how to fade in/out the group state icon when moving the mouse over group/folder nodes</y:summary>
    <y:description>
      Demonstrates how to fade in/out the group state icon when moving the mouse
      over group/folder nodes using a custom <code>y.view.ViewMode</code>.
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>generic</y:keyword>
      <y:keyword>fading</y:keyword>
      <y:keyword>fade</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.GroupingDemo" source="GroupingDemo.java">
    <y:displayname>Grouping</y:displayname>
    <y:summary>Exhibits the Nested Graph Hierarchy and the Node Grouping technologies </y:summary>
    <y:description>
      <p>
        This tutorial source code demo
        exhibits
        the
        <b>Nested Graph Hierarchy</b>
        and the
        <b>Node Grouping</b>
        technologies
        that are a modular part of the yFiles library.
      </p>

      <h2>Nested Graph Hierarchy</h2>

      <p>
        <b>Nested Graph Hierarchy</b>
        basically provides the possibility to
        put a graph inside a node which itself is contained in another
        graph.
        A node that contains another graph is called an
        <b>anchor node</b>
        or a
        <b>folder node</b>
        A tree-like hierarchy of graphs will be induced by a nesting
        of graphs inside of other nodes. The top-level graph of this hierarchy
        of graphs is called the
        <b>root graph</b>
        . A graph that
        contains a nested graph is called the
        <b>parent graph</b>
        of
        that nested graph.
      </p>

      <h2>Node Grouping/Nesting</h2>
      <p>
        <b>Node Grouping</b>
        complements the
        <i>Nested Graph Hierarchy</i>
        technology. It is a feature mainly provided by the viewer component. Nodes
        of all kind can be put together in a group, that will be visualized by a
        group node, which will be painted in the background of it's child nodes.
        In contrast to the
        <i>Nested Graph Hierarchy</i>
        technology, all nodes,
        <i>group nodes</i>
        and their
        <i>child nodes</i>
        reside in the top level
        graph at the same time. However the view suggests that at all times, child
        nodes lie within their respective parent group nodes. This makes it possible
        to connect nodes of different logical hierarchy levels with each other
        visually.
      </p>

      <p>
        This application demonstrates the use of these two technologies. Since both
        of them can be used to describe a hierarchy of nodes, it is possible to
        simply switch between the two different technologies. The actions that are
        made accessible through this application can be used to edit the graph/node
        hierarchy and the visual presentation of the hierarchy.
      </p>

      <center>
        <table>
          <caption align="bottom">A hierarchical graph with
            folder nodes, that contain graphs themselves.
          </caption>
          <tr>
            <td>
              <img src="resource/hierarchy1.jpg" alt="Sample Image"/>
            </td>
          </tr>
        </table>
      </center>

      <p>
        A noteworthy feature of the yFiles
        <b>Nested Graph Hierarchy</b>
        is
        that one can move parts of a graph to another level within the
        hierarchy of graphs. The edges connecting the part that has
        been moved with the rest of the graph won't get lost though.
        Original edges will be represented by edges connecting to the
        node the subgraph is nested in. When unpacking the contents of a
        node again, the original edges will be restored. Hence the
        topology of a graph won't be destroyed by a sequence of
        nesting operations.
      </p>

      <h2>Using GroupingDemo</h2>

      <p>
        GroupingDemo displays a view of a nested graph hierarchy.
        Group nodes look similar to folder-nodes but behave differently.
        While it is possible to resize and move folder-nodes freely, the position
        and size of a group-node is induced by the positions and sizes of the child
        nodes that belong to the respective group. While a folder-node only
        displays the child nodes it contains, the children of a group node still belong
        to the graph structure and can be treated like normal nodes.
      </p>

      <h2>Available actions</h2>

      <p>
        This section describes which hierarchy-related and grouping-related
        operations are available within the view.
      </p>

      <h3>The Popup Menu and the Grouping Menu</h3>

      <p>
        By right clicking on the main view a popup menu will become
        visible. The Grouping menu on the applications menu bar provides the same actions.
        The following menu items manipulate the graph hierarchy
        or the view on the graph hierarchy:
      </p>

      <table>
        <tr>
          <th>Menu Item</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>Close Group</td>
          <td>
            This action can be invoked on selected group nodes. This will actually
            switch the node from
            <i>Node Grouping</i>
            technology to
            <i>Nested
              Graph
            </i>
            technology. This can be undone by invoking
            <i>Open
              Folder
            </i>
            on the closed group node.
          </td>
        </tr>
        <tr>
          <td>Open Folder</td>
          <td>
            Opens the currently selected folder-node, thus transforming it
            into a group-node. This is the reverse operation of
            <i>Close Group</i>
            .
          </td>
        </tr>
        <tr>
          <td>Group Selection</td>
          <td>
            Selected nodes will be grouped. This is done by creating a new group
            node and making the selected nodes logically children of the newly
            created group node.
          </td>
        </tr>
        <tr>
          <td>Ungroup Selection</td>
          <td>
            Selected nodes will be ungrouped, i.e. they will become child nodes of the
            parent of their current parent node. Empty group nodes will not be
            removed, but stay in the graph structure.
          </td>
        </tr>
        <tr>
          <td>Fold Selection</td>
          <td>
            This method folds the subgraph induced by the selected
            nodes inside a newly created folder node.
          </td>
        </tr>
      </table>


      <h3>Hierarchic View Mode</h3>

      <p>
        There are some additional hierarchy-related operations
        available on the main view that are triggered by mouse gestures.
      </p>

      <ul>
        <li>
          Dropping a selection of nodes onto a group-node while pressing the
          "shift" modifier key
          will make the selected nodes part of the group that is visualized by
          the group-node.
          The location of the mouse cursor must be on a group-node
          when the mouse button gets released.
        </li>
        <li>
          Pressing the "shift" modifier key before starting to drag a selection of
          nodes will ungroup the selected nodes.
        </li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.GroupNavigationDemo" source="GroupNavigationDemo.java">
    <y:displayname>Group Navigation</y:displayname>
    <y:summary>Shows how to implement custom navigation actions to navigate to group/folder node contents and back</y:summary>
    <y:description>
      The following actions are supported:
      <ul>
        <li>Navigation into a group or folder node: Either select a single group or folder node and press <code>CTRL+PAGE_DOWN</code>, or
        use the entry "Enter Group" in the node's context menu. This will change the view graph to the inner graph of the folder or group node.
        If the node to enter is not a group or folder node, nothing happens.</li>
        <li>Navigation to the parent graph: Either press <code>CTRL+PAGE_UP</code>, or
        use the entry "Navigate to parent" in the context menu. This will change the view graph to the parent graph of the folder or group node. If
        the view is already at root level, nothing is done.</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>HierarchyJTree</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.hierarchy.HierarchyJTreeDemo" source="HierarchyJTreeDemo.java">
    <y:displayname>Hierarchy and JTree</y:displayname>
    <y:summary>Shows how to use class HierarchyJTree to display the hierarchical structure as a JTree</y:summary>
      <y:description>
      <code>HierarchyJTree</code>
      provides a different view on the graph structure, as well as (optionally) navigational actions
      and support for changes in the hierarchical structure. This demo provides the following actions:
        <ul>
          <li>Double clicking on a node in the tree centers the view on this node. If the node is contained in a folder node,
          this action navigates to the inner graph of the node's parent folder.</li>
          <li>Drag/drop inside the tree changes the graph hierarchy.</li>
          <li>Editing labels in the tree will change the actual node labels and vice versa.</li>
        </ul>
    </y:description>
    <y:keywords>
      <y:keyword>HierarchyManager</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>folder</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>nested</y:keyword>
      <y:keyword>nesting</y:keyword>
      <y:keyword>grouping</y:keyword>
      <y:keyword>organization</y:keyword>
      <y:keyword>hierarchical</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>drill-down</y:keyword>
      <y:keyword>HierarchyJTree</y:keyword>
      <y:keyword>root</y:keyword>
      <y:keyword>graph</y:keyword>
      <y:keyword>anchor</y:keyword>
      <y:keyword>inner</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.isometry">
  <y:displayname>Sample: Isometric Graphs</y:displayname>
  <y:displaypriority>17</y:displaypriority>
  <y:summary>Contains a demo that displays graphs in an isometric fashion to create an impression of a 3-dimensional view.</y:summary>
  <y:description>
    <h1>Isometry Demo</h1>
    <p>
    This demo displays graphs in an isometric fashion to create the impression of a 3-dimensional view.
    It shows how to:
    </p>
    <ul>
      <li>
        create a layout stage (<code>IsometryTransformationLayoutStage</code>) that transforms the graph into a layout space
        before layout and retransforms it into view space afterwards. So any <code>Layouter</code> can be used to
        calculate the layout which is then transformed into an isometric view.
      </li>
      <li>write custom label configurations that display the labels isometrically transformed.</li>
      <li>write custom node painter that use custom user data with 3D-information.</li>
      <li>adjust the rendering order to paint objects that are further away behind.</li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Isometry Demo</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.isometry.IsometryDemo" source="IsometryDemo.java">
    <y:displayname>Isometric Graphs</y:displayname>
    <y:summary>Shows isometric graph layouts that create a 3D-impression.</y:summary>
    <y:shortdescription>
      To produce a 3-dimensional view of a graph the node positions and edge routes are transformed into isometric
      coordinates. Additionally, isometric cuboids represent nodes and the rendering order takes the node's position
      in space into account to support the spatial impression.
    </y:shortdescription>
    <y:description>
      <p>
        This demo displays graphs in an isometric fashion to create an impression of a 3-dimensional view.
        It shows how to:
      </p>
      <ul>
        <li>
          create a layout stage (<code>IsometryTransformationLayoutStage</code>) that transforms the graph into a layout
          space
          before layout and retransforms it into view space afterwards. So any <code>Layouter</code> can be used to
          calculate the layout which is then transformed into an isometric view.
        </li>
        <li>write custom label configurations that display the labels isometrically transformed.</li>
        <li>write custom node painter that use custom user data with 3D-information.</li>
        <li>adjust the rendering order to paint objects that are further away behind.</li>
      </ul>

      <h2>Interaction</h2>
      <p>
        As this demo is mainly a viewer, it is not possible to edit the graph structure.
      </p>

      <h3>Group Nodes</h3>
      <dl>
        <dt>Left Click on Group State Icon</dt>
        <dd>Opens/Closes the group node and shows/hides its children.</dd>
      </dl>

      <h3>Navigation</h3>
      <dl>
        <dt>Left Drag on View</dt>
        <dd>Moves view according to the difference between drag start and current mouse position.</dd>
        <dt>Right Drag on View</dt>
        <dd>Moves view in the direction of the vector between drag start and current mouse position.</dd>
      </dl>

      <h3>Zoom</h3>
      <dl>
        <dt>Mouse Wheel</dt>
        <dd>Changes the zoom level of the view.</dd>
      </dl>

      <h2>Layout</h2>
      <dl>
        <dt>Hierarchic layout button</dt>
        <dd>Applies an hierarchic layout to the current diagram.</dd>
        <dt>Orthogonal layout button</dt>
        <dd>Applies an orthogonal layout to the current diagram.</dd>
        <dt>Opening/closing groups</dt>
        <dd>
          Either applies incremental hierarchic or orthogonal layout to the
          current diagram according to the last layout setting.
        </dd>
      </dl>

      <h2>Load Graphs</h2>
      <dl>
        <dt>Select Load in the File Menu</dt>
        <dd>Load a graph and display it isometrically.</dd>
        <dt>Select Save in the File Menu</dt>
        <dd>
          Save the current graph. Note that if a custom graph was loaded it got
          changed. Do not accidentally overwrite your original graph.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>isometry</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>NavigationMode</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>IncrementalHierarchicLayouter</y:keyword>
      <y:keyword>OrthogonalGroupLayouter</y:keyword>
      <y:keyword>serialize</y:keyword>
      <y:keyword>deserialize</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.IsometryTransformationLayoutStage" source="IsometryTransformationLayoutStage.java" executable="false">
    <y:displayname>IsometryTransformationLayoutStage</y:displayname>
    <y:description>
      A <code>LayoutStage</code> which transforms the current isometric graph into layout space where it can be
      layouted. Afterwards, the graph gets transformed to isometric space again.
    </y:description>
    <y:keywords>
      <y:keyword>isometry</y:keyword>
      <y:keyword>LayoutStage</y:keyword>
      <y:keyword>transform</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.IsometryRealizerFactory" source="IsometryRealizerFactory.java" executable="false">
    <y:displayname>IsometryRealizerFactory</y:displayname>
    <y:description>
      This class registers the custom isometric configurations for nodes and labels. It also provides methods to change
      a graphs realizers and configurations and to retrieve <code>IsometryData</code> for realizers.
    </y:description>
    <y:keywords>
      <y:keyword>isometry</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>IsometryData</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.IsometryData" source="IsometryData.java" executable="false">
    <y:displayname>IsometryData</y:displayname>
    <y:description>
      This class contains 3-dimension information (width, depth, height) and can be attached to generic realizers and
      labels as user data. <code>IsometryTransformationLayoutStage</code> uses this data to transform the graph from
      view to layout and vice versa.
    </y:description>
    <y:keywords>
      <y:keyword>isometry</y:keyword>
      <y:keyword>user data</y:keyword>
      <y:keyword>transform</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.IsometryNodePainter" source="IsometryNodePainter.java" executable="false">
    <y:displayname>IsometryNodePainter</y:displayname>
    <y:description>
      A <code>Painter</code> for <code>GenericNodeRealizer</code> that paints the node isometrically.
    </y:description>
    <y:keywords>
      <y:keyword>GenericNodeRealizer</y:keyword>
      <y:keyword>painter</y:keyword>
      <y:keyword>isometry</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.IsometryGroupPainter" source="IsometryGroupPainter.java" executable="false">
    <y:displayname>IsometryGroupPainter</y:displayname>
    <y:description>
      A <code>Painter</code> for <code>GenericGroupNodeRealizer</code> that paints a group node isometrically and adds
      a group state icon as a button to open/close the group.
    </y:description>
    <y:keywords>
      <y:keyword>GenericGroupNodeRealizer</y:keyword>
      <y:keyword>painter</y:keyword>
      <y:keyword>isometry</y:keyword>
      <y:keyword>group state icon</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.EdgeLabelConfiguration" source="EdgeLabelConfiguration.java" executable="false">
    <y:displayname>EdgeLabelConfiguration</y:displayname>
    <y:description>
      A configuration for edge labels that paints them standing up in isometric space.
    </y:description>
    <y:keywords>
      <y:keyword>configuration</y:keyword>
      <y:keyword>EdgeLabel</y:keyword>
      <y:keyword>isometry</y:keyword>
      <y:keyword>transform</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.GroupLabelConfiguration" source="GroupLabelConfiguration.java" executable="false">
    <y:displayname>GroupLabelConfiguration</y:displayname>
    <y:description>
      A configuration for group node labels that paints them lying on the group node in isometric space.
    </y:description>
    <y:keywords>
      <y:keyword>configuration</y:keyword>
      <y:keyword>NodeLabel</y:keyword>
      <y:keyword>group</y:keyword>
      <y:keyword>isometry</y:keyword>
      <y:keyword>transform</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.isometry.IsometryGraphTraversal" source="IsometryGraphTraversal.java" executable="false">
    <y:displayname>IsometryGraphTraversal</y:displayname>
    <y:description>
      A <code>Graph2DTraversal</code> that orders the graph elements according to their distance to the observer.
    </y:description>
    <y:keywords>
      <y:keyword>render order</y:keyword>
      <y:keyword>isometry</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.mindmap">
  <y:displayname>Sample: Mind Map</y:displayname>
  <y:displaypriority>16</y:displaypriority>
  <y:summary>Manipulate or create completely new, nice looking mind maps.</y:summary>
  <y:shortDescription>
    Demonstrates how to implement a basic, yet powerful mind map application
    using yFiles for Java.
    Import from and export to FreeMind's native XML format is supported.
    The design follows the suggestions of Tony Buzan, the inventor of mind maps.
  </y:shortDescription>
  <y:description>
    <h1>Mind Map Demo</h1>
    <p>
      Demonstrates how to implement a basic, yet powerful mind map application
      using yFiles for Java.
      Import from and export to FreeMind's native XML format is supported.
      The design follows the suggestions of Tony Buzan, the inventor of mind maps.
    </p>
    <h2>User Interaction</h2>
    <dl>
      <dt>Adding items</dt>
      <dd>
        Either move the mouse over an existing item and click the green plus symbol
        of the overlay controls, or select an existing item and type
        <code>INSERT</code> to add a child item and <code>ENTER</code> to add
        a sibling item.
      </dd>
      <dt>Deleting items</dt>
      <dd>
        Either move the mouse over an existing item and click the red minus symbol
        of the overlay controls, or select an existing item and type
        <code>DELETE</code> or <code>BACKSPACE</code> to remove the selected item
        and all of its children.
      </dd>
      <dt>Expanding and collapsing items</dt>
      <dd>
        Either click on the blue arrow symbol below an item with children or
        select an item with children and type <code>NUMPAD -</code> to collapse the
        item or <code>NUMPAD +</code> to expand the previously collapsed item.
      </dd>
      <dt>Creating cross-references</dt>
      <dd>
        Either move the mouse over an existing item and click the light blue arrow
        symbol or select an existing item, then press and hold <code>SHIFT</code>
        and click on another item or move the mouse over an existing item, press
        and hold <code>SHIFT</code>, then drag the mouse to another item.
      </dd>
      <dt>Editing text</dt>
      <dd>
        Either double-click an existing item or select an existing item and type
        <code>F2</code>.
        Text for cross-references may be added/edited the same way.
      </dd>
      <dt>Changing colors</dt>
      <dd>
        Move the mouse over an existing item and click the multi-colored symbol.
      </dd>
      <dt>Changing icons</dt>
      <dd>
        Move the mouse over an existing item and click the smiley symbol.
        Choosing the crossed out box removes a previously selected icon.
      </dd>
      <dt>Changing the mind map structure</dt>
      <dd>
        Dragging an existing item close to another item will reassign it to a
        new parent item.
        Dragging an existing item away from all other items will delete it once
        the mouse is released.
      </dd>
      <dt>Loading and Saving mind maps</dt>
      <dd>
        Mind maps may be loaded from and saved as GraphML and FreeMind's native
        XML format.
      </dd>
    </dl>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Mind Map Demo</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.mindmap.MindMapDemo" source="MindMapDemo.java">
    <y:displayname>MindMapDemo</y:displayname>
    <y:summary>
      Manipulate or create completely new, nice looking mind maps.
    </y:summary>
    <y:shortDescription>
      Demonstrates how to implement a basic, yet powerful mind map application
      using yFiles for Java.
      Import from and export to FreeMind's native XML format is supported.
      The design follows the suggestions of Tony Buzan, the inventor of mind maps.
    </y:shortDescription>
    <y:description>
      <h2>User Interaction</h2>
      <dl>
        <dt>Adding items</dt>
        <dd>
          Either move the mouse over an existing item and click the green plus symbol
          of the overlay controls, or select an existing item and type
          <code>INSERT</code> to add a child item and <code>ENTER</code> to add
          a sibling item.
        </dd>
        <dt>Deleting items</dt>
        <dd>
          Either move the mouse over an existing item and click the red minus symbol
          of the overlay controls, or select an existing item and type
          <code>DELETE</code> or <code>BACKSPACE</code> to remove the selected item
          and all of its children.
        </dd>
        <dt>Expanding and collapsing items</dt>
        <dd>
          Either click on the blue arrow symbol below an item with children or
          select an item with children and type <code>NUMPAD -</code> to collapse the
          item or <code>NUMPAD +</code> to expand the previously collapsed item.
        </dd>
        <dt>Creating cross-references</dt>
        <dd>
          Either move the mouse over an existing item and click the light blue arrow
          symbol or select an existing item, then press and hold <code>SHIFT</code>
          and click on another item or move the mouse over an existing item, press
          and hold <code>SHIFT</code>, then drag the mouse to another item.
        </dd>
        <dt>Editing text</dt>
        <dd>
          Either double-click an existing item or select an existing item and type
          <code>F2</code>.
          Text for cross-references may be added/edited the same way.
        </dd>
        <dt>Changing colors</dt>
        <dd>
          Move the mouse over an existing item and click the multi-colored symbol.
        </dd>
        <dt>Changing icons</dt>
        <dd>
          Move the mouse over an existing item and click the smiley symbol.
          Choosing the crossed out box removes a previously selected icon.
        </dd>
        <dt>Changing the mind map structure</dt>
        <dd>
          Dragging an existing item close to another item will reassign it to a
          new parent item.
          Dragging an existing item away from all other items will delete it once
          the mouse is released.
        </dd>
        <dt>Loading and Saving mind maps</dt>
        <dd>
          Mind maps may be loaded from and saved as GraphML and FreeMind's native
          XML format.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>mind map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.CollapseButton" source="CollapseButton.java" executable="false">
    <y:displayname>CollapseButton</y:displayname>
    <y:description>
      Hides or unhides children of an item.
    </y:description>
    <y:keywords>
      <y:keyword>button</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>
  
  <y:demo javaname="demo.view.mindmap.FreeMindIOHandler" source="FreeMindIOHandler.java" executable="false">
    <y:displayname>FreeMindIOHandler</y:displayname>
    <y:description>
      Provides methods to import and export FreeMind documents.
      It is tested with FreeMind 0.9.0 and Freeplane 1.2.0.
      It should work for other versions, too, though.
    </y:description>
    <y:keywords>
      <y:keyword>Freemind</y:keyword>
      <y:keyword>Freeplane</y:keyword>
      <y:keyword>Free Mind</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.HoverButton" source="HoverButton.java" executable="false">
    <y:displayname>HoverButton</y:displayname>
    <y:description>This class provides button functionality to manipulate the mind map.</y:description>
    <y:keywords>
      <y:keyword>button</y:keyword>
      <y:keyword>hover</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.KeyboardHandling" source="KeyboardHandling.java" executable="false">
    <y:displayname>KeyboardHandling</y:displayname>
    <y:description>This class provides several actions for keyboard interaction and
      a method to register the actions
    </y:description>
    <y:keywords>
      <y:keyword>keyboard</y:keyword>
      <y:keyword>input</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.LayoutUtil" source="LayoutUtil.java" executable="false">
    <y:displayname>LayoutUtil</y:displayname>
    <y:description>
      Provides utility methods for automatically arranging a mind map.
    </y:description>
    <y:keywords>
      <y:keyword>layout</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.MindMapUtil" source="MindMapUtil.java" executable="false">
    <y:displayname>MindMapUtil</y:displayname>
    <y:description>This class provides static methods to manipulate the mind map</y:description>
    <y:keywords>
      <y:keyword>add item</y:keyword>
      <y:keyword>delete item</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.MindMapRenderer" source="MindMapRenderer.java" executable="false">
    <y:displayname>MindMapRenderer</y:displayname>
    <y:description>
      Renders the elements of a mind map in a specific order.
      This specific rendering order is
      <ol>
      <li>normal edges,</li>
      <li>nodes,</li>
      <li>cross-reference edges, and</li>
      <li>node labels</li>
      </ol>
    </y:description>
    <y:keywords>
      <y:keyword>add item</y:keyword>
      <y:keyword>delete item</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.mindmap.MoveNodeMode" source="MoveNodeMode.java" executable="false">
    <y:displayname>MoveNodeMode</y:displayname>
    <y:description>
      Handles mouse dragged events to rearrange the mind map.
    </y:description>
    <y:keywords>
      <y:keyword>move</y:keyword>
      <y:keyword>drag</y:keyword>
      <y:keyword>drop</y:keyword>
      <y:keyword>Mind Map</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.networkmonitoring">
  <y:displayname>Sample: Network Monitoring</y:displayname>
  <y:displaypriority>19</y:displaypriority>
  <y:summary>Allows to watch and influence the traffic flow through a network.
  </y:summary>
  <y:description>
    <h1>Network Monitoring Demo</h1>
    <p>
    This demo shows a simple network monitoring tool. You can watch the traffic flow through the network
    and even influence the network.
    The network consists of PCs, Laptops, Tablets, Switches, Servers, Databases and W-LANS. The color of the edges
    change from green to yellow to red depending on its traffic load. The traffic load of nodes is shown on their
    info label. Active edges are marked through an animation.
    </p>
    <h2>Things to try</h2>
    <ul>
    <li>Open/Hide Info Label: Every node has an info label. It can be shown and hidden by clicking on the node. It shows
    the name, IP address and traffic load. You can also close it by clicking on the x in the top right corner.
    Remember that info labels are only visible at a detailed zoom level.</li>
    <li>Disable nodes: The info label also contains a power button in the bottom right corner. Clicking on it
    (de)activates the node, preventing it from processing data. This way you can influence the data flow and watch
    what happens.</li>
    <li>Enable Failures: By Clicking on "Enable Failures" you allow failures to happen randomly. Nodes and edges get
    broken and can't process data anymore. Broken elements are marked with a stop sign. If a failure happens on a node
    or edge outside the current viewport, then the viewport will be moved to focus the broken element.
    You can repair elements by clicking on the stop sign. To repair a node, you can also
    open the info label and then click on the green arc arrow at the bottom right corner.</li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Network Monitoring Demo</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.networkmonitoring.NetworkMonitoringDemo" source="NetworkMonitoringDemo.java">
    <y:displayname>Network Monitoring</y:displayname>
    <y:summary>Allows to watch and influence the traffic flow through a network.
    </y:summary>
    <y:shortdescription>
    This demo shows a simple network monitoring tool. You can watch the traffic flow through the network
    and even influence the network.
    The network consists of PCs, Laptops, Tablets, Switches, Server, Databases and W-LANS. The color of the edges
    change from green to yellow to red depending on its traffic load. The traffic load of nodes is shown on their
    info label. Active edges are marked through an animation.
    </y:shortdescription>

    <y:description>
    <h2>Things to try</h2>
    <ul>
    <li>Open/Hide Info Label: Every node has an info label. It can be shown and hidden by clicking on the node. It shows
    the name, IP address and traffic load. You can also close it by clicking on the x in the top right corner.
    Remember that info labels are only visible at a detailed zoom level.</li>
    <li>Disable nodes: The info label also contains a power button in the bottom right corner. Clicking on it
    (de)activates the node, preventing it from processing data. This way you can influence the data flow and watch
    what happens.</li>
    <li>Enable Failures: By Clicking on "Enable Failures" you allow failures to happen randomly. Nodes and edges get
    broken and can't process data anymore. Broken elements are marked with a stop sign. If a failures happens on a node
    or edge outside the current viewport, then the viewport will be moved to focus the broken element.
    You can repair elements by clicking on the stop sign. To repair a node, you can also
    open the info label and then click on the green arc arrow at the bottom right corner.</li>
     </ul>
    </y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>


  <y:demo javaname="demo.view.networkmonitoring.NetworkData" source="NetworkData.java" executable="false">
    <y:displayname>NetworkData</y:displayname>
    <y:description>Network data for a network node or a connection as seen by the view.</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkInfoLabelPainter" source="NetworkInfoLabelPainter.java" executable="false">
    <y:displayname>NetworkInfoLabelPainter</y:displayname>
    <y:description>Paints an info label that displays a label text and additional buttons on a bubble shaped background.
    </y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkConnectionPainter" source="NetworkConnectionPainter.java" executable="false">
    <y:displayname>NetworkConnectionPainter</y:displayname>
    <y:description>A painter that paints network connections.</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkInteractionMode" source="NetworkInteractionMode.java" executable="false">
    <y:displayname>NetworkInteractionMode</y:displayname>
    <y:description>ViewMode to disable, enable or repair network nodes and edges.</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkModel" source="NetworkModel.java" executable="false">
    <y:displayname>NetworkModel</y:displayname>
    <y:description>Interface for a network model</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkModelImpl" source="NetworkModelImpl.java" executable="false">
    <y:displayname>NetworkModelImpl</y:displayname>
    <y:description> This is an elementary network model that creates consistent data load.
     In this model, PCs generate data. Data is sent between nodes without a specific target.
     The nodes behave differently:
     <ul>
              <li>Switches and W-LANs route data to the least busy node.</li>
     <li>Server and databases send (maybe more) data back to the node who send him data.</li>
     <li>PCs, Laptops and Tablets generate data and are the only target for data</li>
            </ul>
          </y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkModelObserver" source="NetworkModelObserver.java" executable="false">
    <y:displayname>NetworkModelObserver</y:displayname>
    <y:description>Interface for NetworkModel observer</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkMonitoringFactory" source="NetworkMonitoringFactory.java" executable="false">
    <y:displayname>NetworkMonitoringFactory</y:displayname>
    <y:description>Factory class that provides realizer configurations for network nodes and connections.
     Also provides color constants and the warning icon.</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkNodeInfo" source="NetworkNodeInfo.java" executable="false">
    <y:displayname>NetworkNodeInfo</y:displayname>
    <y:description>Contains the name and ip address of a network node</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkNodePainter" source="NetworkNodePainter.java" executable="false">
    <y:displayname>NetworkNodePainter</y:displayname>
    <y:description>A painter that paints a network node either in enabled or disabled state.</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.networkmonitoring.NetworkView" source="NetworkView.java" executable="false">
    <y:displayname>NetworkView</y:displayname>
    <y:description>The network view creates a view graph and updates it every time the state of elements in the
      model graph changes.</y:description>
    <y:keywords>
      <y:keyword>network monitoring</y:keyword>
      <y:keyword>network</y:keyword>
      <y:keyword>monitoring</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.orgchart">
  <y:displayname>Sample: Organization Chart</y:displayname>
  <y:displaypriority>20</y:displaypriority>
  <y:summary>View and manipulate an organization chart</y:summary>
  <y:shortDescription>
    All your staff neatly arranged gives you a clear overview of your company, helping you to run your business.
    Need to reorganize your company? <br/>
    Try it first in the organization chart and see, if it fit your needs.<br/>
    This is a great example how to use many of the yFiles features with little code to create a powerful application.
  </y:shortDescription>
  <y:description>
    <h1>How to use</h1>
    <h2>Navigation</h2>
    <ul>
      <li>Mouse Navigation: Use the mouse wheel to zoom and the right mouse button to drag the chart. A left click
        select an employee both in the graph and the tree chart, double clicking will zomm into the employee.
        When pressing the middle button, a magnifier is shown.
      </li>
      <li>Tree chart navigation: Select an employee in the tree chart to focus him in the graph</li>
      <li>View Options: Switch between global view and local view to see all employees or only the selected
        with his direct subordinates. You can also show the colleagues in the local view by activating
        "Show Colleagues". By activating "Show Business Units" the business units are shown using group nodes.
      </li>
    </ul>
    <h2>Manipulating</h2>
    <ul>
      <li>Add Employee: Click on an employee and then on the plus icon.</li>
      <li>Delete Employee: Click on an employee and then on the trash bin.</li>
      <li>Move Employee: There are three modes to move an employee: Move only the employee,
        move employee with all subordinates or to move an employee and his assistants.
        To move, click on one of the four-way-arrows. The on with an star is moving with all subordinates,
        the one with an plus is moving with all assistans. If you drag the employee without pressing a
        button, you move the employee without the subordinates.
      </li>
      <li>Collapse/Expand: Use the arrow buttons on the left to collapse/expand parents (and their children)
        and the arrows on the right to collapse/expand children. Collapsing and expanding is done layer by
        layer.
      </li>
      <li>Edit Properties: To change an employees properties, select the employee and directly edit the properties
        in the properties table in the bottom left corner.
      </li>
    </ul>

    <h2>Key Bindings</h2>
    <p>To use keyboard navigation the chart needs to have the focus.</p>
    <ul>
      <li>Arrow Keys: Moves the diagram to the left, right, up and down.</li>
      <li>CTRL + Arrow Key: Selects a node to the left, right, up or down of the currently selected node</li>
      <li>+ / - Key: Zoom in or out</li>
      <li>Enter: When in
        <b>Global View</b>
        mode, zoom in on the selected node. When in
        <b>Local View</b>
        mode, the selected node will
        become the new central element of the local view.
      </li>
    </ul>

    <h2>Overview</h2>
    <ul>
      <li>Mouse Drag highlighted region: Move the diagram in the main view</li>
      <li>Mouse Drag corner of highlighted region: Change zoom level of the main view</li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Orgchart Demo</y:keyword>
    <y:keyword>organization chart</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>


  <y:demo javaname="demo.view.orgchart.OrgChartDemo" source="OrgChartDemo.java">
    <y:displayname>Organization Chart</y:displayname>
    <y:summary>View and manipulate an organization chart.</y:summary>
    <y:shortDescription>
      All your staff neatly arranged gives you a clear overview of your company, helping you to run your business.
      Need to reorganize your company? <br/>
      Try it first in the organization chart and see, if it fit your needs.<br/>
      This is a great example how to use many of the yFiles features with little code to create a powerful application.
    </y:shortDescription>
    <y:description>
      <h1>How to use</h1>
      <h2>Navigation</h2>
      <ul>
        <li>Mouse Navigation: Use the mouse wheel to zoom and the right mouse button to drag the chart. A left
          click
          select an employee both in the graph and the tree chart, double clicking will zomm into the employee.
          When pressing the middle button, a magnifier is shown.
        </li>
        <li>Tree chart navigation: Select an employee in the tree chart to focus him in the graph</li>
        <li>View Options: Switch between global view and local view to see all employees or only the selected
          with his direct subordinates. You can also show the colleagues in the local view by activating
          "Show Colleagues". By activating "Show Business Units" the business units are shown using group nodes.
        </li>
      </ul>
      <h2>Manipulating</h2>
      <ul>
        <li>Add Employee: Click on an employee and then on the plus icon.</li>
        <li>Delete Employee: Click on an employee and then on the trash bin.</li>
        <li>Move Employee: There are three modes to move an employee: Move only the employee,
          move employee with all subordinates or to move an employee and his assistants.
          To move, click on one of the four-way-arrows. The on with an star is moving with all subordinates,
          the one with an plus is moving with all assistans. If you drag the employee without pressing a
          button, you move the employee without the subordinates.
        </li>
        <li>Collapse/Expand: Use the arrow buttons on the left to collapse/expand parents (and their children)
          and the arrows on the right to collapse/expand children. Collapsing and expanding is done layer by
          layer.
        </li>
        <li>Edit Properties: To change an employees properties, select the employee and directly edit the
          properties
          in the properties table in the bottom left corner.
        </li>
      </ul>

      <h2>Key Bindings</h2>
      <p>To use keyboard navigation the chart needs to have the focus.</p>
      <ul>
        <li>Arrow Keys: Moves the diagram to the left, right, up and down.</li>
        <li>CTRL + Arrow Key: Selects a node to the left, right, up or down of the currently selected node</li>
        <li>+ / - Key: Zoom in or out</li>
        <li>Enter: When in
          <b>Global View</b>
          mode, zoom in on the selected node. When in
          <b>Local View</b>
          mode, the selected node will
          become the new central element of the local view.
        </li>
      </ul>

      <h2>Overview</h2>
      <ul>
        <li>Mouse Drag highlighted region: Move the diagram in the main view</li>
        <li>Mouse Drag corner of highlighted region: Change zoom level of the main view</li>
      </ul>
    </y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>


  <y:demo javaname="demo.view.orgchart.OrgChartTreeModel" source="OrgChartTreeModel.java" executable="false">
    <y:displayname>OrgChartTreeModel</y:displayname>
    <y:description>TreeModel that uses Employee as TreeNodes</y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.orgchart.JOrgChart" source="JOrgChart.java" executable="false">
    <y:displayname>JOrgChart</y:displayname>
    <y:description>Organization chart component that builds upon the more generic tree chart component<code>
      demo.view.orgchart.JTreeChart</code>.
      It visualizes a<code>demo.view.orgchart.OrgChartTreeModel</code>. Also it customizes the look and feel of the
      component to make it suitable for
      organization charts. TreeModel that uses Employee as TreeNodes
    </y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.orgchart.JTreeChart" source="JTreeChart.java" executable="false">
    <y:displayname>JTreeChart</y:displayname>
    <y:description>Tree chart component that allows to display local views of the tree.
    </y:description>
    <y:keywords>
      <y:keyword>organization chart</y:keyword>
      <y:keyword>orgchart</y:keyword>
      <y:keyword>TreeModel</y:keyword>
      <y:keyword>Scroller</y:keyword>
      <y:keyword>JTree</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.orgchart.KeyboardNavigation" source="KeyboardNavigation.java" executable="false">
    <y:displayname>KeyboardNavigation</y:displayname>
    <y:description>Factory class that provides
      <code>java.awt.event.KeyListener</code>
      implementations suitable for
      navigating within Graph2DView.
    </y:description>
    <y:keywords>
      <y:keyword>keyboard</y:keyword>
      <y:keyword>keyboard navigation</y:keyword>
      <y:keyword>KeyListener</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>
</y:package>
      <y:package javaname="demo.view.realizer">
  <y:displayname>Nodes and Edges</y:displayname>
  <y:displaypriority>100</y:displaypriority>
  <y:summary>Working with node and edge realizers</y:summary>
  <y:description>
    <h1>yFiles Tutorial Realizer Demos</h1>
    <p>
      The following tutorial demos describe how to use, customize, and extend
      diverse NodeRealizer and EdgeRealizer classes.
      Among other user interface aspects, a realizer defines the way a graph element
      is rendered.
    </p>
    <p>
      <b>Note:</b> Except for the implementation of <code>demo.view.realizer.StateNodeRealizer</code>,
      all classes listed here are also executable.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Realizer Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.realizer.VisualFeatureDemo" source="VisualFeatureDemo.java">
    <y:displayname>Realizers Visual Features</y:displayname>
    <y:summary>Presents the visual features that are available with node realizers and edge realizers</y:summary>
    <y:description>
      Demonstrates visual features and editor behaviour
      <ol>
      <li>EdgeLabels that display icons and text<br/>
              </li>
      <li>Rotated Labels<br/>
              </li>
      <li>Auto rotating EdgeLabels
      <br/>
              </li>
      <li>Transparent colors
      <br/>
              </li>
      <li>Gradients
      <br/>
              </li>
      <li>Bridges for crossing PolyLine Edges
      <br/>
              </li>
      <li>InterfacePorts that display icons. (A port defines the logical and visual endpoint of and edge path)
      <br/>
              </li>
      <li>In edit mode you can reposition an edge label by pressing on it with the left mouse button and then by dragging
      the label around. For better orientation some edges provide snap lines with suitable label positions. The snap
      lines disappear, if the shift key is pressed down. Then the placement of labels at arbitrary positions is possible.
      <br/>
              </li>
      <li>In edit mode you can interactively change the offsets of edge ports. Select the edge that should have different
      ports. A little black dot will appear at the point where the port has it's logical location. You can drag the black
      dot around. If you release the mouse again the offset of the port will be changed.
      <br/>
              </li>
      <li>In edit mode you can create an edge that has non-zero port offsets by starting edge creation with the shift key
      pressed down. The point where you press will become the source port location of the edge. If you have the shift key
      down when you finish edge creation (by releasing the mouse over a node) that the release point will become the offset
      of the target port of the edge.
      <br/>
              </li>
      </ol>
    </y:description>
    <y:keywords>
      <y:keyword>label</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>image</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>decoration</y:keyword>
      <y:keyword>color</y:keyword>
      <y:keyword>shape</y:keyword>
      <y:keyword>bridge</y:keyword>
      <y:keyword>transparent</y:keyword>
      <y:keyword>gradient</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.GenericNodeRealizerDemo" source="GenericNodeRealizerDemo.java">
    <y:displayname>Generic Node Realizer</y:displayname>
    <y:summary>This class demonstrates the usage of the GenericNodeRealizer to provide customized node rendering</y:summary>
    <y:description>
      This class demonstrates the usage of the <code>y.view.GenericNodeRealizer</code>
      class which makes it easy to provide customized node rendering.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>GenericNodeRealizer</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>hotspot</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.GenericEdgeRealizerDemo" source="GenericEdgeRealizerDemo.java">
    <y:displayname>Generic Edge Realizer</y:displayname>
    <y:summary>This class demonstrates the usage of the GenericEdgeRealizer class to provide customized edge rendering</y:summary>
    <y:description>
      <p>
      This class demonstrates the usage of the <code>y.view.GenericEdgeRealizer</code>
      class which makes it easy to provide customized edge rendering.
      </p>
      <p>
        <b>Usage:</b> Try adding new edges and adding bends to existing edges.
        The list on the left side allows to switch between the possible edge types for creating new edges.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>GenericEdgeRealizer</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.YLabelConfigurationDemo" source="YLabelConfigurationDemo.java">
    <y:displayname>YLabel Configuration</y:displayname>
    <y:summary>This class demonstrates the usage of YLabel's configuration feature which simplifies customized label rendering</y:summary>
    <y:description>
      This class demonstrates the usage of YLabel's configuration feature which simplifies
      customized label rendering.
      <br/>
      Things to try: move nodes around, move node/edge labels around, select a node/edge
      and press F2 to edit the label, insert/move bends of edges.
    </y:description>
    <y:keywords>
      <y:keyword>label</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>YLabel</y:keyword>
      <y:keyword>cropping</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.TableStyleDemo" source="TableStyleDemo.java">
    <y:displayname>Table Styles</y:displayname>
    <y:summary>Demonstrates different visual styles for table groups and their content</y:summary>
    <y:description>
      Demonstrates different visual styles for table groups and their content.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>TableGroupNodeRealizer</y:keyword>
      <y:keyword>TableNodePainter</y:keyword>
      <y:keyword>TableStyle</y:keyword>
      <y:keyword>PortConstraint</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.SwingRendererDemo" source="SwingRendererDemo.java">
    <y:displayname>Swing Components</y:displayname>
    <y:summary>This class shows how to customize GenericNodeRealizer to display JComponents as nodes</y:summary>
    <y:description>
      This class shows how to customize GenericNodeRealizer to display JComponents as nodes.
    </y:description>
    <y:keywords>
      <y:keyword>Swing</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>JComponent</y:keyword>
      <y:keyword>GenericNodeRealizer</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.UMLClassNodeRealizer" source="UMLClassNodeRealizer.java">
    <y:displayname>UML Class Node Realizer</y:displayname>
    <y:summary>Node Realizer with an UML class look</y:summary>
    <y:description>
      This class represents a custom NodeRealizer that can be used to
      represent a class in an UML diagram. It supports classname, sterotype,
      constraint, attribute list, and method list.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>class</y:keyword>
      <y:keyword>UML</y:keyword>
      <y:keyword>classname</y:keyword>
      <y:keyword>SmartNodeLabelModel</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.BridgeEdgeRealizerDemo" source="BridgeEdgeRealizerDemo.java">
    <y:displayname>Bridge Edge Realizer</y:displayname>
    <y:summary>This class demonstrates how to implement a custom EdgeRealizer that shows bridges/gaps when crossing other edges</y:summary>
    <y:description>
      This class demonstrates how to implement a custom EdgeRealizer that shows
      bridges/gaps when crossing other edges.<br/>
      Usage: Hit one of the two buttons "Gap Style" and "Arc Style" to change how edge crossings are displayed. If
      edges are selected, the style is only applied to these edges. To change all edge styles at the same time,
      select either all or no edges.
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>bridge</y:keyword>
      <y:keyword>gap</y:keyword>
      <y:keyword>crossing</y:keyword>
      <y:keyword>custom painter</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.StateNodeRealizer" source="StateNodeRealizer.java" executable="false">
    <y:displayname>State Node Realizer</y:displayname>
    <y:summary>This demo shows how the custom node realizer StateNodeRealizer can be used within an application</y:summary>
    <y:description>
      Realizer showcased by demo <code>StateNodeRealizerDemo</code>.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>paint</y:keyword>
      <y:keyword>customization</y:keyword>
      <y:keyword>serialization</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.realizer.StateNodeRealizerDemo" source="StateNodeRealizerDemo.java">
    <y:displayname>State Node Realizer</y:displayname>
    <y:summary>This demo shows how the custom node realizer StateNodeRealizer can be used within an application</y:summary>
    <y:description>
      This demo shows how the custom node realizer <code>StateNodeRealizer</code>
      can be used within an application.
      <br/>
      The demo allows to create nodes that have different state.
      Additionally it is possible to change the state of a node by either right clicking
      or left double clicking on it.
      on it.
      A graph with its custom node realizers can be saved and loaded using the GraphML
      format.
    </y:description>
    <y:keywords>
      <y:keyword>node</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>paint</y:keyword>
      <y:keyword>customization</y:keyword>
      <y:keyword>double click</y:keyword>
      <y:keyword>right click</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.rendering">
  <y:displayname>Renderers</y:displayname>
  <y:displaypriority>50</y:displaypriority>
  <y:summary>Advanced rendering aspects like background rendering or bridge calculators</y:summary>
  <y:description>
    <h1>yFiles Tutorial View Rendering Demos</h1>
    <p>
    The following tutorial demos center around advanced rendering aspects of the graph view.
    It is shown how to use auxiliary rendering classes <code>Drawable</code>,
    <code>BackgroundRenderer</code>, and <code>BridgeCalculator</code>.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>Rendering Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.rendering.BridgeDemo" source="BridgeDemo.java">
    <y:displayname>Overlap Edge Bridges</y:displayname>
    <y:summary>Demonstrates how to utilize BridgeCalculator to draw bridges or gaps for crossing edges.</y:summary>
    <y:description>
      Demonstrates how to utilize <code>BridgeCalculator</code> to draw bridges or gaps
      for crossing edges.
    </y:description>
    <y:keywords>
      <y:keyword>bridge</y:keyword>
      <y:keyword>BridgeCalculator</y:keyword>
      <y:keyword>gap</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>cross</y:keyword>
      <y:keyword>crossing</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.rendering.BackgroundDemo" source="BackgroundDemo.java">
    <y:displayname>Background Images</y:displayname>
    <y:summary>Demonstrates how to use background images in the view</y:summary>
    <y:description>
      <p>
      Demonstrates how to use background images in the view.
      </p>
      <p>
      <b>Usage:</b> Create some nodes and try the different background settings available
      via the toolbar button. Try changing the window size, zooming in and out and
      moving the view port by right dragging.
      </p>

      <h3>Third Party Licenses:</h3>
      <p>
        The USA map that is used as background in this demo is based on
        <a href="http://commons.wikimedia.org/wiki/File:Blank_US_Map.svg">Blank_US_Map.svg by Theshibboleth</a>
        and licensed under the
        <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported</a>
        license.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>background</y:keyword>
      <y:keyword>render</y:keyword>
      <y:keyword>rendering</y:keyword>
      <y:keyword>BackgroundRenderer</y:keyword>
      <y:keyword>image</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.rendering.DrawablesDemo" source="DrawablesDemo.java">
    <y:displayname>Drawables</y:displayname>
    <y:summary>This demo shows how to add objects of type Drawable to a Graph2DView</y:summary>
    <y:description>
      This demo shows how to add objects of type Drawable to
      a Graph2DView and how to implement such a Drawable object.
      Drawables represent graphical objects that can be displayed
      by a Graph2DView. The main purpose of Drawables is to highlight
      certain regions of the displayed graph.
      <br/>
      The Drawable implemented in this demo draws itself as a box
      drawn underneath the displayed graph. The size and location of the box changes
      dynamically as the bounding box of the graph changes.
    </y:description>
    <y:keywords>
      <y:keyword>Drawable</y:keyword>
      <y:keyword>Graph2DView</y:keyword>
      <y:keyword>implementation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.rendering.LevelOfDetailDemo" source="LevelOfDetailDemo.java">
    <y:displayname>Level Of Detail Rendering</y:displayname>
    <y:summary>Demonstrates how to control the level of detail for graph visualization using rendering hints</y:summary>
    <y:description>
      Demonstrates how to control the level of detail for graph visualization
      using rendering hints.
      The following hints can be set (or unset):
      <ul>
      <li>
                <code>y.view.YRenderingHints.KEY_GROUP_STATE_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_EDGE_LABEL_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_NODE_LABEL_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_NODE_PORT_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_GRADIENT_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_SELECTION_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_SHADOW_PAINTING</code>
              </li>
      <li>
                <code>y.view.ShapeNodeRealizer.KEY_SLOPPY_RECT_PAINTING</code>
              </li>
      <li>
                <code>y.view.YRenderingHints.KEY_SLOPPY_POLYLINE_PAINTING</code>
              </li>
      </ul>
      <h2>Motivation</h2>
      <p>
        yFiles for Java provides two complementary techniques to control the level of
        detail for graph visualization.
        EdgeRealizer's and NodeRealizer's
        <code>paint</code> and <code>paintSloppy</code> methods provide
        coarse-grained control while rendering hints allow for fine-grained control
        over rendering details.
        For example, it is possible to ignore selection states and/or group
        state icons when exporting to images.
        Another use case would be an overview that provides more details than
        standard sloppy rendering but still omits expensive features like text or
        drop shadows.
      </p>

      <h2>Settings</h2>
      <h3>Level of Detail</h3>
      <p>
        Determines the view's rendering mode.
      </p>
      <dl>
        <dt>Depends on zoom</dt>
        <dd>
          Depending on the view's zoom level, either
          <code>paint</code> or <code>paintSloppy</code> is used to render graph
          elements.
        </dd>
        <dt>Always detailed</dt>
        <dd>
          The view always uses <code>paint</code> for rendering.
        </dd>
        <dt>Always sloppy</dt>
        <dd>
          The view always uses <code>paintSloppy</code> for rendering.
        </dd>
      </dl>
      <h3>Rendering Hints</h3>
      <dl>
        <dt>Group state painting</dt>
        <dd>
          Determines whether or not <code>[+]</code>/<code>[-]</code> symbols for
          group and/or folder nodes are displayed.
        </dd>
        <dt>Edge label painting</dt>
        <dd>
          Determines whether or not labels of edges are displayed.
        </dd>
        <dt>Node label painting</dt>
        <dd>
          Determines whether or not labels of nodes are displayed.
        </dd>
        <dt>Node port painting</dt>
        <dd>
          Determines whether or not ports of nodes are displayed.
        </dd>
        <dt>Gradient painting</dt>
        <dd>
          If disabled, flat colors are used instead of gradient paints.
        </dd>
        <dt>Selection painting</dt>
        <dd>
          If disabled, selected elements are no longer "highlighted", e.g. resize
          handles for nodes (so-called <em>hot spots</em>) are no longer displayed.
        </dd>
        <dt>Shadow painting</dt>
        <dd>
          If disabled, drop shadows are no longer displayed.
        </dd>
        <dt>Sloppy rect painting</dt>
        <dd>
          If disabled, <code>y.view.ShapeNodeRealizer</code> will use its actual
          shape instead of its rectangular bounds for sloppy rendering.
        </dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>lod</y:keyword>
      <y:keyword>level of detail</y:keyword>
      <y:keyword>rendering</y:keyword>
      <y:keyword>hint</y:keyword>
      <y:keyword>hints</y:keyword>
      <y:keyword>rendering hint</y:keyword>
      <y:keyword>rendering hints</y:keyword>
      <y:keyword>sloppy</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.uml">
  <y:displayname>Sample: UML Class Editor</y:displayname>
  <y:displaypriority>18</y:displaypriority>
  <y:summary>Allows to visualize and edit UML class diagrams.</y:summary>
  <y:description>
    <h1>UML Class Editor</h1>
    <p>
    This demo allows you to visualize and edit UML class diagrams. It shows how to
    </p>
    <ul>
      <li>
        create a configuration for <code>GenericNodeRealizer</code> that
        provides interactive buttons to show or hide parts of the node and to
        add or remove labels.
      </li>
      <li>load and save the customized node realizer.</li>
      <li>use <code>Drawable</code>s to display interactive buttons that invoke edge creation.</li>
      <li>animate the appearance and disappearance of the buttons.</li>
      <li>write a customized <code>EditMode</code> that handles mouse interactions with buttons.</li>
      <li>add a layout action that calculates a layout adjusted to UML diagrams.</li>
      <li>route edges incrementally after graph changes.</li>
    </ul>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>UML Class Editor</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.uml.UmlDemo" source="UmlDemo.java">
    <y:displayname>UML Class Editor</y:displayname>
    <y:summary>Allows to visualize and edit UML class diagrams.</y:summary>
    <y:shortdescription>
      yFiles for Java offers a powerful and highly customizable viewer framework. This demo shows how you can use it to
      create an interactive UML class editor. The representation of the classes and their connections have been
      implemented with the help of so-called realizer. With them you can create any interactive user interface controls.
      A class provides buttons to show or hide class sections and buttons to add or remove attributes and operations.
      The integrated animation framework also provides the possibility to animate these controls. For example if the
      cursor hovers above a class, additional buttons fade in with which you can connect this class with another one.
    </y:shortdescription>
    <y:description>
      <p>
      The demo allows you to visualize and edit UML class diagrams.
      </p>

      <h2>Interaction</h2>
      <p>
      Moving the mouse over a node makes several buttons for node editing and edge creation appear.
      </p>

      <h3>Node Editing</h3>
      <dl>
        <dt>Left Click on Background</dt>
        <dd>Creates a node.</dd>
        <dt>Left Click on Button in upper-right Corner</dt>
        <dd>Hides/shows attributes and operations.</dd>
        <dt>Left Click on Plus left of Attributes/Operations</dt>
        <dd>Hides/shows attributes or operations, respectively.</dd>
        <dt>Left Click on Plus right of Attributes/Operations</dt>
        <dd>Adds an attribute or an operation, respectively.</dd>
        <dt>Left Click on Minus right of Attributes/Operations</dt>
        <dd>Removes the selected attribute or operation, respectively.</dd>
      </dl>

      <h3>Edge Creation</h3>
      <dl>
        <dt>Left Click on Edge Creation Button</dt>
        <dd>Starts new edge that can be connected to an existing node.</dd>
        <dt>Left Drag on Edge Creation Button</dt>
        <dd>
          Starts new edge with a new target node. If this node is dropped onto an existing node, only the edge will be
          added to the diagram. Otherwise, also the node is added.
        </dd>
      </dl>

      <h3>Zoom</h3>
      <dl>
        <dt>Mouse Wheel</dt>
        <dd>Changes the zoom level of the view.</dd>
      </dl>

      <h2>Layout</h2>
      <dl>
        <dt>Hitting the layout button</dt>
        <dd>Applies an orthogonal layout to the current diagram.</dd>
        <dt>Changing the diagram</dt>
        <dd>Routes affected edges orthogonally.</dd>
      </dl>
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>DirectedOrthogonalLayouter</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>PortConstraints</y:keyword>
      <y:keyword>EdgeRouter</y:keyword>
      <y:keyword>GraphMLIOHandler</y:keyword>
      <y:keyword>morphing</y:keyword>
      <y:keyword>fade</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlEditMode" source="UmlEditMode.java" executable="false">
    <y:displayname>UmlEditMode</y:displayname>
    <y:description>
      A customized <code>EditMode</code> that also handles animated edge creation buttons.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>child mode</y:keyword>
      <y:keyword>setChild</y:keyword>
      <y:keyword>drawable</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>GraphListener</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlEdgeCreationButtons" source="UmlEdgeCreationButtons.java" executable="false">
    <y:displayname>UmlEdgeCreationButtons</y:displayname>
    <y:description>
      A <code>Drawable</code> that displays circular, zoom-independent edge creation buttons that can be animated.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>drawable</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>GraphListener</y:keyword>
      <y:keyword>selection</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlRealizerFactory" source="UmlRealizerFactory.java" executable="false">
    <y:displayname>UmlRealizerFactory</y:displayname>
    <y:description>
      A <code>Factory</code> that provides methods to create node realizers, edge realizers and to access custom
      properties of the realizers.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>realizer</y:keyword>
      <y:keyword>property</y:keyword>
      <y:keyword>properties</y:keyword>
      <y:keyword>constants</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlCreateEdgeMode" source="UmlCreateEdgeMode.java" executable="false">
    <y:displayname>UmlCreateEdgeMode</y:displayname>
    <y:description>
      A <code>ViewMode</code> that creates a new edge with a target node when dragging.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>node</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassConfiguration" source="UmlClassConfiguration.java" executable="false">
    <y:displayname>UmlClassConfiguration</y:displayname>
    <y:description>
      A custom configuration for a UML class node that paints a class node with buttons to edit the node.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>configuration</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>MouseInputEditorProvider</y:keyword>
      <y:keyword>painter</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassButton" source="UmlClassButton.java" executable="false">
    <y:displayname>UmlClassButton</y:displayname>
    <y:description>
      An abstract class for interaction with and painting of a button of a class node.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>MouseInputEditor</y:keyword>
      <y:keyword>button</y:keyword>
      <y:keyword>paint</y:keyword>
      <y:keyword>interaction</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassOpenCloseClassButton" source="UmlClassOpenCloseClassButton.java" executable="false">
    <y:displayname>UmlClassOpenCloseClassButton</y:displayname>
    <y:description>
      A button of class node that shows or hides the attributes and operations area when clicked.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>MouseInputEditor</y:keyword>
      <y:keyword>button</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassOpenCloseSectionButton" source="UmlClassOpenCloseSectionButton.java" executable="false">
    <y:displayname>UmlClassOpenCloseSectionButton</y:displayname>
    <y:description>
      A button of class node that shows or hides the attributes area or the operations area, respectively, when clicked.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>MouseInputEditor</y:keyword>
      <y:keyword>button</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassAddItemButton" source="UmlClassAddItemButton.java" executable="false">
    <y:displayname>UmlClassAddItemButton</y:displayname>
    <y:description>
      A button of class node that adds a label to the attributes list or the operations list, respectively, when
      clicked.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>MouseInputEditor</y:keyword>
      <y:keyword>button</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassRemoveItemButton" source="UmlClassRemoveItemButton.java" executable="false">
    <y:displayname>UmlClassRemoveItemButton</y:displayname>
    <y:description>
      A button of class node that removes a label from the attributes list or the operations list, respectively, when
      clicked.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>MouseInputEditor</y:keyword>
      <y:keyword>button</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>animation</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassAnimation" source="UmlClassAnimation.java" executable="false">
    <y:displayname>UmlClassAnimation</y:displayname>
    <y:description>
      Animates opening and closing in a class node. That way, when a button is pressed to open or close the node, one of
      its sections or also when adding or removing a label, the node's size will change smoothly.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>layout</y:keyword>
      <y:keyword>edge router</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassLabelPainter" source="UmlClassLabelPainter.java" executable="false">
    <y:displayname>UmlClassLabelPainter</y:displayname>
    <y:description>
      A label painter that does not paint selection marks when a label is selected.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>painter</y:keyword>
      <y:keyword>selection</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassLabelEditMode" source="UmlClassLabelEditMode.java" executable="false">
    <y:displayname>UmlClassLabelViewMode</y:displayname>
    <y:description>
      A <code>ViewMode</code> that opens a label editor when a label is double-clicked and shows a selection background
      for the selected label while the mouse is over the node.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>editor</y:keyword>
      <y:keyword>selection</y:keyword>
      <y:keyword>ViewMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassLabelSupport" source="UmlClassLabelSupport.java" executable="false">
    <y:displayname>UmlClassLabelSupport</y:displayname>
    <y:description>
      A class that provides methods to change the model and update the labels in a class node.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>model</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassModel" source="UmlClassModel.java" executable="false">
    <y:displayname>UmlClassModel</y:displayname>
    <y:description>
      The model of a class node consisting of the name of the class and lists of attributes and operations.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>model</y:keyword>
      <y:keyword>user data</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.uml.UmlClassModelIOHandler" source="UmlClassModelIOHandler.java" executable="false">
    <y:displayname>UmlClassModelIOHandler</y:displayname>
    <y:description>
      A <code>GraphMLIOHandler</code> that serializes and deserializes the <code>UmlClassModel</code> stored as user
      data of the node realizer representing an UML class.
    </y:description>
    <y:keywords>
      <y:keyword>uml</y:keyword>
      <y:keyword>model</y:keyword>
      <y:keyword>user data</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
      <y:package javaname="demo.view.viewmode">
  <y:displayname>User Interaction</y:displayname>
  <y:displaypriority>90</y:displaypriority>
  <y:summary>Working with View Mode classes</y:summary>
  <y:description>
    <h1>yFiles Tutorial ViewMode Demos</h1>
    <p>
      The following tutorial demos describe how to use, customize, and extend
      diverse ViewMode classes. View modes provide the base functionality to handle
      mouse-based interaction that happens in a view.
    </p>
  </y:description>
  <y:keywords>
    <y:keyword>Graph Viewer Demos</y:keyword>
    <y:keyword>ViewMode Demos</y:keyword>
    <y:keyword>View Demos</y:keyword>
  </y:keywords>

  <y:demo javaname="demo.view.viewmode.MagnifierViewModeDemo" source="MagnifierViewModeDemo.java">
    <y:displayname>Magnifying Glass</y:displayname>
    <y:summary>Demonstrates how to use a magnifying glass effect to zoom view regions locally</y:summary>
    <y:description>
      <p>
      Demonstrates how to use a magnifying glass effect to zoom view regions locally.
      </p>
      <p>
      <b>Usage:</b> To activate the magnifier select the "Use Magnifier" button. Move the mouse
      over the view canvas to move the magnifier. Note that you can even edit the graph
      while the magnifier is active. Use the mouse wheel to change the zoom factor of the
      magnifier. To change the radius of the magnifier with the mouse wheel, additionally
      keep the <code>Ctrl</code> pressed. To deactivate the magnifier again, deselect the
      "Use Magnifier" button.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>magnify</y:keyword>
      <y:keyword>magnifying</y:keyword>
      <y:keyword>glass</y:keyword>
      <y:keyword>tool</y:keyword>
      <y:keyword>zoom</y:keyword>
      <y:keyword>region</y:keyword>
      <y:keyword>local</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.FullScreenNavigationDemo" source="FullScreenNavigationDemo.java">
    <y:displayname>Full Screen Navigation</y:displayname>
    <y:summary>How to use the NavigationComponent and Overview to controll the view</y:summary>
    <y:description>
      This demo demonstrates the usage of y.view.NavigationComponent and y.view.Overview. Both controls
      will be added to a glass pane the view provides (y.view.Graph2DView#getGlassPane()) and can be toggled during
      runtime.
      <br/>
      Besides one can switch to a full screen mode and navigate through the graph view.
    </y:description>
    <y:keywords>
      <y:keyword>full-screen</y:keyword>
      <y:keyword>full</y:keyword>
      <y:keyword>navigation</y:keyword>
      <y:keyword>screen</y:keyword>
      <y:keyword>NavigationComponent</y:keyword>
      <y:keyword>control</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.OrthogonalEdgeViewModeDemo" source="OrthogonalEdgeViewModeDemo.java">
    <y:displayname>Orthogonal Edge Edit Mode</y:displayname>
    <y:summary>Demonstrates how to customize EditMode in order to simulate orthogonal edges</y:summary>
    <y:description>Demonstrates how to customize EditMode in order to simulate orthogonal edges.
      <br/>
      This demo allows to switch between the creation of orthogonal and polygonal edges and toggling snapping behavior
      on and off.
      Toggling the "Orthogonal" button in the toolbar switches the type of newly created edges.
      Also intelligent snapping for the various view modes can be toggled in the tool bar.
      This affects the behavior of CreateEdgeMode and EditMode, as well as implicitly the minor modes
      of EditMode.
    </y:description>
    <y:keywords>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>orthogonal</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>path</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>snapping</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.SnapLineDemo" source="SnapLineDemo.java">
    <y:displayname>Orthogonal Snapping</y:displayname>
    <y:summary>Demonstrates EditMode's snapping feature in conjunction with orthogonal edges</y:summary>
    <y:description>Demonstrates EditMode's snapping feature in conjunction with orthogonal edges.
      <br/>
      This demo can be used to toggle the snapping feature on and off. It shows how a custom <b>SnapLine</b>
      (the red vertical line) can be used to snap nodes and edges to other entities.
      Toggling the button in the toolbar toggles snapping on and off, the sliders can be used to adjust the
      preferred distance between nodes and edges. This will influence the "preferred distance snap lines."
    </y:description>
    <y:keywords>
      <y:keyword>ViewMode</y:keyword>
      <y:keyword>SnapLine</y:keyword>
      <y:keyword>snapping</y:keyword>
      <y:keyword>EditMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.RollOverEffectDemo" source="RollOverEffectDemo.java">
    <y:displayname>Roll Over Effect</y:displayname>
    <y:summary>Shows roll over effect for nodes</y:summary>
    <y:description>
      Demonstrates how to create a custom ViewMode that uses yFiles'
      Animation Framework to produce a roll over effect for nodes under the mouse
      cursor.
    </y:description>
    <y:keywords>
      <y:keyword>roll-over</y:keyword>
      <y:keyword>effect</y:keyword>
      <y:keyword>animation</y:keyword>
      <y:keyword>node</y:keyword>
      <y:keyword>ViewMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.MouseInputDemo" source="MouseInputDemo.java">
    <y:displayname>Mouse Input</y:displayname>
    <y:summary>Demonstrates how to create drawable to the view that interacts with the MouseInputMode</y:summary>
    <y:description>
      <p>
      Demonstrates how to add a custom drawable to the view that interacts
      with the MouseInputMode that is registered with class EditMode by default.
      </p>
      <p>
      <b>Usage:</b> Move the mouse over one af the arrows in the upper left
      corner of the view and press it to move the view port in the indicated
      direction.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>Drawable</y:keyword>
      <y:keyword>MouseInputMode</y:keyword>
      <y:keyword>interaction</y:keyword>
      <y:keyword>MouseInputEditorProvider</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.PopupModeDemo" source="PopupModeDemo.java">
    <y:displayname>Popup Menus</y:displayname>
    <y:summary>Demonstrates how to display context sensitive popup menus and how to edit node labels in the view</y:summary>
    <y:description>
      Demonstrates how to display context sensitive popup menus
      in the view.
      <br/>
      This demo does also show how to write an action that opens
      an inlined text editor in the view to modify the label of a node.
      <br/>
      To activate the popup menus right click either on a node, an edge, or
      the view background.
    </y:description>
    <y:keywords>
      <y:keyword>context</y:keyword>
      <y:keyword>context-sensitive</y:keyword>
      <y:keyword>popup</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>editor</y:keyword>
      <y:keyword>PopupMode</y:keyword>
      <y:keyword>PopupMenu</y:keyword>
      <y:keyword>context menu</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.CreateEdgeModeDemo" source="CreateEdgeModeDemo.java">
    <y:displayname>Customized CreateEdgeMode</y:displayname>
    <y:summary>Demonstrates how to customize CreateEdgeMode to prevent the creation of certain edges and to provide feedback</y:summary>
    <y:description>
      Demonstrates how CreateEdgeMode can be customized to prevent
      the creation of certain edges and to provide feedback whether
      creating an edge to the node the mouse is hovering over is possible.
      <br/>
      This demo does only allow the creation of edges that start from nodes labeled
      "start" and end at nodes labeled "end".
    </y:description>
    <y:keywords>
      <y:keyword>edge</y:keyword>
      <y:keyword>creation</y:keyword>
      <y:keyword>odd</y:keyword>
      <y:keyword>even</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>prevent</y:keyword>
      <y:keyword>allow</y:keyword>
      <y:keyword>disallow</y:keyword>
      <y:keyword>CreateEdgeMode</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.PortCreateEdgeModeDemo" source="PortCreateEdgeModeDemo.java">
    <y:displayname>Ports and CreateEdgeMode</y:displayname>
    <y:summary>Demonstrates how CreateEdgeMode can be customized in order to control automatic assignments of ports for edges</y:summary>
    <y:description>
      <p>
      Demonstrates how CreateEdgeMode can be customized in order to
      control automatic assignments of ports for edges.
      <br/>
      Edges are created in such a way, that the source port is always on
      the bottom side of the source node and the target port is always on the top
      side of the target node.
      </p>
      <p>
      <b>Usage:</b> Create some nodes and edges. Select an edge to check its
      source and target ports.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>CreateEdgeMode</y:keyword>
      <y:keyword>edge</y:keyword>
      <y:keyword>creation</y:keyword>
      <y:keyword>port</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.HyperlinkDemo" source="HyperlinkDemo.java">
    <y:displayname>Hyperlinks</y:displayname>
    <y:summary>Demonstrates how to use a HtmlLabelConfiguration to trigger and process hyperlink events </y:summary>
    <y:description>
      <p>
      Demonstrates how to use <code>y.view.HtmlLabelConfiguration</code> to
      trigger and process hyperlink events with HTML formatted label text.
      </p>
      <p>
      When clicking on an external link such as
      <br/>
      <code>&lt;a href="http://www.yworks.com/products/yfiles"&gt;yFiles for Java&lt;/a&gt;</code>,
      <br/>
      a dialog is opened that displays the link's destination in response to the
      generated hyperlink event.
      </p>
      <p>
      Additionally, a custom protocol <code>graph</code> is used to allow
      in-graph navigation. E.g. clicking on
      <br/>
      <code>&lt;a href="graph://yfilesforjava"&gt;yFiles for Java&lt;/a&gt;</code>
      <br/>
      will navigate to the first node in the graph that has a corresponding
      <br/>
      <code>&lt;a name="yfilesforjava"&gt;&lt;/a&gt;</code>
      <br/>
      declaration in its label text.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>configuration</y:keyword>
      <y:keyword>HTML</y:keyword>
      <y:keyword>hyperlink</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>link</y:keyword>
      <y:keyword>EditMode</y:keyword>
      <y:keyword>internet</y:keyword>
    </y:keywords>
  </y:demo>

  <y:demo javaname="demo.view.viewmode.SmartLabelModelDemo" source="SmartLabelModelDemo.java">
    <y:displayname>Smart Label Model</y:displayname>
    <y:summary>Demonstrates how to use a SmartNodeLabelModel and a SmartEdgeLabelModel</y:summary>
    <y:description>
      <p>
        Demonstrates how to use <code>y.view.SmartNodeLabelModel</code> and
        <code>y.view.SmartEdgeLabelModel</code>.
      </p>
      <p>
        Both models allow for labels to be placed freely at every position.
        By default, node labels using <code>SmartNodeLabelModel</code> snap to the
        borders and the center of the node as well as the node's other labels.
        Edge labels using <code>SmartEdgeLabelModel</code> snap to the edge itself as
        well as an imaginary snap segment to the left and an imaginary snap segment
        to the right of the edge.
      </p>

      <h3>Node Labels</h3>
      <dl>
        <dt>Changing Label Position</dt>
        <dd>
          The labels can be moved to every position and will snap to the borders and the center of the node.
          <br/>
          It is also possible to disable snapping by pressing <code>Ctrl</code> when the label is dragged.
        </dd>
        <dt>Changing Label Options</dt>
        <dd>
          To change label options, use <code>Edit Label</code> from the label's context menu. The label can get a new text,
          it can be rotated and the font size is adjustable. Note how the label behaves.
          It keeps aligned to the node and grows/shrinks in a pleasant way.
        </dd>
        <dt>Resizing Nodes</dt>
        <dd>
          It is possible to change the size of the node where the label belongs. The label will adjust its position relative
          to the node and keep its alignment.
        </dd>
      </dl>

      <h3>Edge Labels</h3>
      <dl>
        <dt>Changing Label Position</dt>
        <dd>
          The labels can be moved freely to every position and will snap to three traces: on the edge and left or right of the
          edge. It will snap also to the positions where the edge starts and ends and in the center of every segment.
          <br/>
          It is also possible to disable snapping by pressing <code>Ctrl</code> when the label is dragged.
        </dd>
        <dt>Changing Label Options</dt>
        <dd>
          To change label options, use <code>Edit Label</code> from the label's context menu. The label can get a new text,
          it can be rotated and the font size is adjustable.
        </dd>
      </dl>

      <h3>Adding New Graph Elements</h3>
      <p>
        Nodes and edges are added as usual.
      </p>
      <p>
        To add labels to nodes and/or edges use <code>Add Label</code> from the
        element's context menu.
      </p>
    </y:description>
    <y:keywords>
      <y:keyword>SmartEdgeLabelModel</y:keyword>
      <y:keyword>label</y:keyword>
      <y:keyword>model</y:keyword>
      <y:keyword>smart</y:keyword>
      <y:keyword>labeling</y:keyword>
      <y:keyword>PopupMode</y:keyword>
      <y:keyword>OptionHandler</y:keyword>
    </y:keywords>
  </y:demo>

</y:package>
    </y:package>
  </y:package>
</y:content>
